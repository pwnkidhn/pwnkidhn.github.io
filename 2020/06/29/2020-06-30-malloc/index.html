<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pwnkidhn.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="다양한 memory allocatorheap exploit을 구현하기 위해서는 메모리 관리를 위해 사용되는 Allocator에 대한 이해가 필요하다.  dllmalloc - 일반적인 목적의 할당자 ptmalloc2 - glibc jemalloc - FreeBSD와 Firefox tcmalloc - Google(Chrome) libumem - Solaris">
<meta property="og:type" content="article">
<meta property="og:title" content="Malloc - glibc(ptmalloc2)">
<meta property="og:url" content="https://pwnkidhn.github.io/2020/06/29/2020-06-30-malloc/index.html">
<meta property="og:site_name" content="rvkhunLab">
<meta property="og:description" content="다양한 memory allocatorheap exploit을 구현하기 위해서는 메모리 관리를 위해 사용되는 Allocator에 대한 이해가 필요하다.  dllmalloc - 일반적인 목적의 할당자 ptmalloc2 - glibc jemalloc - FreeBSD와 Firefox tcmalloc - Google(Chrome) libumem - Solaris">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/49066484/138287500-84240be1-e56e-48f8-a92e-f74742a2fc84.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bYFw0F/btqFe4iFrTD/iUNNLD6VwTgxhJmSOflqO0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/dyrD5x/btqFe4ivGWx/75uhTqoGOtWIaNV2hSMt50/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/Xstwr/btqFfZnpq2n/uynxJD2aSnSUXVd7ybr6Kk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bfifzP/btqFgHfyW95/EiK79gkdxCLCQnVMHdXAxK/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bRSxbT/btqFed8ks6b/31I2GLWNBUUxuOFvAV9NP0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/DJAMP/btqFfYWrRSF/3bUFQuQoTwKxhrfrQdFZj0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/cGkQBn/btqFfuutQuh/f9FjFkWziqLKnaQGPtwhMk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/dfmYfB/btqFePeQZnf/LjYRo6twBPp92FvnK4KKE1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/HKcX4/btqFe4CSUjC/lIzpoQBbRXMivgLqU9FdM0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/c7jyH0/btqFfunLOTe/96GFUbxbcBdbt3XzQxhGs0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/dZ0SWs/btqFdLKXosg/hy8Ik6Nb19gnuIeWW55fp1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bMbUx7/btqFec2DDCv/SrOhtmPmupkW9mEejnI2kk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/XfnRd/btqFec9ofBF/zl2LCpjRzmQEhudRNFWXk0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/eouLHz/btqFgwSXqQ3/FiKp4HkWub83rtiKK23bok/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/DtUdh/btqFgwZIuOK/T5L3wrFCtIsKRFUyUmiQx1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/uBdWR/btqFe3xaLQR/QLa8KkKN6LeFwfjYiHUGnk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/dNckmz/btqFgyiWeTR/fWJdF3fq5KRrcFqhTKoB90/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/nctV3/btqFedtL1xH/Ox0QwWePghRe6KOPwwbsQ0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/AQBjs/btqFhmo94if/6SppT0OKZKXyFkyf8wuWv1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/DxPpL/btqFhLhVOaS/zoUGSmneXQdF8xxjUXkbSk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/zOfPF/btqFg3jwPXh/VsfZogqPikwzk114kw4yU1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/cS6x8D/btqFhlYyOf6/sry7c1SQ3CX42WHpOXsrFk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/boJPOL/btqFgx6wsDn/mzkjbx0coKUHCg8HPwsQGk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/dpwJYU/btqFiOZ2dg6/hdE10QjVoTAWHTckvm5840/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/cqewZI/btqFiAhMME9/Z8kFVHvkUF28BxSlq3O7U1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/cgiar4/btqFkmQburO/WBtrk4YETygknSGVBlLANk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/btK37x/btqFhlZLYK5/wZcwR1N2jH9481u8srVWL1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bGZW6h/btqFjdfn7zH/2VkQTQ0KnjJ4AKHcnkykok/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bnr7IZ/btqFjFWOLAJ/CDOl4QlxW43IHj4zvIsqW1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/chdXE9/btqFhLjCvvc/QXgz6thKdgNxZVXE8zfZo0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/brJQKB/btqFiAIXUZH/Gt37rSbONdx1NZeI8579m1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/cUEc85/btqFhLxbVnC/uH1J1YDy5Upqf6YI2SXWFk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/CSE3x/btqFhK6aLHL/eAltZ7LMuR0wVnMavYMbT1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/c2OJGW/btqFknn903G/RGEggi2wqPM9veObJXAveK/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/E3OQ5/btqFhMv8yTv/w6wYv3RKvESRQGwFVrWEGk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/tCTOL/btqFiOAeHPF/ECdWw4C4lVD0kIqPwVCRMk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/cc2ObH/btqFjFbv2sp/GPguvCaoRvlKxNQ2kntYD0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/mevsd/btqFiy5vG7r/xOIVDMEukkT7MP6yCYKdc0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/baowZv/btqFiAPQIvH/KCwqL2rOYfMYyygZqLbke0/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/uVAnF/btqFkI6IZp7/oebaRO9mgzu9oaiv4E4jAk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bcQlgE/btqFhMwaVTB/2in6j4lpemr5md3bwqXk9K/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/zNDin/btqFhK6dOm8/FvFKxNxqVLlXiNKRqxKV31/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/dcqJcI/btqFkmwV7Is/49edJHR7GX4xYlIfl2ny30/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/d1PLuz/btqFkTOrxdy/jhgbamKIK9bLWaQeQ6bKmK/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/bu8Mpb/btqFknWMET1/0Qa8di0M5Hv1cAvxn4JCtK/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/buIpXb/btqFmuUOOJe/tbPsbUnOajN6gTH86fu6c1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/JKQMg/btqFk76SEEw/i1fTEMbt85aI8ch6KKyoJ1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/ljz1L/btqFjqNnUv6/4vAXUaah7F1dew2KwTdRC1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/pqv0s/btqFknCCVTE/754R5SKZwD1yKafQukbbBK/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/pBIcq/btqFjp8GJ7q/gxaKHLkhjhohQOWN4cxsX1/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/wz1op/btqFnjetERJ/Z5fcLnkXBf0q8xmZIY5r51/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/r2QXU/btqFlje0b56/Kgf2kinlQzkDsx1ARZ4oCk/img.png">
<meta property="og:image" content="https://blog.kakaocdn.net/dn/1YJRM/btqFk7skjCc/WRXlVZCiMhjtggIgzbNri1/img.png">
<meta property="article:published_time" content="2020-06-29T15:00:00.000Z">
<meta property="article:modified_time" content="2021-10-26T08:27:59.017Z">
<meta property="article:author" content="rvkhun">
<meta property="article:tag" content="malloc">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/49066484/138287500-84240be1-e56e-48f8-a92e-f74742a2fc84.png">

<link rel="canonical" href="https://pwnkidhn.github.io/2020/06/29/2020-06-30-malloc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Malloc - glibc(ptmalloc2) | rvkhunLab</title>
  <meta name="google-site-verification" content="eBj8hDfb8V5sujjVERa_zAbaTQFLbQzowFQfUz3Rhw8">
  <meta name="naver-site-verification" content="7c18a15cd138e9448d263381fe6201215fc40046">

  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="rvkhunLab" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rvkhunLab</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Write about System Hacking</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pwnkidhn.github.io/2020/06/29/2020-06-30-malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/raccoon1.jpg">
      <meta itemprop="name" content="rvkhun">
      <meta itemprop="description" content="Security Researcher / CTF Player">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rvkhunLab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Malloc - glibc(ptmalloc2)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-30T00:00:00+09:00">2020-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-26 17:27:59" itemprop="dateModified" datetime="2021-10-26T17:27:59+09:00">2021-10-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="다양한-memory-allocator"><a href="#다양한-memory-allocator" class="headerlink" title="다양한 memory allocator"></a>다양한 memory allocator</h2><p>heap exploit을 구현하기 위해서는 메모리 관리를 위해 사용되는 Allocator에 대한 이해가 필요하다.</p>
<ul>
<li>dllmalloc - 일반적인 목적의 할당자</li>
<li>ptmalloc2 - glibc</li>
<li>jemalloc - FreeBSD와 Firefox</li>
<li>tcmalloc - Google(Chrome)</li>
<li>libumem - Solaris</li>
</ul>
<h3 id="ptmalloc2"><a href="#ptmalloc2" class="headerlink" title="ptmalloc2"></a>ptmalloc2</h3><ul>
<li>ptmalloc2는 리눅스 GLIBC에서 사용하는 메모리 할당자이다.</li>
<li>운영체제마다 메모리 할당자가 동작하는 방식은 각각 다르며, ptmalloc2는 리눅스 유저 모드에서 주로 사용하는 할당자이다.</li>
<li>ptmalloc2는 glibc 2.23 버전과 glibc 2.26 ( Tcache )이후 버전 동작 방식이 조금 달라졌다.</li>
<li>ptmalloc2는 dlmalloc 코드를 기반으로 하며 멀티 스레드에서 사용되도록 확장되었다. </li>
<li>ptmalloc2는 사용하면 한 번에 두 개 이상의 메모리 영역을 활성화하여 멀티 스레드 어플리케이션을 효율적으로 처리 할 수 있다.</li>
<li>복수의 스레드가 동시에 malloc을 호출하면 각 스레드는 별도의 힙 세그먼트가 생성되고, 해당 힙을 유지 보수하는 데이터 구조도 분리되어 메모리에 할당된다.</li>
<li>따라서 서로 다른 스레드가 서로 간섭하지 않고 서로 다른 메모리 영역에 접근 할 수 있다.</li>
<li>이렇게 각각의 스레드의 유지를 위해 분배된 힙과 freelist data structures의 행동을 per thread arena라고 부른다.</li>
</ul>
<span id="more"></span>

<h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Malloc에 메모리 할당을 요청하면 넓은 메모리의 영역(“Heap”)을 다양한 크기의 덩어리(“Chunk”)로 나눈다.</p>
<ul>
<li>Chunk에는 Allocate Chunk, Free Chunk, Top Chunk, Last Remainder Chunk가 있다.<ul>
<li>Allocate Chunk : malloc이나 calloc 함수 등 동적 메모리 할당 함수를 통해 할당된 청크를 말한다.</li>
<li>Free Chunk : free 함수 등 동적 메모리 해제 함수를 통해 해제된 청크를 말한다.</li>
<li>Top Chunk : 힙 메모리의 마지막에 위치해있는 청크를 말한다. Top Chunk의 마지막은 힙 메모리 영역의 끝이다. 메모리 할당 요청이 들어왔을 때, 사용할 적절한 Free Chunk가 없으면 Top Chunk를 쪼개어 사용한다.</li>
<li>Last Remainder Chunk : 작은 사이즈의 할당 요청이 들어왔을 때, Free Chunk가 쪼개지고 남은 청크를 말한다. Last Remainder Chunk는 연속된 작은 사이즈의 할당 요청이 들어왔을 때 비슷한 주소에 힙 청크가 할당되는 할당의 지역성을 유지시키기 위해 사용된다.<ul>
<li>Allocator는 메모리를 할당할 때 Free chunks 중에서 사용가능한 chunk가 있는지 확인한다. 만약 요청한 크기와 일치하는 Chunk가 없고, 요청된 크기 보다 큰 Chunk가 있다면 해당 Chunk를 분할한다. 이때 분할되고 남은 Chunk가 “Last Remainder Chunk”이다.</li>
</ul>
</li>
</ul>
</li>
<li>각 청크에는 크기와 인접한 청크의 위치에 대한 메타 데이터를 가지고 있다.<ul>
<li>메타 데이터를 이용하여 해당 chunk가 사용중인지 또는 해제되었는지를 알 수 있다.</li>
<li>그리고 이전 청크가 사용중인지 해제되었는지도 알 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="struct-of-malloc-chunk"><a href="#struct-of-malloc-chunk" class="headerlink" title="struct of malloc_chunk"></a>struct of malloc_chunk</h2><p><img src="https://user-images.githubusercontent.com/49066484/138287500-84240be1-e56e-48f8-a92e-f74742a2fc84.png" alt="image"></p>
<p><img src="https://blog.kakaocdn.net/dn/bYFw0F/btqFe4iFrTD/iUNNLD6VwTgxhJmSOflqO0/img.png" alt="image2"></p>
<ul>
<li>free 요청이 발생해 메모리 관리자가 메모리 해제를 수행하려면, 원래 할당했던 메모리의 크기를 정확하게 알고 있어야 한다.</li>
<li>메모리 관리자가 그러한 정보를 기억하는 일반적인 방식은 메모리를 할당할 때 할당된 메모리 블록 첫 부분에 그 블록의 크기를 써 두고,  할당 요청 코드에게는 그 크기를 쓴 부분 이후의 메모리 주소를 반환한다. </li>
<li>따라서 메모리를 요청할때 32bit인 경우, 헤더(8byte) + 요청한크기(8배수 align), 64bit인 경우, 헤더(16byte) + 요청한크기(16배수 align)이 할당된다. </li>
<li>이때 헤더는 prev_size, size로 되어있으며 prev_size는 메모리가 할당 되었을때 데이터 영역으로 사용되므로, align된 요청한 크기 + prev_size 크기 만큼 데이터를 저장할 수 있다.</li>
<li>ex) malloc(32)를 한 경우 (32=0x20) 32는 16배수 이므로 헤더(16byte) + 요청한크기(32byte) = 48byte(0x30)이 할당된다. 여기서 헤더의 16byte중 prev_size의 8byte가 추가로 데이터 영역에 포함되므로 데이터 영역은 40byte가 된다. 즉, malloc(40)까지는 요청했을 경우 48byte(0x30)가 할당된다. 만약 malloc(41)을 했을 경우 48byte(0x30)을 초과하여 다시 16배수로 align을 해줘야 한다. 그러므로 헤더(16byte) + 요청한크기(41byte -&gt; 48byte(가장 가까운 16배수) = 64byte(0x40)이 할당된다. </li>
<li>malloc(32) ~ malloc(40) = 48byte(0x30)[chunk_size]이 할당된다.</li>
<li>malloc(41) ~ malloc(48) ~ malloc(56) = 64byte(0x40)[chunk_size]이 할당된다.</li>
<li>malloc(57) ~ malloc(64) ~ malloc(72) = 80byte(0x80)[chunk_size]이 할당된다.</li>
</ul>
<p>malloc()은 각 Chunk를 관리하기 위해 malloc_chunk 구조체인 mchunkptr를 선언한다.</p>
<ul>
<li>malloc_chunk 구조체는 앞에서 설명한 메타데이터 이다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dyrD5x/btqFe4ivGWx/75uhTqoGOtWIaNV2hSMt50/img.png" alt="1"><br><img src="https://blog.kakaocdn.net/dn/Xstwr/btqFfZnpq2n/uynxJD2aSnSUXVd7ybr6Kk/img.png" alt="2"></p>
<p>구조체 malloc_chunk은 6개의 정보를 관리한다.</p>
<ul>
<li>prev_size : 이전 힙 청크가 해제되었을 경우 해제된 힙 청크의 크기를 저장한다. 해제되기 전까지는 이전 힙 청크의 데이터 영역으로 사용된다.</li>
<li>size : 할당된 현재 힙 청크의 크기를 저장하고있으며, 3개의 비트 플래그가 존재한다.<ul>
<li>Flags (3bit)<ul>
<li>PREV_INUSE <a href="0x1">P</a> : 해당 비트는 이전 힙 청크가 해제된 경우 설정 된다. 1은 이전 청크가 해제되지 않았을 경우이고, 0은 이전 청크가 해제되었을 때 나타내는 값이다.</li>
<li>IS_MMAPPED <a href="0x2">M</a> : 해당 비트는 현재 청크가 mmap 시스템 콜을 사용하여 할당된 경우 설정된다.</li>
<li>NON_MAIN_ARENA <a href="0x4">N</a> : 해당 비트는 현재 청크가 main_arena에서 관리하지 않을 경우에 설정된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Free chunk는 크기와 히스토리에 따라 다양한 목록에 저장되며, 이러한 목록들을 “bins”라고 한다.</p>
<ul>
<li>fd(Forward pointer) : fd 포인터가 위치한 주소가 실제로 데이터 영역의 시작 부분이며, 할당되었을 때에는 사용하지 않는다. 힙 청크가 해제되었을 때 동일한 bin에 존재하는 다음 Free 청크의 포인터를 가진다.</li>
<li>bk(Backward pointer) : 동일한 bin에 존재하는 이전 Free 청크의 포인터를 가진다.</li>
<li>fd_nextsize : large bin에서 사용하는 포인터로, 현재 힙 청크의 크기보다 작은 힙 청크의 주소를 가진다.</li>
<li>bk_nextsize : large bin에서 사용하는 포인터로, 현재 힙 청크의 크기보다 큰 힙 청크의 주소를 가진다.</li>
</ul>
<p>모든 청크의 크기는 MALLOC_ALIGNMENT(2 * sizeof(size_t))의 배수이다.</p>
<ul>
<li>32bit의 경우 size_t의 크기가 4byte이기 때문에 chunk의 크기는 8의 배수가 된다.</li>
<li>64bit의 경우 size_t의 크기는 8byte이기 때문에 chunk의 크기는 16의 배수가 된다.</li>
<li>따라서 청크의 mchunk_size에서 3 LSB(least significant bit)를 플래그로 사용될 수 있다.</li>
</ul>
<h3 id="Allocate-Chunk"><a href="#Allocate-Chunk" class="headerlink" title="Allocate Chunk"></a>Allocate Chunk</h3><p><img src="https://blog.kakaocdn.net/dn/bfifzP/btqFgHfyW95/EiK79gkdxCLCQnVMHdXAxK/img.png" alt="3"></p>
<p>Allocate Chunk는 할당자로 부터 메모리를 할당을 받아서 사용중인 메모리 덩어리 이다.</p>
<ul>
<li>이전의 Chunk가 사용가능 할 때, 이전의 Chunk의 크기가 mchunk_prev_size에 저장된다.</li>
<li>해당 chunk의 크기가 mchunk_size에 저장되고, 필드의 맨 끝 3bit는 flag 정보를 나타낸다.</li>
<li>malloc_chunk의 다른 필드(fd,bk)는 할당되어 있는 청크에서는 사용하지 않는다. 따라서 할당되어 있는 청크는 사용자 데이터가 저장되어 있다.</li>
<li>사용자가 요청한 크기는 malloc_chunk를 저장하고 메모리를 정렬하기 위해서는 약간의 공간이 여분으로 필요하기 때문에 사용할 수 있는 크기(청크 내부를 나타내는 크기)로 변환된다.</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/bRSxbT/btqFed8ks6b/31I2GLWNBUUxuOFvAV9NP0/img.png" alt="4"><br><img src="https://blog.kakaocdn.net/dn/DJAMP/btqFfYWrRSF/3bUFQuQoTwKxhrfrQdFZj0/img.png" alt="5"></p>
<p>malloc()이 호출되기 전이다.</p>
<ul>
<li>시스템은 Heap 공간이 필요한 경우에만 프로세스에 해당 공간을 맵핑한다. </li>
<li>기본적으로 맵핑되어 있지 않다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cGkQBn/btqFfuutQuh/f9FjFkWziqLKnaQGPtwhMk/img.png" alt="6"></p>
<p>malloc()이 호출된 후에 이 프로세스에 Heap 공간이 매핑되었다.</p>
<p><img src="https://blog.kakaocdn.net/dn/dfmYfB/btqFePeQZnf/LjYRo6twBPp92FvnK4KKE1/img.png" alt="7"></p>
<p>할당자로 부터 할당받은 첫번째 Heap의 포인터는 0x602010이다.</p>
<ul>
<li>145(0x91)가 size(0x602008)에 저장되어 있다.<ul>
<li>할당자에 의해 할당되는 청크의 크기는 MALLOC_ALIGNMENT의 배수가 된다.</li>
<li>이 시스템은 64bit이며, size_t의 크기가 8byte이기 때문에 할당되는 청크의 크기는 모두 16의 배수가 되어야한다.</li>
<li>136(0x88)은 16의 배수가 아니며, 해당 수와 가장 가까운 16의 배수는 144이다.</li>
<li>할당자는 이 크기로 청크를 할당한다.</li>
</ul>
</li>
<li>그리고 해당 값에 PREV_INUSE <a href="0x1">P</a> 플래그를 더한 값이 145(0x91)이다.<ul>
<li>해당 chunk가 프로세스에 매핑된 heap 공간의 최상위에 존재하기 때문에 해당 chunk 앞에 새로운 chunk를 할당할 수 없다.</li>
<li>그래서 해당 청크에 PREV_INUSE <a href="0x1">P</a> 플래그가 설정된다.</li>
</ul>
</li>
<li>할당이 가능한 메모리의 크기가 (0x602098)에 저장된다. (Top Chunk 크기)</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/HKcX4/btqFe4CSUjC/lIzpoQBbRXMivgLqU9FdM0/img.png" alt="8"></p>
<p>할당자로부터 할당받은 두번째 Heap의 포인터는 0x6020a0이다.</p>
<ul>
<li>해당 청크의 크기는 97(0x61)이다. </li>
<li>애플리케이션이 요청한 크기는 80(0x50)이다. (16배수)</li>
<li>하지만 할당자는 청크를 관리하기 위해 필요한 헤더(prev_size,size)를 저장하기 위해 요청된 크기에 16을 더해서 메모리를 할당한다.</li>
<li>그리고 해당 청크 앞에 사용중인 청크가 있기 때문에 그 값에 PREV_INUSE <a href="0x1">P</a> 플래그가 더해진다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/c7jyH0/btqFfunLOTe/96GFUbxbcBdbt3XzQxhGs0/img.png" alt="9"></p>
<p>프로세스는 free()함수를 이용하여 첫번째 청크(0x602010)를 해제한다.</p>
<ul>
<li>이로 인해 0x602010 ~ 0x602018 메모리에 fd, bk 값이 저장된다.</li>
<li>그리고 두번째 chunk의 prev_size에 해제된 chunk의 크기(0x90)가 저장되고, size에는 PREV_INUSE <a href="0x1">P</a> 플래그 값이 빠진 값이 저장된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dZ0SWs/btqFdLKXosg/hy8Ik6Nb19gnuIeWW55fp1/img.png" alt="10"></p>
<p>할당자로부터 할당받은 세번째 Heap의 포인터는 0x602010이다.</p>
<ul>
<li>이 포인터는 처음 할당 된 포인터와 동일하다.</li>
<li>malloc()은 메모리 효율성을 위해 free chunk를 관리한다.<ul>
<li>할당자는 메모리의 할당을 요청받으면 free chunk를 먼저 사용한다.</li>
</ul>
</li>
<li>다시 할당받은 chunk는 이전에 저장된 데이터가 초기화 되지 않고 그대로 존재한다.</li>
<li>변경되는 값은 두번째 chunk의 size값이며, 0x60에서 0x61로 변경된다.<ul>
<li>두번째 chunk의 앞에 chunk가 할당되어 사용중이기 때문에 PREV_INUSE <a href="0x1">P</a> 플래그 값이 추가되었다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/bMbUx7/btqFec2DDCv/SrOhtmPmupkW9mEejnI2kk/img.png" alt="11"></p>
<p>새로 할당받은 heap 메모리는 정상적으로 사용가능하다.</p>
<ul>
<li>값을 입력하게 되면 이전에 저장되어 있던 값을 덮어쓰게 된다.</li>
</ul>
<h3 id="Free-Chunk"><a href="#Free-Chunk" class="headerlink" title="Free Chunk"></a>Free Chunk</h3><p><img src="https://blog.kakaocdn.net/dn/XfnRd/btqFec9ofBF/zl2LCpjRzmQEhudRNFWXk0/img.png" alt="12"></p>
<p>Free chunk는 할당자에게 반환된 chunk 이다.</p>
<ul>
<li>Chunk의 크기에 따라 fd, bk, fd_nextsize, bk_nextsize의 값이 해당 chunk내에 저장된다.<ul>
<li>Chunk의 크기가 최소의 크기 일 경우 fd_nextsize, bk_nextsize의 값을 저장할 수 없다.</li>
<li>이 경우 Free chunk의 크기가 커지지 않는다.<ul>
<li>해당 chunk는 prev_size, size, fd, bk 값만을 메모리에 저장한다.</li>
<li>fd_nextsize, bk_nextsize는 오직 large bin에서만 사용된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/eouLHz/btqFgwSXqQ3/FiKp4HkWub83rtiKK23bok/img.png" alt="13"></p>
<p><img src="https://blog.kakaocdn.net/dn/DtUdh/btqFgwZIuOK/T5L3wrFCtIsKRFUyUmiQx1/img.png" alt="14"></p>
<p>할당자가 할당한 메모리는 다음과 같다.</p>
<ul>
<li>chunk의 크기가 128바이트인 메모리가 3개(0x602010, 0x6020c0, 0x602170) 할당되었다. (0x90)</li>
<li>chunk의 크기가 8바이트인 메모리가 3개(0x6020a0, 0x602150, 0x602200) 할당되었다. (0x20)</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/uBdWR/btqFe3xaLQR/QLa8KkKN6LeFwfjYiHUGnk/img.png" alt="15"></p>
<p>heap1(0x602010)이 해제되면 해당 chunk에 bk,fd 값이 저장된다.</p>
<ul>
<li>이전 청크의 크기(0x90)는 tmp2(0x6020a0)의 “prev_size”에 저장되며, “size”에는 PREV_INUSE [P] (0x1) 플래그의 값을 뺀 값(0x20)이 저장된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dNckmz/btqFgyiWeTR/fWJdF3fq5KRrcFqhTKoB90/img.png" alt="16"></p>
<p>heap2(0x6020c0)가 해제되면 해당 chunk에 fd, bk값이 저장된다.</p>
<ul>
<li>fd(0x6020c0)에 저장되는 값은 해당 chunk 앞에 있는 Free chunk의 mchunkptr(0x602000)이다.</li>
<li>그리고 heap1의 bk(0x602018)에 heap2의 mchunkptr(0x6020b0)이 저장된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/nctV3/btqFedtL1xH/Ox0QwWePghRe6KOPwwbsQ0/img.png" alt="17"></p>
<p>heap3(0x602170)가 해제되면 fd(0x602170)에 해당 chunk 앞에 있는 Free chunk의 mchunkptr(0x6020b0)이 저장된다.</p>
<ul>
<li>그리고 heap2의 bk(0x6020c8)에 heap3의 mchunkptr(0x602160)이 저장된다.</li>
</ul>
<h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><p>해제된 힙 청크(Free Chunk)는 bin이라는 freelist 구조체를 통해 관리된다.</p>
<ul>
<li><p>freelist란 동적으로 메모리를 할당하고 해제할 때 메모리 관리의 효율을 높이기 위해 할당되지 않은 영역을 관리하는 연결 리스트이다.</p>
</li>
<li><p>영역을 해제할 때 해제하려는 영역을 freelist에 추가하고, 할당 요청이 들어왔을 때 freelist에 추가된 영역을 제거하고 해당 영역을 사용힌다.</p>
</li>
<li><p>bins의 종류에는 Fast bin, Small bin, Large bin, Unsorted bin이 있다.</p>
</li>
<li><p>fastbinsY - 이 배열은 fast bin을 수용한다.</p>
</li>
<li><p>bins - 이 배열은 unsorted, small, large bin을 수용한다. 총 126개의 bin이 있다.</p>
<ul>
<li>Bin 1 - Unsorted bin (1개)</li>
<li>Bin 2 ~ Bin 63 - Small bin (62개)</li>
<li>Bin 64 ~ Bin 126 - Large bin (63개)</li>
</ul>
</li>
</ul>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p><img src="https://blog.kakaocdn.net/dn/AQBjs/btqFhmo94if/6SppT0OKZKXyFkyf8wuWv1/img.png" alt="18"><br><img src="https://blog.kakaocdn.net/dn/DxPpL/btqFhLhVOaS/zoUGSmneXQdF8xxjUXkbSk/img.png" alt="19"></p>
<p>M_MXFAST(1)라는 매개변수를 사용해서 “fastbin”에 포함되는 청크의 범위를 설정한다.</p>
<ul>
<li>“fastbin”에 포함되는 chunk 크기의 범위는 0에서 80*sizeof(size_t)/4까지 이다. </li>
<li>“fastbin”의 기본 범위는 0에서 64*sizeof(size_t)/4 이다. (mallopt() 함수로 확장 가능)</li>
<li>32비트 아키텍처에서 패스트빈의 상한은 64byte(64<em>4/4)이며, 64비트 아키텍처에서는 128byte(64</em>8/4)이다.<ul>
<li>해당 크기보다 작은 chunk들이 fastbin에 배치된다.</li>
</ul>
</li>
<li>해당 크기는 매개변수 “value”를 이용하여 변경할 수 있다.<ul>
<li>매개변수를 최대로 설정하면 32비트 아키텍처에서는 최대 80byte(80<em>4/4), 64bit에서는 최대 160byte(80</em>8/4)의 상한을 설정 할 수 있다.</li>
<li>fast bin을 비활성화하려면 0으로 설정하면 된다.</li>
</ul>
</li>
<li>Fastbin은 LIFO(last in, first out)를 사용한다.<ul>
<li>마지막으로 해제 된 chunk가 먼저 재 할당된다.</li>
</ul>
</li>
<li>해당 bin은 최대 10개의 bin 관리 할 수 있으며, 패스트빈의 상한 값보다 크기가 작은 chunk들을 관리한다.<ul>
<li>64bit 아키텍처의 경우 Fastbin에 포함되는 chunk의 크기는 32, 48, 64, 80, 96, 112, 128 이다.</li>
<li>32bit 아키텍처의 경우 Fastbin에 포함되는 chunk의 크기는 16, 24, 32, 40, 48, 56, 64 이다.</li>
</ul>
</li>
<li>해당 bin은 single-linked list로 구성된다.<ul>
<li>같은 크기의 chunk가 해제되면 마지막으로 해제된 chunk의 fd에 새로 해제된 chunk의 mchunkptr을 저장된다.</li>
<li>bk는 사용하지 않는다.</li>
</ul>
</li>
<li>해당 bin에 포함되는 chunk들은 서로 인접해 있어도 병합하지 않는다.</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/zOfPF/btqFg3jwPXh/VsfZogqPikwzk114kw4yU1/img.png" alt="20"></p>
<p>마지막 free()를 호출한 다음의 코드에 Breakpoint를 설정하고 프로그램을 실행한다.</p>
<ul>
<li>main_arena의 정보는 gdb에 “p main_arena” 명령어를 입력하면 확인할 수 있다.</li>
<li>해제된 chunk들 중 fastbin에 포함되는 chunk들은 fastbinsY에 배치되어 있다.</li>
<li>배치된 chunk들의 크기는 0x20(32) ~ 0x80(128)이다.</li>
<li>malloc(16) ~ malloc(112) -&gt; 0x20(32) ~ 0x80(128)</li>
</ul>
<p>fastbin에서 동일한 chunk들의 관리</p>
<p><img src="https://blog.kakaocdn.net/dn/cS6x8D/btqFhlYyOf6/sry7c1SQ3CX42WHpOXsrFk/img.png" alt="21"></p>
<p>해제된 chunk들 중 가장 나중에 free된 chunk가 fastbinsY에 배치된다.</p>
<ul>
<li>이 chunk의 fd에는 두번째 free chunk의 mchunkptr이 저장되어 있다.</li>
<li>그리고 두번째 chunk의 fd에는 세번째 chunk의 mchunkptr이 저장되어 있다. (뒤로 갈수록 가장 먼저 free된 chunk)</li>
<li>bk에는 어떠한 값도 배치되지 않는다.</li>
<li>single-linked list 형태로 fastbin들이 연결된다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/boJPOL/btqFgx6wsDn/mzkjbx0coKUHCg8HPwsQGk/img.png" alt="22"></p>
<p>malloc()에 크기가 16byte인 메모리의 할당을 요청하면, Allocater는 해당 크기과 동일한 free chunk가 있는지 fastbinsY에서 확인한다.</p>
<ul>
<li>할당자는 fastbinsY에 동일한 크기의 chunk가 있다면 해당 chunk를 재할당한다.</li>
<li>fastbinsY에는 두번째 free chunk가 배치되었고, 첫번째(가장 최근에 free된) free chunk가 반환되었다.</li>
<li>반환된 chunk에 값이 정상적으로 써진다. </li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dpwJYU/btqFiOZ2dg6/hdE10QjVoTAWHTckvm5840/img.png" alt="23"></p>
<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p><img src="https://blog.kakaocdn.net/dn/cqewZI/btqFiAhMME9/Z8kFVHvkUF28BxSlq3O7U1/img.png" alt="24"></p>
<ul>
<li>Small bin이 포함하는 chunk는 크기가 MIN_LARGE_SIZE 보다 작은 chunk들이다.<ul>
<li>32bit 시스템은 MALLOC_ALIGNMENT는 8이고, SIZE_SZ는 4이다.<ul>
<li>MIN_LARGE_SIZE는 512((64 - 0) * 8)이다.</li>
</ul>
</li>
<li>64bit 시스템은 MALLOC_ALIGNMENT는 16이고,SIZE_SZ는 8이다.<ul>
<li>MIN_LARGE_SIZE는 1024((64 * 0) * 16)이다.</li>
</ul>
</li>
<li>즉, 32bit 시스템에서 Small bin의 범위는 16<del>504byte(64*8-8)이며 64bit에서는 32</del>1008byte이다.</li>
</ul>
</li>
<li>해당 bin은 62개의 bin들을 관리하며, doubly-linked list로 구성된다.<ul>
<li>같은 크기의 chunk가 해제되면 마지막으로 해제된 chunk의 bk에 새로 해제된(나중에 해제된) chunk의 mchunkptr가 저장된다.</li>
<li>새로 해제된 chunk의 fd에 마지막으로 해제된(먼저 해제된) 같은 크기의 chunk의 mchunkptr가 저장된다.</li>
</ul>
</li>
<li>Small bin은 FIFO(First In, First Out)을 사용한다.<ul>
<li>먼저 해제 된 청크가 먼저 재 할당된다.</li>
</ul>
</li>
<li>Small bin에 해당되는 chunk들은 서로 인접하게 배치될수 없다.<ul>
<li>해당 chunk가 서로 인접해 있을 경우 하나의 chunk로 병합된다.</li>
</ul>
</li>
<li>Small bin은 각 16바이트 크기를 가지는 청크 binlist를 가진다.<ul>
<li>ex) 첫 번째 Small bin(Bin 2)은 32바이트 크기의 청크 binlist를 가지며, 두 번째 small bin(Bin 3)은 48바이트 크기의 청크 binlist를 가지는 식으로, 이어진다.</li>
</ul>
</li>
</ul>
<p>bin의 인덱스는 smallbin_index() 함수를 이용하여 확인 할 수 있다.</p>
<ul>
<li>이함수는 SMALLBIN_WIDTH을 사용해서 해당 시스템이 32bit인지 64bit인지 확인한다.<ul>
<li>64bit의 경우 chunk 크기를 16으로, 32bit의 경우 chunk의 크기를 8로 나눈다음, 그 값에 SMALLBIN_CORRECTION를 더 한다.</li>
<li>이 값이 해당 chunk에 대한 bin 인덱스 이다.</li>
</ul>
</li>
<li>예를 들어 64bit에서 144byte의 free chunk의 bin의 인덱스는 9(144 &gt;&gt; 4 + 0)이다. bin 9</li>
<li>free chunk의 인덱스는 ((144 &gt;&gt; 4 + 0) - 1) * 2 = 16(fd),17(bk) 이다.</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/cgiar4/btqFkmQburO/WBtrk4YETygknSGVBlLANk/img.png" alt="25"></p>
<p>사이즈가 128byte인 메모리 3개와 200byte 1개와 160byte 2개, 그리고 해당 메모리 사이에 16byte 메모리 할당을 요청한다.</p>
<ul>
<li>“small*”변수들이 가리키는 메모리들 사이에 16byte의 메모리 할당을 요청하지 않으면 Small bin에 해당하는 chunk들이 연속으로 배치되기 때문에 서로 병합된다.</li>
<li>“small*”변수들이 가리키는 메모리들을 모두 해제한 후 200byte, 128byte의 메모리 할당을 요청한다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/btK37x/btqFhlZLYK5/wZcwR1N2jH9481u8srVWL1/img.png" alt="26"></p>
<ul>
<li>free chunk들은 먼저 Unsorted bin에 배치되기 때문에 마지막에 해제된 chunk는 Unsorted bin에서 찾을 수 있다.<ul>
<li>해당 어플리케이션에서 마지막에 해제된 chunk는 0x602300이며, 크기는 176byte이다.</li>
<li>free()를 이용하여 해제할 메모리는 0x6023c0이며, 이 메모리는 마지막에 해제된 chunk과 인접해 있다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/bGZW6h/btqFjdfn7zH/2VkQTQ0KnjJ4AKHcnkykok/img.png" alt="27"></p>
<ul>
<li>free()가 실행되면 두 chunk는 병합되어 하나의 chunk가 된다.<ul>
<li>해당 chunk(0x602300)의 크기가 352byte가 되었다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/bnr7IZ/btqFjFWOLAJ/CDOl4QlxW43IHj4zvIsqW1/img.png" alt="28"></p>
<ul>
<li>크기가 144 (128 + 16) 바이트 인 청크의 인덱스는 16과 17이다.</li>
<li>Unsorted bin에 있던 chunk가 재할당되면 list의 연결이 끊기기 때문에, Allocator는 연결이 끊긴 chunk들을 bins에 배치한다.<ul>
<li>크기가 128byte인 free chunk가 3개 있다.</li>
<li>이 중에서 bins<a href="fd">16</a>에는 마지막에 해제된 chunk가, bins<a href="bk">17</a>에는 먼저 해제된 chunk가 배치된다.</li>
</ul>
</li>
<li>할당자는 해당 chunk 앞,뒤에 있는 chunk의 mchunkptr를 fd와 bk에 배치한다.<ul>
<li>첫번째에 있는 chunk와 끝에 있는 chunk는 fd, bk에 “bins”의 주소를 배치한다.</li>
<li>할당자는 free chunk에 배치된 “bins”의 주소를 하나의 chunk로 본다.</li>
<li>그래서 할당자는 bins[idx]의 주소에서 16을 뺀 주소를 사용한다.</li>
<li>이것은 doubly-linked list 형태이다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/chdXE9/btqFhLjCvvc/QXgz6thKdgNxZVXE8zfZo0/img.png" alt="29"></p>
<p>어플리케이션이 Small bin에 배치된 chunk와 동일한 크기의 메모리 할당을 요청하면, 할당자는 먼저 해제되었던 chunk(0x6020c0)를 재할당한다.</p>
<ul>
<li>그리고 해당 chunk(0x6020c0) 뒤에 있던 chunk(0x602000)가 bins[17]에 배치된다.</li>
</ul>
<p><strong>example2</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/brJQKB/btqFiAIXUZH/Gt37rSbONdx1NZeI8579m1/img.png" alt="30"></p>
<ul>
<li>크기가 272byte인 chunk의 인덱스는 (272/16 -1) * 2 = 32(fd), 33(bk)이다. </li>
<li>bins[32],bins[33]은 bins17으로 하나의 주소를 사용한다.  (bins[30],bins[31] = bins16으로 하나의 주소 사용)</li>
<li>맨처음에 해제된 chunk의 mchunkptr는 bins[33]에 배치된다.</li>
<li>맨마지막에 해제된 chunk의 mchunkptr는 bins[32]에 배치된다.</li>
</ul>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><ul>
<li>Large bin이 포함하는 chunk의 크기가 MIN_LARGE_SIZE와 같거나 큰 chunk들이다.<ul>
<li>64bit 아키텍처의 경우 free chunk의 크기가 1024와 같거나 크면 해당 chunk는 Larger bin에 배치된다.</li>
</ul>
</li>
<li>Large bin이 포함하는 chunk들은 서로 인접해 있을 경우 하나의 chunk로 병합된다.</li>
<li>Large bin은 63개의 bin을 사용하며, small bin과 같이 doubly-linked list로 구성된다.<ul>
<li>그러나 Large bin은 Small Bin과 다르게 하나의 bin에 다양한 크기의 chunk들을 보관한다.</li>
<li>해당 bin들은 bin내에서 크기 별로 정렬되어 할당의 효율성을 높인다.</li>
</ul>
</li>
</ul>
<p>(32bit)</p>
<ul>
<li><p>32개의 bin은 각 64바이트 크기를 가지는 청크의 binlist를 가진다.</p>
<ul>
<li>ie) 첫 번째 large bin(Bin 65)은 512바이트 ~ 568바이트 크기의 청크 binlist를 가지고,</li>
<li>두 번째 large bin(Bin 66)은 576바이트 ~ 632바이트 크기의 청크 binlist를 가지는 식으로, 이어진다.</li>
</ul>
</li>
<li><p>16개의 bin은 각 512바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>8개의 bin은 각 4,096바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>4개의 bin은 각 32,768바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>2개의 bin은 각 262,144바이트 크기를 가지는 청크의 binlist를 가진다.</p>
</li>
<li><p>1개의 bin은 남은 크기를 가지는 청크를 가진다.</p>
</li>
<li><p>small bin과 달리, large bin 내부의 청크는 동일한 크기를 가지고 있지 않다. 따라서, 내림차순으로 저장된다.</p>
<ul>
<li>가장 큰 청크는 binlist의 가장 앞쪽에 저장되고, 가장 작은 청크는 binlist의 가장 뒷쪽에 저장된다.</li>
<li>fd로 갈 수록 크기가 작고, bk로 갈 수록 크기가 크다.</li>
</ul>
</li>
<li><p>fd_nextsize(나보다 작은 크기)와 bk_nextsize(나보다 큰 크기)를 사용하여 크기 순으로 정렬, 동일한 크기의 chunk 끼리는 연결되지 않는다. </p>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cUEc85/btqFhLxbVnC/uH1J1YDy5Upqf6YI2SXWFk/img.png" alt="31"><br><img src="https://blog.kakaocdn.net/dn/CSE3x/btqFhK6aLHL/eAltZ7LMuR0wVnMavYMbT1/img.png" alt="32"></p>
<p>Large bin에 해당하는 chunk들의 인덱스는 largebin_index_32(), largebin_index_64() 함수를 이용하여 확인할 수 있다.</p>
<ul>
<li>free chunk의 크기를 쉬프트 연산을 이용하여 나누고, 그 값이 조건에 만족하는 값이라면 기본 인덱스 값을 더한 값이 해당 chunk의 인덱스 값이 된다.</li>
<li>ex)64bit 아키텍처에서 chunk의 크기가 3072 ~ 3120인 chunk들은 bin[96]에 보관된다. 48 + (3072 &gt;&gt; 6) = 96</li>
</ul>
<p><strong>example</strong></p>
<p><img src="https://blog.kakaocdn.net/dn/c2OJGW/btqFknn903G/RGEggi2wqPM9veObJXAveK/img.png" alt="33"></p>
<p>1024, 1040, 1056 byte인 메모리 3개, 200byte 1개, 1120byte 2개, 그리고 해당 메모리 사이에 16byte 메모리 할당을 요청한다.</p>
<ul>
<li>“large*” 변수가 가리키는 메모리들 사이에 16byte의 메모리 할당을 요청하지 않으면 Large bin에 해당하는 chunk들이 연속으로 배치되기 때문에 서로 병합된다.</li>
<li>“large*” 변수가 가리키는 메모리들을 모두 해제한 후 200byte, 1040byte의 메모리 할당을 요청한다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/E3OQ5/btqFhMv8yTv/w6wYv3RKvESRQGwFVrWEGk/img.png" alt="34"></p>
<ul>
<li>마지막으로 해제된 chunk는 0x602db0이며, 크기는 1136byte이다.<ul>
<li>free()를 이용하여 해제할 메모리는 0x603230이며, 이 메모리는 마지막에 해제된 chunk과 인접해 있다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/tCTOL/btqFiOAeHPF/ECdWw4C4lVD0kIqPwVCRMk/img.png" alt="35"></p>
<ul>
<li>free()가 실행되면 두 chunk는 병합되어 하나의 chunk가 된다<ul>
<li>해당 chunk(0x602db0)의 크기가 2272byte가 되었다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cc2ObH/btqFjFbv2sp/GPguvCaoRvlKxNQ2kntYD0/img.png" alt="36"></p>
<p>크기가 1040(1024 + 16)byte 인 chunk의 인덱스는 126 및 127이다.</p>
<ul>
<li>Large bin은 Small bin과 동일하게 doubly-linked list 로 chunk들을 연결한다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/mevsd/btqFiy5vG7r/xOIVDMEukkT7MP6yCYKdc0/img.png" alt="37"></p>
<p>할당자는 Large bin에 해당하는 chunk가 “bins”에 배치될때 해당 인덱스에 해당하는 chunk들을 크기 별로 정렬한다.</p>
<ul>
<li>Chunk가 Unsorted bin에 있을 때는 해제된 순서대로 연결되어 있다.<ul>
<li>0x602870 (size : 0x430) &lt;–&gt; 0x602000 (size : 0x410) &lt;–&gt; 0x602430 (size : 0x420)</li>
</ul>
</li>
<li>하지만 Chunk가 “bins”에 배치되면 chunk의 크기순으로 정렬된다.<ul>
<li>0x602870 (size : 0x430) &lt;–&gt; 0x602430 (size : 0x420) &lt;–&gt; 0x602000 (size : 0x410)</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/baowZv/btqFiAPQIvH/KCwqL2rOYfMYyygZqLbke0/img.png" alt="38"></p>
<p>Large bin에 배치된 chunk와 동일한 크기의 메모리 할당을 요청하면, 할당자는 요청한 크기와 동일한 chunk(0x602440)를 재할당한다.</p>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><ul>
<li>청크를 분할한 후에 남은 chunk와 반환된 모든 청크는 Unsorted bin에 먼저 배치된다.<ul>
<li>해당 bin은 Chunk 크기에 대한 제한이 없기 때문에 다양한 크기의 청크가 해당 Bin에 저장될 수 있다. </li>
<li>그러나 Fast bin에 해당하는 chunk는 Unsorted bin에 배치 되지 않는다.</li>
<li>할당자는 Unsorted bin에 요청받은 메모리의 크기와 같은 chunk가 있다면 해당 chunk를 재할당한다.</li>
</ul>
</li>
<li>Unsorted Bin은 1개의 bin만 사용하며, doubly-linked list와 FIFO를 사용한다.<ul>
<li>해당 bin을 이용해 적절한 bin을 찾는 시간이 덜 걸리므로 할당과 해제의 처리가 빠르다.</li>
</ul>
</li>
<li>Allocator에 의해 검색된 Chunk는 바로 재할당 되거나 아니면 원래의 Bin에 배치된다.<ul>
<li>unsorted bin의 모든 chunk는 재할당을 위한 1번의 기회가 주어진다. </li>
<li>재할당에 실패한 경우, 크기에 따라 small bin이나 large bin에 재배치된다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/uVAnF/btqFkI6IZp7/oebaRO9mgzu9oaiv4E4jAk/img.png" alt="39"></p>
<h3 id="fastbinsY-amp-bins"><a href="#fastbinsY-amp-bins" class="headerlink" title="fastbinsY &amp; bins"></a>fastbinsY &amp; bins</h3><p><img src="https://blog.kakaocdn.net/dn/bcQlgE/btqFhMwaVTB/2in6j4lpemr5md3bwqXk9K/img.png" alt="40"><br><img src="https://blog.kakaocdn.net/dn/zNDin/btqFhK6dOm8/FvFKxNxqVLlXiNKRqxKV31/img.png" alt="41"></p>
<h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><ul>
<li>ptmalloc2는 각 스레드가 서로 간섭하지 않고, 서로 다른 메모리 영역에 액세스 할 수 있게 한다.<ul>
<li>이러한 메모리 영역을 “Arena”라고한다.</li>
<li>Main을 포함한 모든 각 Threads에 대한 힙 영역이라고 할 수 있다.</li>
<li>모든 Threads가 각자의 Arena를 가지진 못 하고 32bit와 64bit System과 시스템의 Core 갯수에 따라 Arena의 갯수에 제한이 있다.</li>
<li>제한을 넘어 Arena가 필요한 경우는 기존에 사용하던 Arena를 재사용한다.</li>
</ul>
</li>
<li>응용 프로그램에는 “main arena”이라는 arena가 있다.<ul>
<li>malloc()에는 이 arena를 가리키는 정적 변수가 있으며 각 arena에는 추가 arena를 연결하는 다음 포인터가 있다.</li>
</ul>
</li>
<li>각 Arena는 하나 이상의 힙 메모리를 얻는다.<ul>
<li>main arena는 프로그램의 초기 힙을 사용한다 (.bss 등 직후 시작)</li>
<li>main arena는 힙 공간이 부족하면 확장하여 사용하기 때문에 추가로 힙을 할당 할 필요가 없다. </li>
<li>추가 Arena는 mmap를 통해 힙에 메모리를 할당하고, 이전 힙이 소모되면 더 많은 힙을 힙목록에 추가한다.</li>
</ul>
</li>
<li>Arena는 heap 메모리에서 할당된 chunk들을 관리한다.<ul>
<li>Arena에서 관리되는 chunk들은 응용 프로그램에서 사용 중이거나 사용이 가능한 chunk들 이다.</li>
<li>사용중인 청크는 Arena에서 추적되지 않는다.</li>
<li>Free chunk는 크기와 히스토리에 따라 분류되어 arena에 저장된다.</li>
<li>할당자는 arena에서 할당 요청을 충족하는 chunk를 신속하게 찾을 수 있다.</li>
</ul>
</li>
<li>Arena의 개수는 현재 시스템의 core의 수에 기반된다.<ul>
<li>For 32 bit systems: Number of arena = 2 * number of cores.</li>
<li>For 64 bit systems: Number of arena = 8 * number of cores.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/dcqJcI/btqFkmwV7Is/49edJHR7GX4xYlIfl2ny30/img.png" alt="42"></p>
<p>malloc.c 코드내에 “main_arena”라는 변수가 존재한다.</p>
<ul>
<li>이 변수가 앞에서 언급한 main arena이다. </li>
<li>해당 변수는 “struct malloc_state” 구조체를 사용한다.</li>
</ul>
<h2 id="구조체-정리"><a href="#구조체-정리" class="headerlink" title="구조체 정리"></a>구조체 정리</h2><h3 id="struct-malloc-info-Heap-Header"><a href="#struct-malloc-info-Heap-Header" class="headerlink" title="struct malloc_info (Heap_Header)"></a>struct malloc_info (Heap_Header)</h3><p><img src="https://blog.kakaocdn.net/dn/d1PLuz/btqFkTOrxdy/jhgbamKIK9bLWaQeQ6bKmK/img.png" alt="43"></p>
<ul>
<li>Arena는 각 Threads에 대한 힙 영역이기 때문에 힙 영역의 공간이 부족하면 새로운 영역에 추가로 할당받아 여러 개의 힙 영역을 가질 수 있다(Main Thread 제외).</li>
<li>이런 힙 영역은 어떤 Arena가 관리하고 있는지, 힙 영역의 크기가 어느정도인지, 이전에 사용하던 heap 영역의 정보가 어디에 있는지를 저장할 필요가 있다.</li>
<li>이런 정보를 저장하기 위한 구조체가 malloc_info 구조체이며, 힙에 대한 정보를 저장하기 때문에 Heap_Header라고도 할 수 있다(Main Thread는 확장을 해서 쓰기 때문에 제외)</li>
</ul>
<h3 id="struct-malloc-state-Arena-Header"><a href="#struct-malloc-state-Arena-Header" class="headerlink" title="struct malloc_state (Arena Header)"></a>struct malloc_state (Arena Header)</h3><p><img src="https://blog.kakaocdn.net/dn/bu8Mpb/btqFknWMET1/0Qa8di0M5Hv1cAvxn4JCtK/img.png" alt="44"></p>
<ul>
<li>위의 Heap_Header에서는 단순히 힙 영역에 대한 정보만을 저장하였기 때문에, 힙 영역에서도 어떤 부분을 사용하면 되는지에 대해 Arena는 이를 관리하기 때문에 알고 있을 필요가 있다.</li>
<li>malloc_state 구조체는 각 Arena에 하나씩 주어지고, 해제된 Chunk를 관리하는 연결리스트 bin과 최상위 Chunk인 top chunk와 같은 Arena에 대한 정보를 저장한다.</li>
<li>단일 스레드 arena는 여러 개의 힙을 가질 수 있지만, 이러한 모든 힙에 대해서는 오직 하나의 arena header만이 존재한다.</li>
<li>“malloc_state”의 구조는 다음과 같다.</li>
<li>mutex는 해당 arena에 대한 액세스를 제어하는 데 사용된다.<ul>
<li>mutex를 이용하여 여러 스레드간에 arena 사용 충돌이 발생하것을 방지한다.</li>
<li>패스트 빈에 대한 액세스와 같은 일부 작업은 arena를 잠글 필요가 없다.</li>
<li>이 외에 다른 모든 작업을 하려면 스레드가 arena를 잠글 필요가 있다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/buIpXb/btqFmuUOOJe/tbPsbUnOajN6gTH86fu6c1/img.png" alt="45"></p>
<p>main_arena의 flags는 2개의 bit로 정보들의 유무를 나타낸다.</p>
<ul>
<li>첫번째bit는 해당 Arena가 fastbin(fastchunk)를 가지고 있는지 나타낸다.<ul>
<li>fastbin(fastchunk)이 arena에 있다면 첫번째 bit의 값은 0이, 없다면 1이 보관 된다.</li>
</ul>
</li>
<li>두번째bit는 해당 Arena가 인접한지를 나타낸다.<ul>
<li>해당 arena가 인접한 arena라면 1이, 아니라면 0이 표시된다.</li>
<li>Non-main arena는 하위 힙으로 구성되며 항상 NONCONTIGUOUS_BIT가 설정된다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/JKQMg/btqFk76SEEw/i1fTEMbt85aI8ch6KKyoJ1/img.png" alt="46"></p>
<p>fastbins에 fastbin에 해당하는 free chunk가 배치된다.</p>
<ul>
<li>fastbin에 해당하는 chunk의 인덱스는 fastbin_index()함수를 이용하여 확인할 수 있다.</li>
<li>해당 함수는 우측 시프트를 이용하여 chunk의 크기(sz)를 8(32bit) 또는 16(64bit)으로 나눈 값에 2를 뺀다.</li>
<li>ex)64bit 아키텍처에서 크기가 32byte인 chunk의 인덱스는 0((32 &gt;&gt; 4) - 2)이다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/ljz1L/btqFjqNnUv6/4vAXUaah7F1dew2KwTdRC1/img.png" alt="47"></p>
<p>top에는 Top chunk가 배치된다.</p>
<ul>
<li>Top chunk는 Arena의 가장 상위 영역에 있는 Chunk이며, bin에 포함되지 않는다.</li>
<li>Top chunk는 PREV_INUSE 플래그가 설정된다.</li>
<li>Top chunk는 요청한 힙을 할당할 수 있는 충분한 청크가 bin에 없는 경우에 사용된다.</li>
<li>Top chunk의 크기가 사용자가 요청한 크기보다 큰 경우 top chunk는 2개로 분리된다.<ul>
<li>(사용자가 요청한 크기의 청크와 분할되고 남은 크기의 나머지 청크(Remainder chunk))</li>
</ul>
</li>
<li>Remainder chunk는 새로운 Top chunk가 된다.</li>
<li>할당자는 Top chunk의 크기가 사용자가 요청한 크기보다 작은 경우 조건에 따라 Top chunk의 크기를 증가시키거나, 새로운 Heap영역을 할당한다.<ul>
<li>할당자는 요청받은 chunk의 크기가 DEFAULT_MMAP_THRESHOLD(131072)보다 큰경우 mmap()을 호출하여 새로운 Heap 영역을 매핑한다.</li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/pqv0s/btqFknCCVTE/754R5SKZwD1yKafQukbbBK/img.png" alt="48"></p>
<p>할당자는 메모리를 할당하기에 arena의 공간이 부족할 경우 sbrk()를 호출하여 메모리의 공간을 증가시킨다.</p>
<ul>
<li>malloc.c에서는 MORECORE라는 매크로를 이용하여 sbrk() 함수를 호출한다.</li>
</ul>
<p>last_remainder에는 chunk를 할당 한 후에 남은 chunk가 배치된다.</p>
<ul>
<li>할당자는 요청한 크기와 일치하는 free chunk가 없으면, 요청한 크기보다 큰 free chunk를 요청 크기로 분할하는 경우가 있다.</li>
</ul>
<p>“bins”에 Unsorted bin, Small bin, Large bin가 포함하는 free chunk가 배치된다.</p>
<ul>
<li>이 변수는 배열 변수이며 총(128 * 2 - 2)254개의 chunk 포인터를 배치할 수 있다.</li>
<li>free chunk를 bins에 배치할 때 chunk의 fd, bk 정보를 저장하기 때문 배열의 크기가 128이 아닌 254이다.<ul>
<li>bins[0], bins[1]은 Unsorted bin들이 배치된다.</li>
</ul>
</li>
</ul>
<p>binmap은 bins를 4(BINMAPSIZE)개의 영역으로 나누어서 정보를 배치한다.</p>
<ul>
<li>binmap[0] : 0 ~ 31, binmap[1] : 32 ~ 64, binmap[2] : 65 ~ 96, binmap[3] : 97 ~128<ul>
<li>bins[]에 free chunk가 배치되면, binmap[]에는 그 bin이 해당하는 위치에 해당 bin의 bit가 배치된다.</li>
</ul>
</li>
<li>예를 들어 크기가 256byte인 free chunk의 인덱스는 65이며, binmap[2]에 bit정보가 저장된다.<ul>
<li>할당자는 idx2bit() 함수를 이용하여 저장할 bit값을 계산한다.</li>
<li>binmap[2]에는 2(1 &lt;&lt; (index(65) &amp; 31))가 배치된다.</li>
</ul>
</li>
<li>binmap[] 배열을 사용하면 많은양의 빈 검색이 간소화된다. </li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/pBIcq/btqFjp8GJ7q/gxaKHLkhjhohQOWN4cxsX1/img.png" alt="49"></p>
<p>next는 여러 arena가 있는 경우에 추가 arena을 연결하는 포인터다.</p>
<h3 id="struct-malloc-chunk-Chunk-Header"><a href="#struct-malloc-chunk-Chunk-Header" class="headerlink" title="struct malloc_chunk (Chunk Header)"></a>struct malloc_chunk (Chunk Header)</h3><p><img src="https://blog.kakaocdn.net/dn/wz1op/btqFnjetERJ/Z5fcLnkXBf0q8xmZIY5r51/img.png" alt="50"></p>
<ul>
<li>힙 영역은 사용자에 의해 할당되거나, 해제되거나 하면 Chunk라는 단위로 관리된다.</li>
<li>malloc_chunk는 현재 chunk의 크기와 바로 인접한 이전 chunk의 크기를 저장하고, 해제된 chunk는 bin에 의해 연결리스트로 관리되기 때문에 이중 연결리스트를 위한 포인터 주소를 저장한다.</li>
<li>마지막으로 있는 2개의 chunk 포인터는 large bin을 위해서만 사용된다. large bin은 다른 bin과 다르게 연결리스트에 크기를 대략적으로 관리하기 때문에 연결리스트 내부에서 크기 순으로 추가적인 연결리스트를 가진다.</li>
</ul>
<p>※ </p>
<ul>
<li>Main arena는 여러 개의 힙과 heap_info 구조체를 가질 수 없다. main arena의 공간이 부족한 경우, sbrk 힙 영역은 메모리가 매핑된 영역까지 확장(인접한 영역)된다.</li>
<li>thread arena와 달리, main arena의 arena header는 sbrk 힙 영역의 일부가 아니다. main arena는 전역 변수이며, libc.so의 데이터 영역에서 찾을 수 있다.</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/r2QXU/btqFlje0b56/Kgf2kinlQzkDsx1ARZ4oCk/img.png" alt="51"><br><img src="https://blog.kakaocdn.net/dn/1YJRM/btqFk7skjCc/WRXlVZCiMhjtggIgzbNri1/img.png" alt="52"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.lazenca.net/pages/viewpage.action?pageId=1147929">https://www.lazenca.net/pages/viewpage.action?pageId=1147929</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://tribal1012.tistory.com/141">https://tribal1012.tistory.com/141</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://tribal1012.tistory.com/78">https://tribal1012.tistory.com/78</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dreamhack.io/">https://dreamhack.io/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://studyfoss.egloos.com/5206220">http://studyfoss.egloos.com/5206220</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/malloc/" rel="tag"># malloc</a>
              <a href="/tags/heap/" rel="tag"># heap</a>
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/08/02/2020-08-03-malloc_glibc_2_23/" rel="next" title="malloc (glibc-2.23)">
      malloc (glibc-2.23) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%8B%A4%EC%96%91%ED%95%9C-memory-allocator"><span class="nav-number">1.</span> <span class="nav-text">다양한 memory allocator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ptmalloc2"><span class="nav-number">1.1.</span> <span class="nav-text">ptmalloc2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chunk"><span class="nav-number">2.</span> <span class="nav-text">Chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-of-malloc-chunk"><span class="nav-number">3.</span> <span class="nav-text">struct of malloc_chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Allocate-Chunk"><span class="nav-number">3.1.</span> <span class="nav-text">Allocate Chunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Free-Chunk"><span class="nav-number">3.2.</span> <span class="nav-text">Free Chunk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bin"><span class="nav-number">4.</span> <span class="nav-text">Bin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fast-bin"><span class="nav-number">4.1.</span> <span class="nav-text">fast bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#small-bin"><span class="nav-number">4.2.</span> <span class="nav-text">small bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#large-bin"><span class="nav-number">4.3.</span> <span class="nav-text">large bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsorted-bin"><span class="nav-number">4.4.</span> <span class="nav-text">unsorted bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fastbinsY-amp-bins"><span class="nav-number">4.5.</span> <span class="nav-text">fastbinsY &amp; bins</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arena"><span class="nav-number">5.</span> <span class="nav-text">Arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EC%A0%95%EB%A6%AC"><span class="nav-number">6.</span> <span class="nav-text">구조체 정리</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-malloc-info-Heap-Header"><span class="nav-number">6.1.</span> <span class="nav-text">struct malloc_info (Heap_Header)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-malloc-state-Arena-Header"><span class="nav-number">6.2.</span> <span class="nav-text">struct malloc_state (Arena Header)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-malloc-chunk-Chunk-Header"><span class="nav-number">6.3.</span> <span class="nav-text">struct malloc_chunk (Chunk Header)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">7.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rvkhun" src="/images/raccoon1.jpg">
  <p class="site-author-name" itemprop="name">rvkhun</p>
  <div class="site-description" itemprop="description">Security Researcher / CTF Player</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:pwnkidhn@gmail.com" title="E-Mail → mailto:pwnkidhn@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/" title="YouTube → https:&#x2F;&#x2F;youtube.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-youtube"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/_choizy_" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;_choizy_" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-instagram"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rvkhun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Gemini</a>
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
